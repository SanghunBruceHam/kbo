<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- HTML 파일 캐시 방지 - 강화된 버전 -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="Last-Modified" content="0">
    <meta http-equiv="If-Modified-Since" content="0">
    
    
    <title>KBO 2025 실시간 순위표 | 매직넘버 계산기 일별통계 순위변동 승률추이 피타고리안 클러치 홈원정 상대전적 연승연패 게임별분석</title>
    
    <!-- 검색엔진 최적화 메타데이터 -->
    <meta name="description" content="KBO 2025 실시간 순위표와 20개 분석지표! 매직넘버 계산기, 일자별 순위 게임차 승률 그래프, 시즌 진행률, 순위 변동 차트, 전후반기 비교, 피타고리안 기대승률, 클러치 지수, 홈원정 성적, 상대전적 매트릭스, 월별 주차별 요일별 경기장별 성적, 시리즈 분석, 연승연패 기록, 게임별 상세 분석, 팀간 잔여경기까지 완벽 제공">
    <meta name="keywords" content="KBO 2025, KBO 실시간 순위, 한국프로야구 순위표, 매직넘버 계산기, 일별 통계, 일자별 순위 그래프, 게임차 승률 그래프, 시즌 진행률, 순위 변동 차트, 승률 추이, 전후반기 비교, 피타고리안 기대승률, 운 지수, 클러치 지수, 1점차 승률, 홈원정 성적, 상대전적 매트릭스, 월별 성적, 주차별 분석, 요일별 성적, 경기장별 성적, 시리즈 전적, 위닝 루징 시리즈, 팀간 잔여경기, 연승 연패 분석, 게임별 연속 기록, 팀별 상세 기록, 경기 일정 분석, KIA 타이거즈, 삼성 라이온즈, LG 트윈스, 두산 베어스, KT 위즈, NC 다이노스, SSG 랜더스, 롯데 자이언츠, 한화 이글스, 키움 히어로즈">
    <meta name="author" content="KBO Analytics Dashboard">
    <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <meta name="googlebot" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <meta name="bingbot" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <link rel="canonical" href="https://kbo-dashboard.co.kr/">
    
    <!-- 한국 검색엔진 최적화 -->
    <meta name="naver-site-verification" content="">
    <meta name="daumoa:subject" content="KBO 2025 순위표 시즌 분석">
    <meta name="daumoa:category" content="스포츠>야구">
    <meta http-equiv="Content-Language" content="ko">
    <meta name="geo.region" content="KR">
    <meta name="geo.country" content="Korea">

    <!-- Canonical URL for SEO -->
    <link rel="canonical" href="https://kbo-dashboard.co.kr/">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-G8F8C9SDX3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-G8F8C9SDX3');
    </script>
    
    <!-- 추가 SEO 메타태그 -->
    <meta name="theme-color" content="#1f2937">
    <meta name="msapplication-TileColor" content="#1f2937">
    <meta name="application-name" content="KBO Analytics">
    <meta name="apple-mobile-web-app-title" content="KBO Analytics">
    <meta name="format-detection" content="telephone=no">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- 구조화 데이터 (JSON-LD) - 스포츠 리그 정보 -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SportsOrganization",
      "name": "KBO 리그",
      "alternateName": ["한국프로야구", "Korea Baseball Organization"],
      "description": "대한민국 프로야구 리그 KBO의 2025시즌 실시간 순위표 및 통계 분석",
      "url": "https://kbo-dashboard.co.kr/",
      "sameAs": [
        "https://www.koreabaseball.com/",
        "https://www.naver.com/search?q=KBO",
        "https://sports.daum.net/proleague/kbo"
      ],
      "sport": "야구",
      "location": {
        "@type": "Country",
        "name": "대한민국",
        "alternateName": "Korea"
      },
      "memberOf": {
        "@type": "SportsLeague",
        "name": "KBO 리그",
        "numberOfTeams": 10,
        "sport": "Baseball"
      }
    }
    </script>
    
    <!-- 구조화 데이터 (JSON-LD) - 웹사이트 정보 -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "KBO 2025 실시간 순위표 & 종합 분석 대시보드",
      "alternateName": ["KBO Analytics Dashboard", "KBO 실시간 순위표", "한국프로야구 종합 통계 플랫폼", "KBO 매직넘버 계산기"],
      "description": "KBO 2025 실시간 순위표와 20개 분석지표 제공! 매직넘버 계산기, 일자별 순위·게임차·승률 그래프, 시즌진행률, 순위변동차트, 승률추이, 전후반기비교, 피타고리안기대승률, 운지수, 클러치지수, 1점차승률, 홈원정성적, 상대전적매트릭스, 월별·주차별·요일별·경기장별성적, 시리즈분석, 팀간잔여경기, 연승연패분석, 게임별상세기록, 팀별일정분석까지 완벽제공",
      "url": "https://kbo-dashboard.co.kr/",
      "inLanguage": "ko-KR",
      "about": {
        "@type": "SportsOrganization",
        "name": "KBO 리그"
      },
      "applicationCategory": "SportsApplication",
      "applicationSubCategory": "Baseball Analytics",
      "featureList": [
        "KBO 2025 실시간 순위표 - 종합 순위 20개 지표별 정렬",
        "매직넘버 계산기 - 우승/플레이오프 진출 조건 분석",
        "일별 통계 - 일자별 순위·게임차·승률 실시간 그래프",
        "시즌 진행률 - 144경기 기준 팀별 진행 상황",
        "순위 변동 차트 - 3월~현재 순위 추이 분석",
        "승률 추이 그래프 - 팀별 승률 변화 시각화",
        "전후반기 비교 - 전반기/후반기 성적 상세 분석",
        "피타고리안 기대승률 - 득실점 기반 운 지수 분석",
        "클러치 지수 - 1점차/2점차/3점차 승률 분석",
        "홈/원정 성적 - 홈경기/원정경기 상세 분석",
        "상대전적 매트릭스 - 10개팀 맞대결 완전 분석",
        "월별 성적 - 3월~10월 월별 승률 트렌드",
        "주차별 분석 - 주간 단위 성적 변화 추이",
        "요일별 성적 - 화~일 요일별 승률 패턴",
        "경기장별 성적 - 9개 구장별 홈원정 분석",
        "시리즈 분석 - 위닝/루징/스플릿 시리즈 기록",
        "연승/연패 기록 - 최대 연승/연패 스트리크 분석",
        "게임별 연속 기록 - 경기별 상세 누적 통계",
        "팀별 상세 기록 - 개별 팀 경기 일정 및 결과",
        "팀간 잔여경기 - 남은 맞대결 일정 매트릭스"
      ],
      "potentialAction": {
        "@type": "SearchAction",
        "target": {
          "@type": "EntryPoint",
          "urlTemplate": "https://kbo-dashboard.co.kr/?q={search_term_string}"
        },
        "query-input": "required name=search_term_string"
      },
      "keywords": "KBO 2025, 한국프로야구, 실시간 순위표 대시보드, 피타고리안 기대승률, 운 지수 분석, 클러치 상황 분석, 일자별 순위 그래프, 게임차 승률 그래프, 상대전적 매트릭스, 전후반기 비교, 팀간 잔여경기수, 요일별 성적, 월별 성적, 주차별 성적, 연승연패 분석, 위닝루징 시리즈, 경기장별 성적, 홈원정 상세 분석, 순위 변동 추이, 게임별 기록 분석, 야구 대시보드, 프로야구 분석, KBO 리그, 한국야구위원회"
    }
    </script>
    
    <!-- 구조화 데이터 (JSON-LD) - KBO 시즌 정보 (개인 분석 사이트) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SportsEvent",
      "name": "KBO 2025 정규시즌 분석 서비스",
      "description": "개인이 운영하는 KBO 2025 정규시즌 데이터 분석 및 통계 제공 웹사이트",
      "url": "https://kbo-dashboard.co.kr/",
      "image": "https://kbo-dashboard.co.kr/magic-number/images/teams/kbo-dashboard-preview.png",
      "startDate": "2025-03-23",
      "endDate": "2025-10-01",
      "eventStatus": "https://schema.org/EventScheduled",
      "location": {
        "@type": "Place",
        "name": "온라인 웹사이트",
        "address": {
          "@type": "PostalAddress",
          "addressCountry": "KR",
          "addressRegion": "온라인",
          "addressLocality": "웹사이트"
        }
      },
      "organizer": {
        "@type": "Person",
        "name": "개인 개발자",
        "alternateName": "KBO 분석 대시보드 운영자",
        "url": "https://kbo-dashboard.co.kr/"
      },
      "performer": [
        {
          "@type": "Organization",
          "name": "KBO 분석 대시보드",
          "description": "KBO 데이터 분석 및 시각화 서비스 제공"
        }
      ],
      "offers": {
        "@type": "Offer",
        "name": "무료 KBO 데이터 분석 서비스",
        "description": "KBO 2025 시즌 실시간 순위표 및 통계 분석 무료 제공",
        "price": "0",
        "priceCurrency": "KRW",
        "availability": "https://schema.org/InStock",
        "validFrom": "2025-01-01",
        "url": "https://kbo-dashboard.co.kr/",
        "category": "Data Analysis Service"
      }
    }
    </script>
    
    <!-- 구조화 데이터 (JSON-LD) - 데이터셋 정보 -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Dataset",
      "name": "KBO 2025 종합 야구 통계 데이터셋 - 20개 분석지표",
      "description": "KBO 2025시즌 종합 야구 통계 데이터셋: 실시간 팀순위, 순위변동차트, 피타고리안승률, 클러치지수, 상대전적매트릭스, 홈원정성적, 경기장별통계, 월별주차별성적, 게임기록, 시리즈전적, 팀간잔여경기, 매직넘버, 일별통계, 전후반기비교 등 20개 세부분석지표 포함한 종합 데이터셋",
      "url": "https://kbo-dashboard.co.kr/",
      "keywords": [
        "KBO 2025", "한국프로야구", "실시간순위변동", "피타고리안승률", "클러치지수", 
        "상대전적매트릭스", "홈원정성적", "경기장별통계", "월별성적", "주차별트렌드",
        "게임기록통계", "시리즈전적", "팀간잔여경기", "매직넘버계산", "일별통계",
        "전후반기비교", "야구통계분석", "프로야구예측", "KBO데이터센터", "스포츠분석"
      ],
      "creator": {
        "@type": "Organization",
        "name": "KBO Analytics Dashboard"
      },
      "publisher": {
        "@type": "Organization", 
        "name": "KBO Analytics Dashboard"
      },
      "dateModified": "2025-08-23",
      "datePublished": "2025-03-23",
      "inLanguage": "ko-KR",
      "spatialCoverage": "대한민국",
      "temporalCoverage": "2025",
      "variableMeasured": [
        {
          "@type": "PropertyValue",
          "name": "실시간 순위",
          "description": "KBO 10개 팀의 실시간 순위 및 순위변동 추적"
        },
        {
          "@type": "PropertyValue", 
          "name": "피타고리안 승률",
          "description": "득점과 실점을 기반으로 한 예상승률 계산"
        },
        {
          "@type": "PropertyValue",
          "name": "클러치 지수",
          "description": "중요한 상황에서의 팀 성과 측정지수"
        },
        {
          "@type": "PropertyValue",
          "name": "상대전적 매트릭스",
          "description": "10개 팀간의 모든 상대전적 데이터"
        },
        {
          "@type": "PropertyValue",
          "name": "홈/원정 성적",
          "description": "홈 경기와 원정 경기 성적 분석"
        },
        {
          "@type": "PropertyValue",
          "name": "경기장별 통계",
          "description": "각 경기장에서의 팀별 성적 통계"
        },
        {
          "@type": "PropertyValue",
          "name": "매직넘버",
          "description": "플레이오프 진출 및 우승을 위한 필요 승수"
        }
      ],
      "distribution": [
        {
          "@type": "DataDownload",
          "encodingFormat": "application/json",
          "contentUrl": "https://kbo-dashboard.co.kr/magic-number/data/api-data.json",
          "description": "메인 순위 및 통계 데이터"
        },
        {
          "@type": "DataDownload", 
          "encodingFormat": "application/json",
          "contentUrl": "https://kbo-dashboard.co.kr/magic-number/data/stats-comprehensive.json",
          "description": "매직넘버 및 확장 대시보드 데이터"
        }
      ],
      "license": {
        "@type": "CreativeWork",
        "name": "개인 프로젝트 - 비상업적 이용 허용",
        "description": "개인이 운영하는 KBO 데이터 분석 프로젝트입니다. 원본 KBO 데이터는 한국야구위원회 소유이며, 본 사이트는 해당 데이터를 분석하여 시각화한 개인 프로젝트입니다.",
        "url": "https://kbo-dashboard.co.kr/"
      }
    }
    </script>

    <!-- 조직/사이트명 인식을 위한 추가 구조화 데이터 -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "KBO Analytics Dashboard",
      "alternateName": ["KBO 분석 대시보드", "KBO 2025 순위표", "한국프로야구 분석센터"],
      "url": "https://kbo-dashboard.co.kr/",
      "logo": "https://kbo-dashboard.co.kr/magic-number/images/teams/kbo-dashboard-preview.png",
      "image": "https://kbo-dashboard.co.kr/magic-number/images/teams/kbo-dashboard-preview.png",
      "description": "KBO 2025 실시간 순위표와 20개 분석지표를 제공하는 한국프로야구 종합 통계 플랫폼",
      "sameAs": [
        "https://kbo-dashboard.co.kr/"
      ],
      "foundingDate": "2025",
      "knowsAbout": [
        "KBO 리그",
        "한국프로야구",
        "야구 통계",
        "스포츠 분석",
        "데이터 시각화"
      ],
      "areaServed": {
        "@type": "Country",
        "name": "대한민국"
      }
    }
    </script>
    
    <!-- Open Graph 소셜미디어 최적화 -->
    <meta property="og:title" content="KBO 2025 실시간 순위표 | 매직넘버 일별통계 순위변동 피타고리안 클러치 홈원정 상대전적">
    <meta property="og:description" content="KBO 2025 실시간 순위표와 20개 분석지표! 매직넘버 계산기, 일자별 순위 그래프, 시즌진행률, 순위변동, 전후반기, 피타고리안, 클러치지수, 홈원정, 상대전적, 월별주차별요일별경기장별 성적까지 완벽 제공">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kbo-dashboard.co.kr/">
    <meta property="og:image" content="https://kbo-dashboard.co.kr/magic-number/images/teams/kbo-dashboard-preview.png">
    <meta property="og:image:width" content="1536">
    <meta property="og:image:height" content="1024">
    <meta property="og:image:alt" content="KBO 2025 순위표 및 시즌 분석 대시보드">
    <meta property="og:site_name" content="KBO Analytics Dashboard">
    <meta property="og:locale" content="ko_KR">
    <meta property="article:author" content="KBO Analytics Dashboard">
    <meta property="article:section" content="Sports">
    <meta property="article:tag" content="KBO,한국프로야구,야구순위,매직넘버">
    
    <!-- Twitter Card 최적화 -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="KBO 2025 실시간 순위표 | 매직넘버 일별통계 순위변동 피타고리안 클러치">
    <meta name="twitter:description" content="KBO 2025 실시간 순위표와 20개 분석지표! 매직넘버, 일자별 그래프, 순위변동, 피타고리안, 클러치, 홈원정, 상대전적, 월별주차별요일별경기장별 성적">
    <meta name="twitter:image" content="https://kbo-dashboard.co.kr/magic-number/images/teams/kbo-dashboard-preview.png">
    <meta name="twitter:image:alt" content="KBO 2025 순위표 및 시즌 분석 대시보드">
    <meta name="twitter:creator" content="@kbo_analytics">
    <meta name="twitter:site" content="@kbo_analytics">
    
    <!-- JSON-LD 구조화된 데이터 - 사이트 이름 명시 -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "KBO Dashboard",
      "alternateName": "KBO 대시보드",
      "url": "https://kbo-dashboard.co.kr/",
      "description": "KBO 2025 실시간 순위표와 20개 분석지표를 제공하는 한국프로야구 통계 대시보드",
      "potentialAction": {
        "@type": "SearchAction",
        "target": {
          "@type": "EntryPoint",
          "urlTemplate": "https://kbo-dashboard.co.kr/"
        }
      },
      "publisher": {
        "@type": "Organization",
        "name": "KBO Dashboard",
        "url": "https://kbo-dashboard.co.kr/",
        "logo": {
          "@type": "ImageObject",
          "url": "https://kbo-dashboard.co.kr/images/kbo-dashboard-preview.png",
          "width": 1536,
          "height": 1024
        }
      },
      "about": {
        "@type": "Thing",
        "name": "KBO 리그",
        "description": "한국프로야구"
      }
    }
    </script>
    
    <!-- 파비콘 및 앱 아이콘 - 검색엔진 최적화 -->
    <link rel="icon" type="image/x-icon" href="magic-number/images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="32x32" href="magic-number/images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="magic-number/images/icons/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="magic-number/images/icons/apple-touch-icon.png">
    <link rel="shortcut icon" type="image/x-icon" href="magic-number/images/icons/favicon-32x32.png">
    <link rel="manifest" href="/manifest.json">
    
    <meta name="theme-color" content="#667eea">
    
    
    <!-- 추가 SEO 최적화 -->
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta name="googlebot" content="index, follow">
    <meta name="bingbot" content="index, follow">
    <meta name="format-detection" content="telephone=no">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    
    
    <!-- 성능 최적화 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://www.googletagmanager.com">
    
    <!-- 지역/언어 설정 -->
    <meta name="geo.region" content="KR">
    <meta name="geo.country" content="KR">
    <meta name="language" content="Korean">
    <link rel="alternate" hreflang="ko" href="https://kbo-dashboard.co.kr/">
    
    <!-- 구조화된 데이터 (JSON-LD) -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": ["WebSite", "DataCatalog"],
        "name": "KBO 2025 종합 분석 대시보드",
        "alternateName": "한국프로야구 실시간 분석 대시보드",
        "description": "한국프로야구 2025시즌의 모든 데이터를 한눈에 분석하고 비교할 수 있는 종합 대시보드. 시즌 진행률, 실시간 순위, 상대전적, 매직넘버 등 제공",
        "url": "https://kbo-dashboard.co.kr/",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://kbo-dashboard.co.kr/"
        },
        "author": {
            "@type": "Organization",
            "name": "KBO 분석 대시보드"
        },
        "publisher": {
            "@type": "Organization",
            "name": "KBO 분석 대시보드"
        },
        "inLanguage": "ko-KR",
        "dateCreated": "2025-01-01",
        "dateModified": "DYNAMIC_DATE_PLACEHOLDER",
        "keywords": ["KBO", "한국프로야구", "2025시즌", "시즌진행률", "순위표", "상대전적", "매직넘버", "야구통계", "실시간분석"],
        "about": {
            "@type": "SportsOrganization",
            "name": "한국야구위원회",
            "alternateName": "KBO"
        },
        "potentialAction": {
            "@type": "SearchAction",
            "target": "https://kbo-dashboard.co.kr/#{search_term_string}",
            "query-input": "required name=search_term_string"
        },
        "breadcrumb": {
            "@type": "BreadcrumbList",
            "itemListElement": [
                {
                    "@type": "ListItem",
                    "position": 1,
                    "name": "홈",
                    "item": "https://kbo-dashboard.co.kr/"
                },
                {
                    "@type": "ListItem", 
                    "position": 2,
                    "name": "시즌 진행률",
                    "item": "https://kbo-dashboard.co.kr/#season-progress"
                },
                {
                    "@type": "ListItem",
                    "position": 3, 
                    "name": "종합 순위",
                    "item": "https://kbo-dashboard.co.kr/#standings"
                }
            ]
        }
    }
    </script>
    
    <script>
        
        // 모바일/태블릿 기기에서만 안내 메시지 표시
        document.addEventListener('DOMContentLoaded', function() {
            // SEO: dateModified를 현재 날짜로 동적 업데이트
            const jsonLdScript = document.querySelector('script[type="application/ld+json"]');
            if (jsonLdScript) {
                const jsonData = JSON.parse(jsonLdScript.textContent);
                jsonData.dateModified = new Date().toISOString().split('T')[0];
                jsonLdScript.textContent = JSON.stringify(jsonData, null, 4);
            }
            const isMobile = /iPhone|iPad|iPod|Android|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isSmallScreen = window.innerWidth <= 768;
            const deviceNotice = document.getElementById('deviceNotice');
            
            // 사용자가 PC 버전 선택했는지 확인
            const forcePCVersion = localStorage.getItem('forcePCVersion') === 'true';
            
            // PC 버전으로 보기 버튼 이벤트
            window.switchToPCVersion = function() {
                localStorage.setItem('forcePCVersion', 'true');
                if (deviceNotice) deviceNotice.style.display = 'none';
                // 모바일 스타일 무효화
                document.body.classList.add('force-desktop');
            };
            
            // 모바일 버전으로 돌아가기 기능
            window.switchToMobileVersion = function() {
                localStorage.removeItem('forcePCVersion');
                location.reload();
            };
            
            // 모바일 기기이거나 화면이 작은 경우에만 표시 (PC 버전 강제 선택하지 않은 경우)
            if (deviceNotice) {
                if (!forcePCVersion && (isMobile || isSmallScreen)) {
                    deviceNotice.style.display = 'block';
                } else {
                    deviceNotice.style.display = 'none';
                }
            }
            
            // PC 버전 강제 선택된 상태라면 모바일 스타일 무효화
            if (forcePCVersion) {
                document.body.classList.add('force-desktop');
            }
            
            // 접근성 문제 방지: body에 aria-hidden이 설정되는 것을 감지하고 제거
            const bodyAriaObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'aria-hidden') {
                        if (document.body.hasAttribute('aria-hidden')) {
                            // body에 aria-hidden 속성 제거
                            document.body.removeAttribute('aria-hidden');
                        }
                    }
                });
            });
            
            bodyAriaObserver.observe(document.body, {
                attributes: true,
                attributeFilter: ['aria-hidden']
            });
        });
    </script>
    
    
    <!-- 리소스 힌트 (성능 최적화) -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    
    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5508768187151867"
         crossorigin="anonymous"></script>
    
    <!-- Coupang Partners -->
    <script src="https://ads-partners.coupang.com/g.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #f5f7fa;
            color: var(--default-color);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* 분석 테이블 공통 변수 정의 */
        :root {
            /* 색상 변수 */
            --positive-bg-light: linear-gradient(135deg, rgba(34, 197, 94, 0.05) 0%, rgba(22, 163, 74, 0.08) 100%);
            --positive-bg-medium: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(22, 163, 74, 0.15) 100%);
            --positive-bg-strong: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(22, 163, 74, 0.25) 100%);
            --positive-color: #059669;
            
            --negative-bg-light: linear-gradient(135deg, rgba(239, 68, 68, 0.05) 0%, rgba(220, 38, 38, 0.08) 100%);
            --negative-bg-medium: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(220, 38, 38, 0.15) 100%);
            --negative-bg-strong: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(220, 38, 38, 0.25) 100%);
            --negative-color: #dc2626;
            
            --neutral-bg-light: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(245, 158, 11, 0.12) 100%);
            --neutral-bg-medium: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(245, 158, 11, 0.25) 100%);
            --neutral-bg-strong: linear-gradient(135deg, rgba(255, 193, 7, 0.3) 0%, rgba(245, 158, 11, 0.35) 100%);
            --neutral-color: #f59e0b;
            
            /* 추가 강도별 그라데이션 */
            --positive-bg-very-light: linear-gradient(135deg, rgba(34, 197, 94, 0.02) 0%, rgba(22, 163, 74, 0.04) 100%);
            --positive-bg-very-strong: linear-gradient(135deg, rgba(34, 197, 94, 0.25) 0%, rgba(22, 163, 74, 0.35) 100%);
            
            --negative-bg-very-light: linear-gradient(135deg, rgba(239, 68, 68, 0.02) 0%, rgba(220, 38, 38, 0.04) 100%);
            --negative-bg-very-strong: linear-gradient(135deg, rgba(239, 68, 68, 0.25) 0%, rgba(220, 38, 38, 0.35) 100%);
            
            --neutral-bg-very-light: linear-gradient(135deg, rgba(255, 193, 7, 0.05) 0%, rgba(245, 158, 11, 0.08) 100%);
            --neutral-bg-very-strong: linear-gradient(135deg, rgba(255, 193, 7, 0.4) 0%, rgba(245, 158, 11, 0.45) 100%);
            
            --default-bg: #f8f9fa;
            --default-color: #666;
            
            /* 표준화된 폰트 사이즈 */
            --font-2xs: 0.7rem;    /* 매우 작은 보조 텍스트 */
            --font-xs: 0.75rem;    /* 작은 보조 텍스트 */
            --font-sm: 0.8rem;     /* 보조 정보 */
            --font-base: 0.85rem;  /* 기본 텍스트 */
            --font-md: 0.9rem;     /* 중간 텍스트 */
            --font-lg: 1rem;       /* 큰 텍스트 */
            --font-xl: 1.2rem;     /* 소제목 */
            --font-2xl: 1.5rem;    /* 중제목 */
            --font-3xl: 2rem;      /* 대제목 */
            --font-4xl: 2.5rem;    /* 메인 제목 */
            --rank-col: 50px;       /* 순위 열 고정 너비 */
            --team-col: 80px;       /* 팀명 열 고정 너비(기본) */
            
            /* 폰트 패밀리 시스템 */
            --font-family-base: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-family-mono: 'Consolas', 'Monaco', 'Courier New', monospace;
            
            /* 폰트 굵기 시스템 */
            --font-weight-light: 300;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;
            
            /* 숫자/데이터 표시용 통합 스타일 */
            --data-font-family: var(--font-family-base);
            --data-font-weight: var(--font-weight-semibold);
            --data-font-size: var(--font-base);
            
            /* 승률 표시용 통합 스타일 (일반 폰트로 통일) */
            --winrate-font-family: var(--font-family-base);
            --winrate-font-weight: var(--font-weight-semibold);
            --winrate-font-size: var(--font-base);
            
            /* 카드 공통 스타일 변수 */
            --card-width: 100%;
            --card-max-width: 100%;
            --card-padding: 8px;
            --card-margin: 0 auto 8px auto;
            --card-border-radius: 15px;
            --card-background: rgba(255, 255, 255, 0.95);
            --card-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            --card-backdrop-filter: blur(10px);

            /* Sticky layering & shadow variables */
            --z-sticky-header: 20;
            --z-sticky-col1-header: 30;
            --z-sticky-col1: 25;
            --z-sticky-col2-header: 40;
            --z-sticky-col2: 35;
            --z-sticky-corner: 50; /* top-left corner cell */
            --sticky-shadow: 2px 0 5px rgba(0,0,0,0.1);
            --sticky-shadow-soft: 0 2px 4px rgba(0,0,0,0.12);
        }

        .container {
            max-width: var(--card-max-width);
            margin: 0 auto;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        
        @media (min-width: 769px) {
            .container {
                padding: 20px;
            }
        }

        .header {
            background: linear-gradient(135deg, #1a237e 0%, #3949ab 100%);
            color: #ffffff;
            padding: 40px 20px 25px 20px;
            margin: 0 0 10px 0;
            width: 100%;
            text-align: center;
            box-sizing: border-box;
            box-shadow: 0 4px 8px rgba(0,0,0,0.12);
        }

        .header-content {
            max-width: 1300px;
            margin: 0 auto;
            padding: 0;
        }

        .header h1 {
            font-size: var(--font-4xl);
            color: #ffffff;
            margin-bottom: 10px;
            font-weight: var(--font-weight-bold);
        }

        .header .subtitle {
            font-size: var(--font-xl);
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 20px;
        }

        .update-info {
            display: inline-block;
            background: rgba(255, 255, 255, 0.15);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: var(--font-md);
            font-weight: var(--font-weight-medium);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .full-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        @media (min-width: 900px) {
            .full-grid {
                grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
                gap: 25px;
                margin-bottom: 30px;
                max-width: 1400px;
                margin-left: auto;
                margin-right: auto;
            }
        }
        
        /* 대형 화면에서는 최대 2-3컬럼으로 제한 */
        @media (min-width: 1400px) {
            .full-grid {
                grid-template-columns: repeat(2, 1fr);
                max-width: 1200px;
            }
        }

        /* 태블릿 이상에서 날짜를 한 줄로 표시 (768px로 낮춤) */
        @media (min-width: 768px) {
            /* 날짜를 한 줄로 표시 */
            .date-cell br {
                display: none;
            }
            
            .date-cell .date-main {
                margin-right: 4px;
            }
            
            .date-cell .date-day {
                margin-right: 4px;
            }
            
            .date-cell .date-time,
            .date-cell .date-holiday {
                margin-left: 4px;
            }
        }
        
        /* PC 버전 전체 컨테이너 폭 제한 */
        @media (min-width: 1024px) {
            .container {
                max-width: 1300px;
            }
        }

        .wide-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .card {
            background: var(--card-background);
            border-radius: var(--card-border-radius);
            padding: var(--card-padding);
            box-shadow: var(--card-shadow);
            backdrop-filter: var(--card-backdrop-filter);
            margin: var(--card-margin);
            width: var(--card-width) !important;
            max-width: var(--card-max-width) !important;
            min-width: 0 !important;
            box-sizing: border-box;
            overflow: visible; /* 모든 콘텐츠 표시 */
        }

        /* 광고 통합 스타일 */
        .coupang-ad-wrapper, .adsense-ad-wrapper {
            width: 100% !important;
            margin: 5px auto !important;
            overflow: hidden !important; /* 광고가 wrapper 밖으로 넘어가는 것 방지 */
            box-sizing: border-box !important;
            text-align: center !important;
        }
        
        .coupang-ad-wrapper > div:first-child,
        .adsense-ad-wrapper > div:first-child {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 3px;
        }
        
        .coupang-ad-wrapper iframe {
            width: 100% !important;
            max-width: 1300px !important;
            height: auto !important;
            display: block !important;
            border: none !important;
        }
        
        /* Google AdSense 반응형 스타일 - CLS 개선 */
        .adsense-ad-wrapper {
            min-height: 250px; /* CLS 방지용 최소 높이 */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .adsense-ad-wrapper .adsbygoogle {
            display: block;
            width: 100%;
            margin: 0 auto;
            min-height: 200px; /* 광고 로딩 전 공간 확보 */
        }

        /* 광고 카드 전용 클래스 - card 스타일 상속 + CLS 최적화 */
        .ad-card {
            background: var(--card-background);
            border-radius: var(--card-border-radius);
            padding: var(--card-padding);
            box-shadow: var(--card-shadow);
            min-height: 200px; /* CLS 방지용 */
            display: flex;
            flex-direction: column;
            backdrop-filter: var(--card-backdrop-filter);
            margin: var(--card-margin);
            width: 100% !important;
            box-sizing: border-box;
            text-align: center;
            overflow: visible !important;
            min-height: 90px;
        }

        /* 개선 제안 카드 전용 스타일 */
        .improvement-suggestion-content {
            text-align: center;
            padding: 20px 0;
        }

        .improvement-suggestion-text {
            font-size: var(--font-base);
            margin: 0 0 20px 0;
            color: #4b5563;
            line-height: 1.6;
        }

        .improvement-suggestion-subtext {
            font-size: var(--font-sm);
            opacity: 0.8;
        }

        .improvement-suggestion-btn {
            display: inline-block;
            color: white;
            text-decoration: none;
            font-size: var(--font-base);
            padding: 14px 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            transition: all 0.3s ease;
            font-weight: var(--font-weight-semibold);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            border: none;
            cursor: pointer;
        }

        .improvement-suggestion-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .card-icon {
            font-size: var(--font-3xl);
            margin-right: 15px;
        }

        .card-title {
            font-size: var(--font-2xl);
            font-weight: var(--font-weight-semibold);
            color: #2c3e50;
        }

        /* 전체 순위표 - 가로 스크롤 */
        .full-standings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0;
            font-size: var(--font-base);
        }

        .full-standings-table th,
        .full-standings-table td {
            padding: 10px 6px;
            text-align: center;
            border: 1px solid #d1d5db;
            white-space: nowrap;
        }
        
        .full-standings-table th {
            border: 1px solid #d1d5db;
        }

        .full-standings-table th {
            background: #34495e;
            color: white;
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-base);
            font-family: var(--font-family-base);
        }

        .full-standings-table .team-name {
            text-align: center !important;
            font-weight: var(--font-weight-semibold);
            min-width: 70px;
        }

        .full-standings-table .rank-1 { background: #fff3cd; }
        .full-standings-table .rank-2 { background: #f8f9fa; }
        .full-standings-table .rank-3 { background: #f8f9fa; }

        /* 지표 그리드 */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #3498db;
        }

        .metric-card.positive {
            border-left-color: #27ae60;
            background: #f0f9f4;
        }

        .metric-card.negative {
            border-left-color: #e74c3c;
            background: #fdf2f2;
        }

        .metric-card.neutral {
            border-left-color: #d97706;
            background: #fffbf0;
        }

        .metric-value {
            font-size: var(--font-2xl);
            font-weight: var(--font-weight-bold);
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: var(--font-sm);
            color: #7f8c8d;
            font-weight: var(--font-weight-medium);
        }

        .metric-team {
            font-size: var(--font-md);
            font-weight: var(--font-weight-semibold);
            color: #2980b9;
            margin-bottom: 5px;
        }

        /* 상세 테이블 */
        .detail-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0;
            font-size: var(--font-base);
        }

        .detail-table th,
        .detail-table td {
            padding: 8px 6px;
            text-align: center;
            border: 1px solid #d1d5db;
        }

        .detail-table th {
            background: #34495e;
            color: white;
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-base);
            font-family: var(--font-family-base);
            cursor: pointer;
            transition: background 0.2s ease;
            user-select: none;
            position: relative;
        }
        
        .detail-table th:hover {
            background: #2c3e50;
        }
        
        .detail-table th.sortable::after {
            content: '';
        }
        
        .detail-table th.sort-asc::after {
            content: '';
        }
        
        .detail-table th.sort-desc::after {
            content: '';
        }

        .detail-table .team-name {
            text-align: center !important;
            font-weight: var(--font-weight-semibold);
        }

        /* 순위 열 스타일 */
        .detail-table th:first-child {
            width: var(--rank-col);
            min-width: var(--rank-col);
            max-width: var(--rank-col);
        }
        
        /* 순위 셀 통일된 스타일 */
        .detail-table td:first-child,
        .full-standings-table td:first-child {
            font-size: var(--font-base) !important;
            font-weight: var(--font-weight-bold);
            text-align: center;
        }
        
        .detail-table td:first-child {
            width: var(--rank-col);
            min-width: var(--rank-col);
            max-width: var(--rank-col);
            font-weight: var(--font-weight-bold);
            text-align: center;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            color: #495057;
        }

        /* 순위별 특별 표시 */
        .rank-1 { 
            background: linear-gradient(135deg, #ffd700, #ffed4e) !important; 
            color: #8b5a00 !important; 
            font-size: var(--font-base) !important;
            font-weight: var(--font-weight-bold) !important;
        }
        .rank-2 { 
            background: linear-gradient(135deg, #c0c0c0, #e8e8e8) !important; 
            color: #666666 !important; 
            font-size: var(--font-base) !important;
            font-weight: var(--font-weight-bold) !important;
        }
        .rank-3 { 
            background: linear-gradient(135deg, #cd7f32, #daa557) !important; 
            color: #5d3a0a !important; 
            font-size: var(--font-base) !important;
            font-weight: var(--font-weight-bold) !important;
        }
        
        .rank-other {
            font-size: var(--font-base) !important;
            font-weight: var(--font-weight-semibold) !important;
        }

        .positive { color: #059669; font-weight: var(--font-weight-semibold); }
        .negative { color: #dc2626; font-weight: var(--font-weight-semibold); }
        .neutral { color: #d97706; font-weight: var(--font-weight-semibold); }
        
        /* 승-패-승률 셀 스타일 개선 */
        .record-cell {
            text-align: center;
            padding: 8px 4px;
            font-size: var(--font-base);
            line-height: 1.3;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .record-cell:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .record-cell .record {
            font-family: var(--data-font-family);
            font-weight: var(--font-weight-bold);
            font-size: var(--font-md);
            margin-bottom: 2px;
            display: block;
        }
        
        .record-cell .rate {
            font-family: var(--winrate-font-family);
            font-size: var(--font-sm);
            font-weight: var(--winrate-font-weight);
            opacity: 0.9;
            display: block;
            padding: 1px 4px;
            border-radius: 8px;
            background: rgba(255,255,255,0.7);
        }
        
        .record-cell .games {
            font-size: var(--font-2xs);
            color: #666;
            margin-top: 2px;
            display: block;
            opacity: 0.8;
        }

        /* 매트릭스 테이블 */
        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--font-base);
            margin-top: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 1100px; /* 매트릭스 테이블 최소 너비 */
        }

        .matrix-table th,
        .matrix-table td {
            padding: 6px 8px;
            text-align: center;
            border: 1px solid #d1d5db;
            position: relative;
            min-width: 90px;
            width: 90px;
            max-width: 90px;
        }

        .matrix-table th {
            background: #34495e;
            color: white;
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-base);
            font-family: var(--font-family-base);
            padding: 12px 8px;
            text-align: center;
        }
        
        /* 태블릿 이상 해상도에서 매트릭스 테이블 스티키 헤더 적용 */
        @media (min-width: 769px) {
            .matrix-table th {
                position: sticky;
                top: 0;
                z-index: 10;
            }
            
            /* 요일별 테이블 헤더 스티키 적용 */
            #weekdayTable thead th {
                position: sticky;
                top: 0;
                z-index: 10;
            }
            
            /* 매트릭스 테이블 컨테이너 높이 제한 */
            #matrixContent .table-container,
            #remainingGamesContent .table-container {
                max-height: 600px;
                overflow-y: auto;
                position: relative;
            }
        }
        
        /* 왼쪽 팀명 열 간격 조정 */
        .matrix-table th:first-child,
        .matrix-table td:first-child {
            padding: 8px 4px !important;
            min-width: 70px !important;
            width: 70px !important;
            max-width: 70px !important;
        }

        .matrix-table td {
            background: white;
            transition: background-color 0.2s ease;
        }

        .matrix-table td:hover {
            background-color: #f8f9fa;
            transform: scale(1.02);
        }

        .matrix-table .matrix-record {
            font-family: var(--data-font-family) !important;
            font-weight: var(--font-weight-bold) !important;
            font-size: var(--font-lg) !important;
            display: block !important;
            margin-bottom: 12px !important;
            color: #1f2937 !important;
            background: rgba(255, 255, 255, 0.8) !important;
            padding: 4px 6px !important;
            border-radius: 6px !important;
            border: 1px solid rgba(209, 213, 219, 0.6) !important;
        }
        
        .matrix-cell-detailed {
            text-align: center;
            font-size: var(--font-base);
        }
        
        .matrix-table .matrix-details {
            margin-top: 12px !important;
            padding-top: 10px !important;
            border-top: 2px solid #d1d5db !important;
            background: rgba(248, 249, 250, 0.5) !important;
            border-radius: 4px !important;
            padding: 8px 4px 6px 4px !important;
        }
        
        .home-away-split {
            display: flex;
            justify-content: space-between;
            gap: 4px;
        }
        
        .matrix-table .home-record, 
        .matrix-table .away-record {
            font-size: var(--font-xs) !important;
            padding: 3px 6px !important;
            border-radius: 4px !important;
            background: #f8f9fa !important;
            border: 1px solid #e9ecef !important;
            font-weight: var(--font-weight-medium) !important;
        }
        
        .matrix-table .home-record {
            color: #2563eb !important;
            background: rgba(37, 99, 235, 0.1) !important;
            border-color: rgba(37, 99, 235, 0.2) !important;
        }
        
        .matrix-table .away-record {
            color: #dc2626 !important;
            background: rgba(220, 38, 38, 0.1) !important;
            border-color: rgba(220, 38, 38, 0.2) !important;
        }
        
        .matrix-table .home-record:hover {
            background: rgba(37, 99, 235, 0.2) !important;
            border-color: rgba(37, 99, 235, 0.4) !important;
            color: #1d4ed8 !important;
        }
        
        .matrix-table .away-record:hover {
            background: rgba(220, 38, 38, 0.2) !important;
            border-color: rgba(220, 38, 38, 0.4) !important;
            color: #b91c1c !important;
        }

        .matrix-rate {
            font-family: var(--winrate-font-family);
            font-size: var(--font-xs);
            font-weight: var(--winrate-font-weight);
            opacity: 0.8;
        }

        /* 월별/요일별 그리드 */
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 1400px) {
            .performance-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 900px) {
            .performance-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 600px) {
            .performance-grid {
                grid-template-columns: 1fr;
            }
        }

        .performance-item {
            background: white;
            border-radius: 15px;
        }
        
        .stadium-analysis-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border: 1px solid #e1e8ed;
        }
        
        .stadium-team-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f8f9fa;
        }
        
        .team-rank {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: var(--font-base);
            font-weight: var(--font-weight-semibold);
            margin-right: 10px;
        }
        
        .team-name-large {
            font-size: var(--font-xl);
            font-weight: var(--font-weight-bold);
            color: #2c3e50;
        }

        .team-logo {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            vertical-align: middle;
            border-radius: 3px;
        }

        .team-logo-small {
            width: 18px;
            height: 18px;
            margin-right: 5px;
            vertical-align: middle;
            border-radius: 2px;
        }
        
        #monthlyTable .team-logo-small {
            width: 16px;
            height: 16px;
            margin-right: 3px;
        }

        .team-name-with-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .matrix-table .team-name-with-logo {
            gap: 3px;
            font-size: var(--font-base);
        }

        .weekly-table .team-name-with-logo, 
        .all-teams-table .team-name-with-logo {
            gap: 6px;
        }

        /* 월별 테이블 스타일 개선 */
        #monthlyTable {
            border-collapse: collapse;
            font-size: var(--font-sm);
            width: 100%;
        }

        #monthlyTable th,
        #monthlyTable td {
            border: 1px solid #d1d5db;
            padding: 6px 2px;
            text-align: center;
            max-width: 60px;
            width: 60px;
        }

        #monthlyTable th:first-child,
        #monthlyTable td:first-child {
            max-width: 80px;
            width: 80px;
        }
        
        #monthlyTable .stats-row {
            border-top: 2px solid #d1d5db;
        }
        
        #monthlyTable .stats-row:first-of-type {
            border-top: 1px solid #6b7280;
        }

        #monthlyTable th {
            background: #34495e;
            color: white;
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-sm);
            font-family: var(--font-family-base);
            white-space: nowrap;
        }


        #monthlyTable .team-name-with-logo {
            gap: 2px;
            font-size: var(--font-xs);
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        #monthlyTable th {
            white-space: nowrap;
            vertical-align: middle;
        }

        /* 월별 테이블 통계 행들 스타일 */
        #monthlyTable .stats-row {
            border-top: 1px solid #34495e;
        }

        #monthlyTable .stats-row td {
            border-color: #d1d5db;
            font-weight: var(--font-weight-medium);
            padding: 10px 8px;
            font-size: var(--font-base);
            text-align: center;
        }

        /* 월별 테이블 라벨 셀 (월, 통계 라벨) */
        #monthlyTable .month-label,
        #monthlyTable .stats-label {
            font-weight: var(--font-weight-semibold);
            color: white;
            padding: 10px 8px;
            text-align: center;
        }

        #monthlyTable .month-label {
            background: #f8f9fa !important;
            color: #495057 !important;
            font-size: var(--font-md);
            padding: 6px 1px;
        }

        #monthlyTable .stats-label {
            font-size: var(--font-base);
            padding: 6px 1px;
        }

        /* 월별 테이블 데이터 셀 */
        #monthlyTable .month-data {
            font-size: var(--font-base);
            line-height: 1.3;
            padding: 6px 1px;
            text-align: center;
            color: #2d3748;
        }
        
        /* 월별/요일별 기록 셀 */
        .month-record-cell, .month-rate-cell {
            color: #2d3748 !important;
            font-weight: var(--font-weight-semibold);
        }

        #monthlyTable .month-data .record {
            margin-bottom: 2px;
        }

        #monthlyTable .month-data .rate {
            font-family: var(--winrate-font-family);
            font-weight: var(--winrate-font-weight);
            font-size: var(--font-base);
        }
        
        /* 새로운 분리된 셀 스타일 */
        #monthlyTable .month-record-cell {
            font-size: var(--font-base);
            font-weight: var(--font-weight-semibold);
            text-align: center;
            padding: 6px 1px;
            /* 배경색을 JavaScript에서 동적으로 설정 */
            line-height: 1.3;
        }
        
        #monthlyTable .month-rate-cell {
            font-family: var(--winrate-font-family);
            font-size: var(--font-md);
            font-weight: var(--font-weight-bold);
            text-align: center;
            padding: 6px 1px;
            line-height: 1.3;
        }

        /* ===== 요일별 성적 분석 테이블 스타일 (행/열 반전 구조) ===== */
        #weekdayTable {
            border-collapse: collapse;
            font-size: var(--font-sm);
            width: 100%;
        }

        /* 기본 셀 스타일 (월별 테이블과 동일) */
        #weekdayTable th,
        #weekdayTable td {
            border: 1px solid #d1d5db;
            padding: 5px 1px;
            text-align: center;
            max-width: 50px !important;
            width: 50px !important;
        }

        /* 첫 번째 컬럼(요일 라벨) 폭 확장 */
        #weekdayTable th:first-child,
        #weekdayTable td:first-child {
            max-width: 80px;
            width: 80px;
        }

        /* 통계 행 상단 구분선 */
        #weekdayTable .stats-row {
            border-top: 2px solid #d1d5db;
        }

        /* 좌측 요일 라벨 (기본 스타일) */
        #weekdayTable .day-label {
            color: white;
            font-size: var(--font-md);
            padding: 6px 1px;
        }

        /* 평일 요일 라벨 - 연한 회색 배경 */
        #weekdayTable .day-label.weekday {
            background: #f8f9fa !important;
            color: #495057 !important;
        }

        /* 주말 요일 라벨 - 연한 회색 배경에 붉은 폰트 */
        #weekdayTable .day-label.weekend {
            background: #f8f9fa !important;
            color: #dc2626 !important;
        }

        /* 평일성적/주말성적 좌측 라벨 (기본 스타일) */
        #weekdayTable .stats-label {
            color: white;
            font-size: var(--font-base);
            padding: 6px 1px;
        }

        /* 데이터 셀 내용 (승-패-무 (승률) + 경기수) */
        #weekdayTable .day-data {
            font-size: var(--font-base);
            line-height: 1.3;
            padding: 6px 1px;
            text-align: center;
            color: #2d3748;
        }

        #weekdayTable .day-data .record {
            margin-bottom: 2px;
        }

        #weekdayTable .day-data .rate {
            font-family: var(--winrate-font-family);
            font-weight: var(--winrate-font-weight);
            font-size: var(--font-base);
        }

        /* 레거시 셀 클래스 (현재 미사용) */
        #weekdayTable .day-record-cell,
        #weekdayTable .day-rate-cell {
            font-size: var(--font-base);
            font-weight: var(--font-weight-semibold);
            text-align: center;
            padding: 6px 1px;
            line-height: 1.3;
        }
        
        /* 월별/요일별 테이블에 주차별과 동일한 색상 클래스 적용 */
        #monthlyTable .positive, #weekdayTable .positive {
            background: var(--positive-bg-medium) !important;
            color: var(--positive-color) !important;
            font-weight: var(--font-weight-semibold);
        }
        
        #monthlyTable .negative, #weekdayTable .negative {
            background: var(--negative-bg-medium) !important;
            color: var(--negative-color) !important;
            font-weight: var(--font-weight-semibold);
        }
        
        #monthlyTable .neutral, #weekdayTable .neutral {
            background: var(--neutral-bg-light) !important;
            color: var(--neutral-color) !important;
            font-weight: var(--font-weight-medium);
        }

        /* 주말승률과 평일승률 열 구분선 제거 */
        #weekdayTable th:nth-child(10), /* 주말승률 헤더 */
        #weekdayTable td:nth-child(10) { /* 주말승률 데이터 */
            position: relative;
        }


        /* 상단 팀 헤더: 월별/주차별 테이블과 동일한 색상 */
        #weekdayTable thead th {
            background: #34495e !important;
            color: white !important;
            font-weight: var(--font-weight-bold);
        }

        /* 평일성적 헤더 - 조금 더 진한 회색 배경 */
        #weekdayTable .stats-label.weekday-stats {
            background: #e9ecef !important;
            color: #495057 !important;
        }

        /* 주말성적 헤더 - 조금 더 진한 회색 배경에 붉은 폰트 */
        #weekdayTable .stats-label.weekend-stats {
            background: #e9ecef !important;
            color: #dc2626 !important;
        }

        /* 요일별 분석 색상 정의 */
        #weekdayTable .positive {
            background: var(--positive-bg-medium);
            color: var(--positive-color);
            font-weight: var(--font-weight-semibold);
        }

        #weekdayTable .negative {
            background: var(--negative-bg-medium);
            color: var(--negative-color);
            font-weight: var(--font-weight-semibold);
        }

        #weekdayTable .neutral {
            background: var(--neutral-bg-light);
            color: var(--neutral-color);
            font-weight: var(--font-weight-medium);
        }

        /* 주차별 분석 색상 정의 (요일별과 동일) */
        .weekly-table .positive {
            background: var(--positive-bg-medium);
            color: var(--positive-color);
            font-weight: var(--font-weight-semibold);
        }

        .weekly-table .negative {
            background: var(--negative-bg-medium);
            color: var(--negative-color);
            font-weight: var(--font-weight-semibold);
        }

        .weekly-table .neutral {
            background: var(--neutral-bg-light);
            color: var(--neutral-color);
            font-weight: var(--font-weight-medium);
        }

        /* 추가 강도별 색상 클래스 */
        .positive-very-light { 
            background: var(--positive-bg-very-light) !important; 
            color: var(--positive-color) !important; 
            font-weight: var(--font-weight-medium);
        }
        .positive-light { 
            background: var(--positive-bg-light) !important; 
            color: var(--positive-color) !important; 
            font-weight: var(--font-weight-medium);
        }
        .positive-medium { 
            background: var(--positive-bg-medium) !important; 
            color: var(--positive-color) !important; 
            font-weight: var(--font-weight-semibold);
        }
        .positive-strong { 
            background: var(--positive-bg-strong) !important; 
            color: var(--positive-color) !important; 
            font-weight: var(--font-weight-semibold);
        }
        .positive-very-strong { 
            background: var(--positive-bg-very-strong) !important; 
            color: var(--positive-color) !important; 
            font-weight: var(--font-weight-bold);
        }

        .negative-very-light { 
            background: var(--negative-bg-very-light) !important; 
            color: var(--negative-color) !important; 
            font-weight: var(--font-weight-medium);
        }
        .negative-light { 
            background: var(--negative-bg-light) !important; 
            color: var(--negative-color) !important; 
            font-weight: var(--font-weight-medium);
        }
        .negative-medium { 
            background: var(--negative-bg-medium) !important; 
            color: var(--negative-color) !important; 
            font-weight: var(--font-weight-semibold);
        }
        .negative-strong { 
            background: var(--negative-bg-strong) !important; 
            color: var(--negative-color) !important; 
            font-weight: var(--font-weight-semibold);
        }
        .negative-very-strong { 
            background: var(--negative-bg-very-strong) !important; 
            color: var(--negative-color) !important; 
            font-weight: var(--font-weight-bold);
        }

        .neutral-very-light { 
            background: var(--neutral-bg-very-light) !important; 
            color: var(--neutral-color) !important; 
            font-weight: var(--font-weight-medium);
        }
        .neutral-light { 
            background: var(--neutral-bg-light) !important; 
            color: var(--neutral-color) !important; 
            font-weight: var(--font-weight-medium);
        }
        .neutral-medium { 
            background: var(--neutral-bg-medium) !important; 
            color: var(--neutral-color) !important; 
            font-weight: var(--font-weight-semibold);
        }
        .neutral-strong { 
            background: var(--neutral-bg-strong) !important; 
            color: var(--neutral-color) !important; 
            font-weight: var(--font-weight-semibold);
        }
        .neutral-very-strong { 
            background: var(--neutral-bg-very-strong) !important; 
            color: var(--neutral-color) !important; 
            font-weight: var(--font-weight-bold);
        }

        /* 분석 테이블 호버 효과 및 전환 애니메이션 */
        #fullStandingsTable td,
        #pythagoreanTable td,
        #clutchTable td,
        #homeAwayTable td,
        #matrixTable td,
        #monthlyTable td,
        #weekdayTable td,
        .weekly-table td {
            transition: all 0.3s ease;
            position: relative;
        }

        #fullStandingsTable td:hover,
        #pythagoreanTable td:hover,
        #clutchTable td:hover,
        #homeAwayTable td:hover,
        #matrixTable td:hover,
        #monthlyTable td:hover,
        #weekdayTable td:hover,
        .weekly-table td:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1;
        }

        /* 월별 테이블 일반 데이터 행 */
        #monthlyTable tbody tr:not(.stats-row) td {
            /* 배경색을 JavaScript에서 동적으로 설정하므로 여기서는 제거 */
        }

        #monthlyTable tbody tr:not(.stats-row):hover td {
            /* 호버 시에도 동적 배경색 유지 */
            filter: brightness(1.05);
        }
        
        .home-away-summary {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .home-summary, .away-summary {
            flex: 1;
            text-align: center;
            padding: 12px;
            border-radius: 10px;
            background: #f8f9fa;
        }
        
        .location-label {
            font-size: var(--font-base);
            font-weight: var(--font-weight-semibold);
            color: #666;
            margin-bottom: 5px;
        }
        
        .record-large {
            font-size: var(--font-xl);
            font-weight: var(--font-weight-bold);
            margin-bottom: 3px;
        }
        
        .rate-large {
            font-size: var(--font-lg);
            font-weight: var(--font-weight-semibold);
            opacity: 0.8;
        }
        
        .stadium-highlights {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .best-stadium, .worst-stadium {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: var(--font-md);
        }
        
        .best-stadium {
            background: #e8f5e8;
            border-left: 4px solid #27ae60;
        }
        
        .worst-stadium {
            background: #fdf2f2;
            border-left: 4px solid #e74c3c;
        }
        
        .highlight-label {
            font-weight: var(--font-weight-semibold);
            min-width: 50px;
        }
        
        .stadium-name {
            font-weight: var(--font-weight-semibold);
            color: #2c3e50;
            min-width: 70px;
        }
        
        .highlight-record {
            font-weight: var(--font-weight-bold);
            margin-left: auto;
        }

        .performance-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
        }

        .performance-team {
            font-size: var(--font-xl);
            font-weight: var(--font-weight-bold);
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .performance-detail {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f8f8f8;
            font-size: var(--font-md);
            line-height: 1.4;
            transition: all 0.2s ease;
        }

        .performance-detail:last-child {
            border-bottom: none;
        }
        
        .performance-detail:hover {
            background-color: #fafafa;
            border-radius: 6px;
            padding: 8px 6px;
        }

        .performance-period {
            font-weight: var(--font-weight-semibold);
            color: #2c3e50;
            min-width: 80px;
            line-height: 1.3;
        }

        .performance-result {
            font-weight: var(--font-weight-semibold);
            text-align: right;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .performance-wins {
            color: #2ecc71;
            font-size: var(--font-lg);
        }

        .performance-losses {
            color: #e67e22;
            font-size: var(--font-lg);
        }

        .performance-rate {
            background: #ecf0f1;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: var(--font-sm);
            font-weight: var(--font-weight-bold);
            margin-left: 6px;
        }

        .table-container {
            overflow-x: auto;
            overflow-y: visible; /* allow sticky column shadows to render */
            margin-top: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 100%;
            -webkit-overflow-scrolling: touch; /* iOS 스크롤 개선 */
            position: relative; /* z-index context for sticky elements */
            background: white;  /* avoid transparency artifacts under sticky cells */
        }
        
        /* 모든 테이블에 최소 너비 설정하여 스크롤 보장 */
        .table-container table {
            min-width: 900px; /* 기본 최소 너비 */
        }
        
        
        /* 중간 해상도(태블릿 가로 모드 등)에서 테이블 스크롤 강화 */
        @media (max-width: 1024px) and (min-width: 769px) {
            .table-container {
                overflow-x: auto !important;
                width: 100% !important;
                max-width: 100% !important;
            }
            
            .table-container table {
                min-width: 1000px !important; /* 중간 해상도에서 더 넓은 최소 너비 */
            }
        }

        /* 팀별 진행률 카드 스타일 */
        .team-progress-card {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px 16px;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .team-progress-card:hover {
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .team-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .team-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .team-logo-progress {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }
        
        .team-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: #374151;
        }
        
        .progress-percentage {
            font-weight: 700;
            font-size: 1rem;
        }
        
        .team-progress-bar {
            width: 100%;
            height: 8px;
            background: #f3f4f6;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .team-progress-fill {
            height: 100%;
            transition: width 1s ease-in-out;
            border-radius: 4px;
        }
        
        .progress-stats {
            display: flex;
            justify-content: space-between;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-number {
            display: block;
            font-weight: 700;
            font-size: 1.1rem;
            color: #374151;
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* 일자별 순위 그래프 모바일 최적화 */
        @media (max-width: 768px) {
            .daily-stats-header {
                padding: 3px 6px !important;
                top: 46px !important;
                margin-bottom: 10px !important;
            }
            
            .daily-stats-controls {
                gap: 3px !important;
                row-gap: 3px !important;
            }
            
            .daily-stats-date-display {
                font-size: 11px !important;
                padding: 3px 8px !important;
                min-width: 110px !important;
            }
            
            .daily-stats-btn {
                padding: 3px 8px !important;
                font-size: 10px !important;
            }
            
            .daily-stats-date-input {
                padding: 3px 8px !important;
                font-size: 11px !important;
                width: 110px;
            }
            
            .daily-stats-animation-controls {
                gap: 2px !important;
            }
            
            .daily-stats-nav-buttons {
                gap: 2px !important;
            }
        }
        
        /* 모바일 가로 모드 최적화 */
        @media (max-width: 768px) and (orientation: landscape) {
            .daily-stats-header {
                top: 42px !important;
                padding: 2px 6px !important;
            }
        }

        /* 모바일에서 매트릭스 테이블 상단 헤더 셀 너비 확대 */
        @media (max-width: 768px) {
            .matrix-table th:not(:first-child) {
                min-width: 110px !important;
                width: 110px !important;
                max-width: 110px !important;
            }
            
            /* 게임별 기록과 연승/연패 분석 테이블의 팀명 헤더 셀 폭 확대 */
            .weekly-table .team-header,
            .all-teams-table .team-header-column {
                min-width: 105px !important;
                width: 105px !important;
                font-size: var(--font-xs) !important;
                padding: 8px 3px !important;
            }
        }

        /* 모바일에서 왼쪽 컬럼 고정 (Sticky Columns) */
        @media (max-width: 768px) {
            .table-container {
                position: relative;
            }
            
            /* 전체 팀명 컬럼 좌우 패딩 축소 - 월별/경기장별 테이블 제외 */
            .detail-table:not(#monthlyTable):not(#stadiumTable) th:nth-child(2),
            .detail-table:not(#monthlyTable):not(#stadiumTable) td:nth-child(2),
            .full-standings-table th:nth-child(2),
            .full-standings-table td:nth-child(2),
            #weekdayTable th:nth-child(2),
            #weekdayTable td:nth-child(2) {
                padding-left: 4px !important;
                padding-right: 4px !important;
            }
            
            /* 월별/경기장별 테이블 - sticky 완전 제거 */
            #monthlyTable th,
            #monthlyTable td,
            #stadiumTable th,
            #stadiumTable td {
                position: static !important;
                left: auto !important;
                z-index: auto !important;
                border-right: none !important;
                box-shadow: none !important;
            }
            
            /* 월별/경기장별 테이블 첫 번째 컬럼만 sticky */
            #monthlyTable th:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: 10 !important;
                background: #34495e !important;
                color: white !important;
                border-right: 2px solid #495057 !important;
                min-width: 70px !important;
            }
            
            #monthlyTable td:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: 10 !important;
                border-right: 2px solid #495057 !important;
                min-width: 70px !important;
            }
            
            /* 월 라벨은 연한 회색 적용 */
            #monthlyTable td:first-child.month-label {
                background: #f8f9fa !important;
                color: #495057 !important;
            }
            
            #stadiumTable th:first-child,
            #stadiumTable td:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: 10 !important;
                background: #f8f9fa !important;
                color: #495057 !important;
                border-right: 2px solid #dee2e6 !important;
                min-width: 140px !important;
                font-weight: bold !important;
            }
            
            /* ===== 순위+팀명이 있는 일반 테이블들 (첫 번째와 두 번째 컬럼 모두 고정) ===== */

            /* 첫 번째 컬럼 (순위) 고정 - 순위+팀명이 있는 테이블만 */
            .detail-table:not(#monthlyTable):not(#stadiumTable) thead th:first-child,
            .full-standings-table thead th:first-child,
            #weekdayTable thead th:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: var(--z-sticky-corner) !important; /* top-left corner has highest */
                background: #34495e !important;
                color: white !important;
                border-right: 2px solid #495057 !important;
                min-width: var(--rank-col) !important;
                box-shadow: var(--sticky-shadow) !important; /* edge glow to the right */
            }

            .detail-table:not(#monthlyTable):not(#stadiumTable) tbody td:first-child,
            .full-standings-table tbody td:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: var(--z-sticky-col1) !important;
                background: #f8f9fa !important;
                color: #495057 !important;
                border-right: 2px solid #dee2e6 !important;
                font-weight: bold !important;
                min-width: var(--rank-col) !important;
                box-shadow: var(--sticky-shadow) !important; /* edge glow to the right */
            }
            
            /* 요일별 테이블 첫 번째 컬럼 별도 처리 (스티키만) */
            #weekdayTable tbody td:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: var(--z-sticky-col1) !important;
                border-right: 2px solid #dee2e6 !important;
                min-width: var(--rank-col) !important;
                box-shadow: var(--sticky-shadow) !important; /* edge glow to the right */
                /* 색상은 .day-label 클래스가 처리 */
            }

            /* 두 번째 컬럼 (팀명) 고정 - 순위+팀명이 있는 테이블만 */
            .detail-table:not(#monthlyTable):not(#stadiumTable) thead th:nth-child(2),
            .full-standings-table thead th:nth-child(2) {
                position: sticky !important;
                left: var(--rank-col) !important;
                z-index: var(--z-sticky-col2-header) !important;
                background: #34495e !important;
                color: white !important;
                border-right: 2px solid #495057 !important;
                box-shadow: var(--sticky-shadow) !important;
                min-width: var(--team-col) !important;
            }

            .detail-table:not(#monthlyTable):not(#stadiumTable) tbody td:nth-child(2),
            .full-standings-table tbody td:nth-child(2) {
                position: sticky !important;
                left: var(--rank-col) !important;
                z-index: var(--z-sticky-col2) !important;
                background: white !important;
                color: #495057 !important;
                border-right: 2px solid #dee2e6 !important;
                box-shadow: var(--sticky-shadow) !important;
                font-weight: 600 !important;
                min-width: var(--team-col) !important;
            }

            /* 요일별 테이블 팀명 셀 너비 축소 */
            #weekdayTable thead th:nth-child(2) {
                position: sticky !important;
                left: var(--rank-col) !important;
                z-index: var(--z-sticky-col2-header) !important;
                background: #34495e !important;
                color: white !important;
                border-right: 2px solid #495057 !important;
                box-shadow: var(--sticky-shadow) !important;
                min-width: 70px !important;
            }

            #weekdayTable tbody td:nth-child(2) {
                position: sticky !important;
                left: var(--rank-col) !important;
                z-index: var(--z-sticky-col2) !important;
                background: white !important;
                color: #495057 !important;
                border-right: 2px solid #dee2e6 !important;
                box-shadow: var(--sticky-shadow) !important;
                font-weight: 600 !important;
                min-width: 70px !important;
            }

            /* ===== 매트릭스 테이블 (첫 번째 컬럼만 고정) ===== */
            .matrix-table thead th:first-child,
            .matrix-table tbody th:first-child,
            .matrix-table tbody td:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: 10 !important;
                background: #34495e !important;
                color: white !important;
                border-right: 2px solid #495057 !important;
                min-width: 70px !important;
            }


            /* ===== 경기장별 성적 분석 (첫 번째 컬럼 '경기장'만 고정) ===== */
            #stadiumTable thead th:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: 10 !important;
                background: #f8f9fa !important;
                color: #495057 !important;
                border-right: 2px solid #dee2e6 !important;
                min-width: 140px !important;
                font-weight: bold !important;
            }
            
            #stadiumTable tbody td:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: 10 !important;
                background: #f8f9fa !important;
                color: #495057 !important;
                border-right: 2px solid #dee2e6 !important;
                min-width: 140px !important;
                font-weight: bold !important;
            }

            /* ===== 중계사별 승률 분석 전용 스타일 ===== */
            #broadcasterTable .broadcaster-name {
                background: var(--neutral-bg-light);
                font-weight: var(--font-weight-bold);
                text-align: left;
                padding: 8px 6px;
                white-space: nowrap;
                font-size: var(--font-sm);
            }

            #broadcasterTable .team-data {
                text-align: center;
                font-size: var(--font-xs);
                padding: 6px 4px;
            }

            #broadcasterTable .win-rate {
                font-weight: var(--font-weight-bold);
                font-size: var(--font-sm);
                margin-bottom: 2px;
            }

            #broadcasterTable .record {
                opacity: 0.8;
                font-size: var(--font-xs);
            }

            /* ===== 게임 기록 테이블들 (첫 번째 컬럼만 고정) ===== */
            .all-teams-table thead th:first-child,
            .detailed-game-table thead th:first-child,
            .weekly-table thead th:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: 11 !important;
                background: #34495e !important;
                color: white !important;
                border-right: 2px solid #495057 !important;
                min-width: 70px !important;
            }
            
            .all-teams-table tbody td:first-child,
            .detailed-game-table tbody td:first-child,
            .weekly-table tbody td:first-child {
                position: sticky !important;
                left: 0 !important;
                z-index: 10 !important;
                background: #f8f9fa !important;
                color: #495057 !important;
                border-right: 2px solid #dee2e6 !important;
                font-weight: bold !important;
                min-width: 70px !important;
            }
        }

        /* 모바일 전용 스타일 */
        .mobile-notice {
            display: none; /* 기본적으로 숨김 */
            margin-top: 12px;
            text-align: center;
            color: rgba(255,255,255,0.9);
        }

        /* 모바일 반응형 폰트 조정 */
        @media (max-width: 768px) {
            :root {
                --font-2xs: 0.65rem;
                --font-xs: 0.7rem;
                --font-sm: 0.75rem;
                --font-base: 0.8rem;
                --font-md: 0.85rem;
                --font-lg: 0.9rem;
                --font-xl: 1rem;
                --font-2xl: 1.2rem;
                --font-3xl: 1.5rem;
                --font-4xl: 2rem;
                --card-padding: 8px;
                --card-max-width: 100%;
            }
            
            .header h1 {
                font-size: var(--font-3xl);
            }
            
            .header {
                padding: 30px 15px !important;
            }
            
            .wide-card,
            .card {
                padding: 15px !important;
                border-radius: 12px !important;
            }
            
            .full-grid {
                grid-template-columns: 1fr;
            }
            
            .team-progress-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 8px !important;
            }
            
            .team-progress-card {
                font-size: 0.8rem !important;
                padding: 8px 12px !important;
            }
            
            .team-progress-header {
                margin-bottom: 6px !important;
            }
            
            .team-logo-progress {
                width: 16px !important;
                height: 16px !important;
            }
            
            .team-name {
                font-size: 0.75rem !important;
            }
            
            .progress-percentage {
                font-size: 0.85rem !important;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }
            
            .performance-grid {
                grid-template-columns: 1fr;
            }
            
            .detailed-game-table {
                font-size: var(--font-sm);
            }
            
            .detailed-game-table th,
            .detailed-game-table td {
                padding: 7px 4px;
                border-left: none;
                border-right: none;
                font-size: var(--font-sm);
            }
            
            .detailed-game-table tr {
                border-bottom: 1px solid #e2e8f0;
            }
            
            /* 모바일에서 매트릭스 테이블 셀 크기 조정 */
            .matrix-table th,
            .matrix-table td {
                min-width: 70px;
                width: 70px;
                max-width: 70px;
                padding: 8px 4px;
                font-size: var(--font-xs);
            }

            /* 모바일에서 안내 메시지 표시 */
            .mobile-notice {
                display: block !important;
            }
            
            /* PC 버전 강제 모드에서는 모바일 스타일 무효화 */
            body.force-desktop .mobile-notice {
                display: none !important;
            }
            
            /* PC 버전 강제 시 일부 모바일 최적화 해제 */
            body.force-desktop {
                min-width: 1200px;
            }

            /* 모바일에서 업데이트 정보 스타일 개선 */
            .update-info {
                font-size: 0.8rem !important;
                padding: 8px 12px !important;
                background: rgba(255,255,255,0.15) !important;
                border-radius: 6px !important;
                border: 1px solid rgba(255,255,255,0.2) !important;
                margin-bottom: 8px !important;
            }

            /* 모바일에서 팀 로고와 팀명 간격 조정 */
            .team-name-with-logo {
                gap: 4px !important;
            }

            .matrix-table .team-name-with-logo {
                gap: 2px !important;
            }

            .weekly-table .team-name-with-logo, 
            .all-teams-table .team-name-with-logo {
                gap: 3px !important;
            }

            #monthlyTable .team-name-with-logo {
                gap: 1px !important;
            }

            /* 홈/원정 분석 테이블 */
            #homeAwayTable .team-name-with-logo {
                gap: 3px !important;
            }
            #homeAwayTable td.team-name {
                padding: 8px 2px !important;
            }

            /* 팀 로고 크기도 약간 조정 */
            .team-logo, .team-logo-small {
                margin-right: 3px !important;
            }
            
        }



        .highlight {
            background: linear-gradient(120deg, #a8e6cf 0%, #dcedc8 100%);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: var(--font-weight-semibold);
        }

        /* 통일된 테이블 스타일 - 기존 테이블과 동일한 스타일 적용 */

        .weekly-table, .game-record-table, .all-teams-table, .detailed-game-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--font-base);  /* 폰트 크기 증가 */
            margin-top: 0;
        }

        /* 테이블 스크롤 컨테이너 - 긴 테이블용 */
        .table-scroll-wrapper {
            max-height: 650px;  /* 더 많은 주차를 보여주도록 높이 증가 */
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            position: relative;
            margin-top: 10px;
        }
        
        /* 게임기록과 팀상세는 적절한 데이터 표시 */
        .table-scroll-wrapper:has(.all-teams-table),
        .table-scroll-wrapper:has(.detailed-game-table) {
            max-height: 650px; /* 개별 팀 테이블 높이 조금 더 줄임 */
        }

        /* 화면 크기별 반응형 높이 조정 - 더 많은 주차 표시 */
        @media (min-width: 1920px) {
            .table-scroll-wrapper {
                max-height: 800px;  /* 대형 모니터에서 더 많은 주차 */
            }
            
            /* 게임기록과 팀상세는 대형 모니터에서 적절한 높이 */
            .table-scroll-wrapper:has(.all-teams-table),
            .table-scroll-wrapper:has(.detailed-game-table) {
                max-height: 850px; /* 대형 모니터에서도 조금 더 줄임 */
            }
        }

        @media (max-width: 1366px) {
            .table-scroll-wrapper {
                max-height: 550px;  /* 노트북 화면 */
            }
            
            .table-scroll-wrapper:has(.all-teams-table),
            .table-scroll-wrapper:has(.detailed-game-table) {
                max-height: 600px; /* 노트북에서도 조금 더 줄임 */
            }
        }

        @media (max-width: 768px) {
            .table-scroll-wrapper {
                max-height: 450px;  /* 태블릿/모바일 */
            }
            
            .table-scroll-wrapper:has(.all-teams-table),
            .table-scroll-wrapper:has(.detailed-game-table) {
                max-height: 600px; /* 500px에서 600px로 증가 */
            }
            
            /* 테이블 컨테이너에 position relative 추가 */
            .table-container {
                position: relative !important;
                overflow: auto !important;
            }
            
            /* 전체 팀 날짜별 테이블의 날짜 열 모바일 최적화 + 상하좌우 스티키 */
            .all-teams-table th:first-child,
            .all-teams-table .date-header-cell {
                min-width: 70px !important;
                max-width: 70px !important;
                width: 70px !important;
                white-space: normal !important;
                word-break: keep-all !important;
                line-height: 1.2 !important;
                padding: 6px 4px !important;
                font-size: var(--font-2xs) !important;
                /* 상하좌우 스티키 적용 */
                position: sticky !important;
                left: 0 !important;
                top: 0 !important;
                z-index: 200 !important;
                background: #34495e !important;
                color: white !important;
                border-right: 2px solid #495057 !important;
                box-shadow: 2px 0 5px rgba(0,0,0,0.1), 0 2px 5px rgba(0,0,0,0.1) !important;
            }
            
            .all-teams-table td:first-child {
                min-width: 70px !important;
                max-width: 70px !important;
                width: 70px !important;
                white-space: normal !important;
                word-break: keep-all !important;
                line-height: 1.2 !important;
                padding: 4px 3px !important;
                font-size: var(--font-xs) !important;
                /* 좌우 스티키 적용 (상하는 일반 스크롤) */
                position: sticky !important;
                left: 0 !important;
                z-index: 10 !important;
                background: #f8f9fa !important;
                border-right: 2px solid #dee2e6 !important;
                box-shadow: 2px 0 5px rgba(0,0,0,0.1) !important;
            }
            
            /* 날짜 색상 클래스 우선 적용 (주말/연휴 빨간색) */
            .all-teams-table td.date-cell.weekend-date,
            .all-teams-table td.date-cell.holiday-date {
                color: #dc2626 !important;
                font-weight: var(--font-weight-semibold) !important;
            }
            
            .all-teams-table td.date-cell.weekday-date {
                color: #1f2937 !important;
                font-weight: var(--font-weight-medium) !important;
            }
            
            /* 모바일 공휴일명 스타일링 */
            .all-teams-table td.date-cell small {
                font-size: var(--font-2xs) !important;
                color: #dc2626 !important;
                font-weight: var(--font-weight-medium) !important;
                display: block;
                margin-top: 1px;
            }
        }

        /* 스티키 테이블 헤더 */
        .table-scroll-wrapper .weekly-table thead th,
        .table-scroll-wrapper .game-record-table thead th,
        .table-scroll-wrapper .all-teams-table thead th,
        .table-scroll-wrapper .detailed-game-table thead th {
            position: sticky;
            top: 0;
            background: #34495e;
            color: white;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }

        /* 주차별 테이블 헤더를 하나의 통합된 스티키 블록으로 처리 */
        .table-scroll-wrapper .weekly-table thead {
            position: sticky;
            top: 0;
            z-index: 100;
            background: #34495e; /* thead 전체 배경 */
            box-shadow: var(--sticky-shadow-soft); /* 통일된 헤더 그림자 */
        }

        /* Prevent transforms/filters from breaking sticky on mobile */
        @media (max-width: 768px) {
            .table-container * {
                transform: none !important;
                filter: none !important;
            }
        }
        
        /* 모든 헤더 셀에 통일된 스타일 적용 */
        .table-scroll-wrapper .weekly-table thead th {
            background: #34495e !important;
            color: white !important;
            border: 1px solid #495057;
            position: relative; /* 클릭 이벤트가 작동하도록 변경 */
            white-space: nowrap; /* 헤더 텍스트 줄바꿈 방지 */
        }

        .weekly-table th, .weekly-table td,
        .game-record-table th, .game-record-table td,
        .detailed-game-table th, .detailed-game-table td {
            border: 1px solid #d1d5db;
            padding: 4px 4px;  /* 패딩 추가 축소 (5px 4px → 4px 4px) */
            text-align: center;
        }
        
        /* 전체 게임 테이블 패딩 통합 스타일 */
        #teamDetailedRecordsContent .all-teams-table th,
        #teamDetailedRecordsContent .all-teams-table td {
            border: 1px solid #d1d5db !important;
            text-align: center !important;
            min-width: 40px !important;
        }
        
        #teamDetailedRecordsContent .all-teams-table th {
            padding: 7px 5px !important;
            line-height: 1.4 !important;
            background: #34495e !important;
            color: white !important;
        }
        
        #teamDetailedRecordsContent .all-teams-table td {
            padding: 1px 5px !important;
            line-height: 1.1 !important;
        }

        /* 밀도 높은 테이블 모드 */
        .table-scroll-wrapper.dense-mode .weekly-table td,
        .table-scroll-wrapper.dense-mode .all-teams-table td,
        .table-scroll-wrapper.dense-mode .detailed-game-table td {
            padding: 4px 3px;  /* 더 작은 패딩 옵션 */
            font-size: var(--font-xs);
        }

        /* 테이블 행 높이 최적화 */
        .table-scroll-wrapper tr {
            line-height: 1.3;  /* 라인 높이 감소 */
        }

        /* 게임 기록 테이블 특별 스타일 */
        .all-teams-table td,
        .detailed-game-table td {
            white-space: nowrap;  /* 텍스트 줄바꿈 방지 */
        }

        .weekly-table th, .game-record-table th, .detailed-game-table th, .all-teams-table th {
            background: #34495e;
            color: white;
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-lg);
            font-family: var(--font-family-base);
            padding: 15px 8px;
            text-align: center;
        }
        
        /* 주차별 테이블 기본 헤더 스타일 */
        .weekly-table th {
            font-size: var(--font-lg) !important;
            text-align: center;
            padding: 12px 8px !important;
        }
        
        /* rowspan 헤더 (주차, 기간) */
        .weekly-table th[rowspan="2"] {
            font-size: var(--font-lg) !important;
            font-weight: var(--font-weight-bold);
            min-width: 80px;
            vertical-align: middle;
            padding: 12px 8px !important;
        }
        
        /* colspan 헤더 (팀별 성적) */
        .weekly-table th[colspan], .detail-table th[colspan] {
            text-align: center;
            font-weight: var(--font-weight-semibold);
            padding: 12px 8px !important;
            font-size: var(--font-lg) !important;
            background: #2c3e50 !important;
            color: white !important;
            border-bottom: 2px solid #34495e !important;
        }
        
        /* 팀명 헤더 */
        .weekly-table .team-header {
            font-size: var(--font-base) !important;
            font-weight: var(--font-weight-semibold);
            padding: 12px 8px !important;
            min-width: 100px;
            z-index: 101; /* 클릭 이벤트를 위해 z-index 추가 */
            position: relative;
        }

        .team-header, .team-header-column {
            background: #34495e !important;
            color: white !important;
            font-weight: var(--font-weight-bold);
        }

        /* 주차별 성적 팀명 헤더 정렬 기능 스타일 */
        .sortable-team {
            transition: background-color 0.2s ease;
        }

        .sortable-team:hover {
            background: #2c3e50 !important;
            cursor: pointer;
        }


        .week-cell, .game-number-cell, .game-num-cell {
            font-weight: var(--font-weight-bold);
            color: #2c3e50;
            font-size: var(--font-sm);
        }

        .date-cell {
            font-size: var(--font-base);
            white-space: nowrap;
            color: #2c3e50;
            padding: 8px 12px;
            text-align: center;
            background: #f8f9fa;
            font-weight: var(--font-weight-medium);
        }

        .team-stats {
            padding: 8px 6px;
        }

        .record {
            font-family: var(--data-font-family);
            font-weight: var(--font-weight-bold);
            font-size: var(--font-md);
            color: #1a202c;
        }

        .win-rate {
            font-family: var(--winrate-font-family);
            font-size: var(--font-sm);
            color: #2d3748;
            margin-top: 3px;
            font-weight: var(--winrate-font-weight);
        }

        /* 승률 표기 통일 스타일 */
        .baseball-winrate {
            font-family: var(--winrate-font-family);
            font-weight: var(--winrate-font-weight);
            font-size: var(--winrate-font-size);
            color: #2d3748;
        }

        .baseball-winrate-cell {
            font-family: var(--winrate-font-family);
            font-weight: var(--font-weight-bold);
            font-size: var(--winrate-font-size);
            text-align: center;
        }

        .baseball-winrate-inline {
            font-family: var(--winrate-font-family);
            font-weight: var(--font-weight-medium);
            font-size: var(--winrate-font-size);
        }

        /* 유틸리티 폰트 클래스 - 재사용성을 위해 */
        .font-data {
            font-family: var(--data-font-family);
            font-weight: var(--data-font-weight);
            font-size: var(--data-font-size);
        }
        
        .font-winrate {
            font-family: var(--winrate-font-family);
            font-weight: var(--winrate-font-weight);
            font-size: var(--winrate-font-size);
        }
        
        .font-data-bold {
            font-family: var(--data-font-family);
            font-weight: var(--font-weight-bold);
            font-size: var(--data-font-size);
        }

        /* 모든 테이블 셀의 기본 폰트 통일 */
        table td {
            font-family: var(--data-font-family);
        }
        
        /* strong 태그 폰트 통일 */
        table strong {
            font-family: var(--data-font-family);
            font-weight: var(--font-weight-bold);
        }
        
        /* 숫자 데이터 표시용 강제 스타일 */
        #fullStandingsTable td,
        #pythagoreanTable td,
        #clutchTable td {
            font-family: var(--data-font-family);
            font-weight: var(--data-font-weight);
        }
        
        #fullStandingsTable strong,
        #pythagoreanTable strong, 
        #clutchTable strong {
            font-family: var(--data-font-family);
            font-weight: var(--font-weight-bold);
        }
        
        /* 승률 표시 컬럼들에 모노스페이스 폰트 적용 */
        #fullStandingsTable td:nth-child(8),  /* 승률 컬럼 */
        #fullStandingsTable td:nth-child(12), /* 홈승률 컬럼 */
        #fullStandingsTable td:nth-child(14), /* 원정승률 컬럼 */
        #pythagoreanTable td:nth-child(3),    /* 실제승률 컬럼 */
        #pythagoreanTable td:nth-child(4),    /* 기대승률 컬럼 */
        #clutchTable td:nth-child(5),         /* 1점차승률 컬럼 */
        #clutchTable td:nth-child(8),         /* 3점차승률 컬럼 */
        #clutchTable td:nth-child(13) {       /* 클러치지수 컬럼 */
            font-family: var(--winrate-font-family) !important;
            font-weight: var(--winrate-font-weight) !important;
        }
        
        /* 모든 테이블의 td 요소에만 강제 폰트 적용 (th는 제외) */
        table td *, table strong, table b, table span {
            font-family: inherit !important;
            font-weight: inherit !important;
        }
        
        /* 테이블 헤더는 별도로 폰트 강제 적용 - 최우선순위 */
        table th,
        .full-standings-table th,
        .detail-table th,
        .matrix-table th,
        #monthlyTable th,
        .weekly-table th,
        .all-teams-table th,
        .detailed-game-table th,
        .series-stats-table th,
        #weekdayTable th,
        th[style*="font-size"] {
            font-family: var(--font-family-base) !important;
            font-size: var(--font-base) !important;
            font-weight: var(--font-weight-semibold) !important;
        }
        
        /* 모든 테이블 헤더에 대한 최우선 적용 (주차별 테이블 제외) */
        * th:not(.weekly-table th):not(.game-record-table th) {
            font-family: var(--font-family-base) !important;
            font-size: var(--font-base) !important;
        }
        
        /* 승률 관련 헤더 특별 처리 - 절대 우선순위 */
        table th:nth-child(8),   /* 승률 헤더 */
        table th:nth-child(14),  /* P승률 헤더 */
        table th:nth-child(16),  /* 1점차승률 헤더 */
        table th:nth-child(17),  /* 홈승률 헤더 */
        table th:nth-child(19),  /* 원정승률 헤더 */
        #fullStandingsTable th:nth-child(8),
        #fullStandingsTable th:nth-child(12),
        #fullStandingsTable th:nth-child(14) {
            font-family: var(--font-family-base) !important;
            font-size: var(--font-base) !important;
            font-weight: var(--font-weight-semibold) !important;
        }
        
        /* 숫자가 포함된 모든 셀에 데이터 폰트 강제 적용 */
        table td:not(.team-name):not(.opponent-cell):not(.date-cell):not(.venue-cell):not(.result-cell) {
            font-family: var(--data-font-family) !important;
            font-weight: var(--data-font-weight) !important;
        }
        
        /* 팀명과 텍스트 셀 제외한 모든 strong 태그 */
        table td:not(.team-name):not(.opponent-cell):not(.date-cell):not(.venue-cell):not(.result-cell) strong,
        table td:not(.team-name):not(.opponent-cell):not(.date-cell):not(.venue-cell):not(.result-cell) b {
            font-family: var(--data-font-family) !important;
            font-weight: var(--font-weight-bold) !important;
        }


        .team-selector {
            text-align: center;
            margin: 15px 0;
        }

        /* 탑으로 가기 버튼 스타일 - magic-number 스타일 적용 */
        .scroll-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: #1a237e;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            z-index: 9999;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transform: translateY(20px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .scroll-to-top:hover {
            background: #3949ab;
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .scroll-to-top.show:hover {
            transform: translateY(-2px);
        }

        .scroll-to-top.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* 모바일에서 버튼 크기 조정 */
        @media (max-width: 768px) {
            .scroll-to-top {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
        }

        /* 플로팅 공유 버튼 스타일 */
        .floating-share {
            position: fixed;
            bottom: 90px;
            right: 30px;
            z-index: 1000;
        }

        .share-label {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .share-toggle {
            width: 50px;
            height: 50px;
            background: #1a237e;
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .share-toggle:hover {
            background: #3949ab;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }


        .share-options {
            position: absolute;
            bottom: 60px;
            right: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            padding: 8px;
            min-width: 160px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }

        .share-options.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .share-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 8px 12px;
            border: none;
            background: none;
            color: #333;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.2s ease;
            font-size: 14px;
        }

        .share-btn:hover {
            background-color: #f5f5f5;
        }

        .share-btn svg {
            flex-shrink: 0;
        }

        /* 모바일에서 공유 버튼 조정 */
        @media (max-width: 768px) {
            .floating-share {
                bottom: 70px;
                right: 20px;
            }
            
            .share-toggle {
                width: 45px;
                height: 45px;
            }
            
            .share-options {
                min-width: 140px;
                bottom: 50px;
            }
        }

        .team-selector select {
            padding: 8px 16px;
            font-size: var(--font-base);
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
        }

        .streak-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            background: #f8fafc;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .streak-item {
            text-align: center;
        }

        .streak-label {
            display: block;
            font-size: var(--font-sm);
            color: #718096;
            margin-bottom: 5px;
        }

        .streak-value {
            display: block;
            font-size: var(--font-xl);
            font-weight: var(--font-weight-semibold);
        }

        .win-streak {
            color: #38a169;
        }

        .lose-streak {
            color: #e53e3e;
        }


        .result-badge {
            padding: 4px 8px;
            border-radius: 8px;
            font-size: var(--font-xs);
            font-weight: var(--font-weight-semibold);
            color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .result-badge.w {
            background: #27ae60;
        }

        .result-badge.l {
            background: #e74c3c;
        }

        .result-badge.d {
            background: #f39c12;
        }

        .result-badge.cancelled {
            background: #f8f9fa;
            color: #6b7280;
            border: 1px solid #e5e7eb;
            font-weight: normal;
        }

        /* 연승/연패 색상 스타일 - 폰트 색상 */
        .streak-hot {
            color: #e74c3c !important;
            font-weight: var(--font-weight-bold);
        }
        
        .streak-warm {
            color: #f39c12 !important;
            font-weight: var(--font-weight-semibold);
        }
        
        .streak-neutral {
            color: #7f8c8d !important;
        }
        
        .streak-cool {
            color: #e67e22 !important;
            font-weight: var(--font-weight-semibold);
        }
        
        .streak-cold {
            color: #3498db !important;
            font-weight: var(--font-weight-bold);
        }


        .all-teams-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--font-md);
        }

        /* 이 스타일 블록 제거 - 위에서 더 구체적으로 정의됨 */

        .all-teams-table th {
            background: #34495e;
            color: white;
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-base);
            font-family: var(--font-family-base);
        }

        .team-header-column {
            background: #34495e !important;
            color: white !important;
            font-weight: 900;
            font-size: var(--font-md);
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
        }

        .game-number-cell {
            font-weight: var(--font-weight-bold);
            background: #fff3e0;
            font-size: var(--font-xs);
        }

        .game-result-cell {
            position: relative;
            padding: 4px;
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-xs);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-result-cell:hover {
            transform: scale(1.1);
            z-index: 2;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .cell-win {
            background: var(--positive-bg-medium);
            color: var(--positive-color);
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-sm);
        }

        .cell-loss {
            background: var(--negative-bg-medium);
            color: var(--negative-color);
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-sm);
        }

        .cell-draw {
            background: var(--neutral-bg-medium);
            color: var(--neutral-color);
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-sm);
        }

        .cell-cancelled {
            background: #f8f9fa;
            color: #9ca3af;
            font-weight: normal;
            font-size: var(--font-sm);
            opacity: 0.8;
        }

        .win-row {
            color: var(--positive-color);
            font-size: var(--font-sm);
        }

        .loss-row {
            color: var(--negative-color);
            font-size: var(--font-sm);
        }

        .draw-row {
            color: #f59e0b;
            font-size: var(--font-sm);
        }

        .cancelled-row {
            color: #9ca3af;
            background-color: #f9fafb;
            opacity: 0.7;
            font-size: var(--font-sm);
        }

        .cell-empty {
            background: #f8fafc;
            color: #9ca3af;
        }

        .result-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
        }

        .streak-number {
            font-size: var(--font-base);
            font-weight: var(--font-weight-bold);
            line-height: 1;
        }

        .result-letter {
            font-size: var(--font-xs);
            font-weight: var(--font-weight-semibold);
            opacity: 0.9;
        }

        /* 무승부일 때 글자 크기를 연승/연패 숫자만큼 크게 */
        .result-letter.draw-result {
            font-size: var(--font-base);
            font-weight: 900;
            opacity: 1;
            line-height: 1;
        }

        /* 취소된 경기일 때 연하게 */
        .result-letter.cancelled-result {
            font-size: var(--font-xs);
            font-weight: normal;
            opacity: 0.6;
            color: #9ca3af;
        }

        .combined-result {
            font-size: var(--font-base);
            font-weight: var(--font-weight-bold);
            line-height: 1;
            display: inline-block;
        }

        .legend {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: var(--font-md);
            color: #4a5568;
        }

        /* 팀별 상세 기록 스타일 제거됨 - wrapper 레이어 제거 */

        .team-stats-summary {
            background: white;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 12px;
            border: 1px solid #e2e8f0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
        }

        .stat-card {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }

        .stat-card:hover {
            background: #e9ecef;
        }

        .stat-title {
            font-size: var(--font-xs);
            color: #718096;
            margin-bottom: 4px;
            font-weight: var(--font-weight-medium);
            line-height: 1.2;
        }

        .stat-number {
            font-size: var(--font-xl);
            font-weight: var(--font-weight-bold);
            color: #2d3748;
            margin-bottom: 2px;
            line-height: 1.2;
        }

        .stat-subtitle {
            font-size: var(--font-2xs);
            color: #a0aec0;
            font-weight: 400;
            line-height: 1.2;
        }

        .win-color {
            color: #38a169 !important;
        }

        .loss-color {
            color: #e53e3e !important;
        }

        /* 예정 경기 구분선 스타일 */
        .future-games-divider {
            background: #e9ecef;
            border-top: 2px solid #6c757d;
        }
        
        .future-games-divider td {
            text-align: center;
            padding: 12px 8px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        /* 게임별 기록 테이블 경기# 셀 스타일 */
        .game-number-cell,
        .all-teams-table td:first-child {
            text-align: center !important;
            font-weight: var(--font-weight-bold);
            font-size: var(--font-base);
            padding: 8px;
        }

        /* 5경기 단위 구분선 스타일 */
        .all-teams-table tr.fifth-game-separator td {
            border-bottom: 1px solid rgba(52, 73, 94, 0.25) !important;
        }

        .detailed-game-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: var(--font-base);
        }

        .detailed-game-table th,
        .detailed-game-table td {
            border: 1px solid #d1d5db;
            padding: 5px 6px;
            text-align: center;
            vertical-align: middle;
            white-space: nowrap;
            font-size: var(--font-base);
        }

        .detailed-game-table th {
            background: #34495e;
            color: white;
            font-weight: var(--font-weight-semibold);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .detailed-game-table th.sortable {
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }

        .detailed-game-table th.sortable:hover {
            background: #2c3e50;
            transform: translateY(-1px);
        }

        .detailed-game-table tbody tr:hover {
            background-color: #f8f9fa;
        }

        .detailed-game-table tbody tr:nth-child(even) {
            background-color: #fdfdfd;
        }

        .detailed-game-table tbody tr:nth-child(even):hover {
            background-color: #f8f9fa;
        }

        .game-num-cell {
            font-weight: var(--font-weight-bold);
            color: #d97706;
            width: 70px;
            max-width: 70px;
            text-align: center;
        }

        .date-cell {
            font-size: var(--font-sm);
            color: #2d3748;
            font-weight: var(--font-weight-medium);
            width: 180px;
            max-width: 180px;
            text-align: center;
            white-space: nowrap;
            overflow: visible;
            text-overflow: clip;
        }

        .weekday-date {
            color: #1f2937;
            font-weight: var(--font-weight-medium);
        }

        .weekend-date {
            color: #dc2626;
            font-weight: var(--font-weight-semibold);
        }

        .holiday-date {
            color: #dc2626;
            font-weight: var(--font-weight-semibold);
        }

        /* 전체 팀 날짜별 테이블 날짜 색상 강제 적용 */
        .all-teams-table td.date-cell.weekend-date,
        .all-teams-table td.date-cell.holiday-date {
            color: #dc2626 !important;
            font-weight: var(--font-weight-semibold) !important;
        }
        
        .all-teams-table td.date-cell.weekday-date {
            color: #1f2937 !important;
            font-weight: var(--font-weight-medium) !important;
        }

        /* 공휴일명 스타일링 */
        .all-teams-table td.date-cell small {
            font-size: var(--font-3xs) !important;
            color: #dc2626 !important;
            font-weight: var(--font-weight-medium) !important;
            display: block;
            margin-top: 2px;
        }

        .opponent-cell {
            font-weight: var(--font-weight-semibold);
            color: #1a202c;
        }

        .venue-cell {
            font-size: var(--font-sm);
            color: #2d3748;
            font-weight: var(--font-weight-medium);
        }

        .home-venue {
            color: #2563eb;
            font-weight: var(--font-weight-semibold);
        }

        .away-venue {
            color: #dc2626;
            font-weight: var(--font-weight-semibold);
        }

        .score-cell {
            font-family: var(--data-font-family);
            font-weight: var(--data-font-weight);
            font-size: var(--data-font-size);
            text-align: center;
        }

        .runs-cell {
            font-family: var(--data-font-family);
            font-weight: var(--data-font-weight);
            font-size: var(--data-font-size);
            text-align: center;
        }

        .diff-cell {
            font-family: var(--data-font-family);
            font-weight: var(--font-weight-bold);
            font-size: var(--data-font-size);
            text-align: center;
        }

        .diff-cell.positive {
            color: #27ae60;
            font-weight: var(--font-weight-semibold);
        }

        .diff-cell.negative {
            color: #e74c3c;
            font-weight: var(--font-weight-semibold);
        }

        .diff-cell.neutral {
            color: #34495e;
        }


        /* 네비게이션 스타일 */
        .navigation {
            position: sticky;
            top: 0;
            z-index: 1000;
            margin-bottom: 10px;
            padding: 8px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 16px;
            overflow: hidden;
        }

        .navigation::before {
            content: "";
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: var(--card-width);
            max-width: var(--card-max-width);
            height: 100%;
            background: var(--card-background);
            backdrop-filter: var(--card-backdrop-filter);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--card-border-radius);
            z-index: -1;
        }

        .nav-container {
            width: var(--card-width) !important;
            max-width: var(--card-max-width) !important;
            margin: 0 auto;
            padding: 0;
            box-sizing: border-box;
        }

        .nav-menu {
            display: flex;
            justify-content: flex-start;
            gap: 2px;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            flex-wrap: nowrap;
        }

        .nav-menu::-webkit-scrollbar {
            display: none;
        }

        .nav-item {
            white-space: nowrap;
            padding: 8px 12px;
            font-size: var(--font-base);
            font-weight: var(--font-weight-medium);
            color: #4a5568;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            text-align: center;
            min-width: 90px;
            display: inline-block;
        }

        .nav-item:hover {
            background: rgba(66, 153, 225, 0.15);
            color: #2563eb;
            border-color: rgba(66, 153, 225, 0.3);
            transform: translateY(-1px);
        }

        .nav-item.active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            font-weight: var(--font-weight-semibold);
            border-color: #2563eb;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .nav-item.active:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        }

        /* 전반기/후반기 테이블 CSS 클래스 */
        .half-season-table {
            min-width: 1200px;
            font-size: 0.9rem;
            border-collapse: collapse;
        }

        .half-season-header {
            font-size: 0.8rem;
            padding: 3px 2px;
            border-right: 1px solid #ddd;
            vertical-align: middle;
        }

        .half-season-header.rank-cell {
            width: 30px;
            cursor: pointer;
        }

        .half-season-header.team-cell {
            width: 80px;
        }

        .half-season-header.current-header {
            text-align: center;
            border-bottom: 1px solid #ddd;
            background: #f8f9fa;
        }

        .half-season-header.first-half-main {
            text-align: center;
            border-bottom: 1px solid #ddd;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }

        .half-season-header.second-half-main {
            text-align: center;
            border-bottom: 1px solid #ddd;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .half-season-header.change-cell {
            width: 70px;
            border-left: 1px solid #ddd;
            cursor: pointer;
        }

        .half-season-header.sub-group-first {
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding: 1px;
            background: rgba(59, 130, 246, 0.1);
        }

        .half-season-header.sub-group-first.last {
            border-right: 1px solid #ddd;
        }

        .half-season-header.sub-group-second {
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding: 1px;
            background: rgba(16, 185, 129, 0.1);
        }

        .half-season-header.current-record {
            width: 70px;
            padding: 4px 2px;
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
            white-space: nowrap;
        }

        .half-season-header.current-winrate {
            width: 50px;
            padding: 4px 2px;
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
            border-right: 1px solid #ddd;
            cursor: pointer;
        }

        .half-season-header.detail-first {
            padding: 1px;
            background: rgba(59, 130, 246, 0.05);
            border-bottom: 1px solid #ddd;
        }

        .half-season-header.detail-first.games {
            width: 30px;
            cursor: pointer;
        }

        .half-season-header.detail-first.record {
            width: 70px;
        }

        .half-season-header.detail-first.winrate {
            width: 50px;
            cursor: pointer;
        }

        .half-season-header.detail-first.rank {
            width: 30px;
            cursor: pointer;
        }

        .half-season-header.detail-first.runs {
            width: 50px;
            cursor: pointer;
        }

        .half-season-header.detail-first.last {
            border-right: 1px solid #ddd;
        }

        .half-season-header.detail-second {
            padding: 1px;
            background: rgba(16, 185, 129, 0.05);
            border-bottom: 1px solid #ddd;
        }

        .half-season-header.detail-second.games {
            width: 30px;
            cursor: pointer;
        }

        .half-season-header.detail-second.record {
            width: 70px;
        }

        .half-season-header.detail-second.winrate {
            width: 50px;
            cursor: pointer;
        }

        .half-season-header.detail-second.rank {
            width: 30px;
            cursor: pointer;
        }

        .half-season-header.detail-second.runs {
            width: 50px;
            cursor: pointer;
        }

        /* 전반기/후반기 테이블 데이터 셀 CSS 클래스 */
        .half-season-data {
            text-align: center;
            font-size: 0.9rem;
            padding: 4px 2px;
        }

        .half-season-data.rank {
            font-weight: 600;
            border-right: 1px solid #ddd;
        }

        .half-season-data.team {
            border-right: 1px solid #ddd;
        }

        .half-season-data.current {
            background: #f8f9fa;
        }

        .half-season-data.current.winrate {
            font-weight: 500;
            border-right: 1px solid #ddd;
        }

        .half-season-data.first-half {
            background: rgba(59, 130, 246, 0.02);
        }

        .half-season-data.first-half.winrate {
            font-weight: 500;
        }

        .half-season-data.first-half.rank {
            font-weight: 600;
        }

        .half-season-data.first-half.last {
            border-right: 1px solid #ddd;
        }

        .half-season-data.second-half {
            background: rgba(16, 185, 129, 0.02);
        }

        .half-season-data.second-half.winrate {
            font-weight: 500;
        }

        .half-season-data.second-half.rank {
            font-weight: 600;
        }

        .half-season-data.performance {
            border-left: 1px solid #ddd;
            white-space: nowrap;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .half-season-data.win-streak {
            color: #27ae60;
        }

        .half-season-data.lose-streak {
            color: #e74c3c;
        }

        /* 매직넘버 카드 스타일 */
        .magic-number-card {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border: none;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .magic-number-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 30px rgba(16, 185, 129, 0.3);
        }

        .magic-number-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0;
        }

        .magic-number-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .magic-number-icon {
            font-size: 3rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
        }

        .magic-number-text h3 {
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0 0 8px 0;
        }

        .magic-number-text p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            margin: 0;
            line-height: 1.5;
        }

        .magic-number-button {
            background: rgba(255, 255, 255, 0.95);
            color: #059669;
            text-decoration: none;
            padding: 14px 28px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 1);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            font-size: 1.05rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .magic-number-button:hover {
            background: white;
            color: #047857;
            transform: translateX(4px) scale(1.02);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .magic-number-button .arrow {
            transition: transform 0.3s ease;
        }

        .magic-number-button:hover .arrow {
            transform: translateX(4px);
        }
        
        /* 매직넘버 버튼 플래시 애니메이션 */
        .magic-number-button {
            animation: magicFlash 2.5s infinite;
        }
        
        @keyframes magicFlash {
            0%, 70%, 100% {
                box-shadow: 0 4px 12px rgba(26, 35, 126, 0.3);
            }
            75%, 85% {
                box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
                transform: translateY(-1px);
            }
        }
        
        /* 상대전적 매트릭스 펄스 애니메이션 */
        @keyframes matrixPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.8;
            }
        }
        
        .matrix-pulse-advantage {
            animation: matrixPulse 2s ease-in-out infinite;
        }
        
        .matrix-pulse-disadvantage {
            animation: matrixPulse 2.5s ease-in-out infinite;
        }
        
        .magic-number-button:hover {
            animation-play-state: paused;
        }

        @media (max-width: 768px) {
            .magic-number-content {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }

            .magic-number-left {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .magic-number-icon {
                width: 70px;
                height: 60px;
                font-size: 2rem;
            }

            .magic-number-text h3 {
                font-size: 1.3rem;
            }

            .magic-number-text p {
                font-size: 0.9rem;
            }

            .magic-number-button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 1024px) {
            .nav-menu {
                justify-content: flex-start;
                gap: 1px;
            }
            .nav-item {
                font-size: var(--font-sm);
                padding: 6px 8px;
                min-width: 70px;
                flex: none;
            }
        }

        @media (max-width: 768px) {
            .nav-item {
                font-size: var(--font-sm);
                padding: 6px 8px;
                min-width: 70px;
            }
            
            /* 모바일에서 팀 선택 탭 최적화 */
            .team-tabs {
                justify-content: flex-start !important;
                padding: 10px !important;
                gap: 4px !important;
            }
            
            .team-tab {
                font-size: var(--font-xs) !important;
                padding: 5px 8px !important;
                min-width: 65px !important;
                flex-shrink: 0 !important;
            }
            
            /* 전체 탭 기본 스타일 (다른 탭과 동일) */
            .team-tab:first-child:not(.active) {
                background: white !important;
                border-color: #dee2e6 !important;
                color: #666 !important;
                font-weight: var(--font-weight-medium) !important;
            }
        }

        /* 시즌 진행률 카드 스타일 */

        .team-progress-item {
            padding: 12px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .team-progress-bar {
            background: #e5e7eb;
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
            margin: 8px 0;
        }

        .team-progress-fill {
            height: 100%;
            transition: width 1.2s ease-out;
            border-radius: 4px;
            will-change: width;
        }

        .team-progress-item:hover {
            border-color: #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            transform: translateY(-2px);
        }

        .team-progress-bar {
            height: 8px;
            background: #f3f4f6;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .team-progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 1.5s ease-out;
            position: relative;
        }

        .team-progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
            /* 애니메이션 제거 - 정적인 글로우 효과만 */
        }

    </style>
</head>
<body>

    <!-- 헤더 -->
    <div class="header">
        <div class="header-content">
            <h1>🏆 KBO 2025 종합 분석 대시보드</h1>
            <p class="subtitle">실시간 순위 · 일별 통계 · 시즌 진행률 · 순위 변동 · 승률 추이 · 전후반기 · 피타고리안 · 클러치 · 홈원정<br>
            상대전적 · 월별성적 · 요일별 · 경기장별 · 주차별 · 시리즈 · 팀간 잔여경기 등 20개 분석 지표 제공</p>
            <div class="update-info" id="updateInfo">
                📅 데이터 로딩 중...
            </div>
            <!-- 모바일 전용 안내 메시지 -->
            <div class="mobile-notice" id="deviceNotice">
                <div style="margin-bottom: 8px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);">
                    <div style="font-size: 0.8rem; margin-bottom: 4px;">
                        📱 <strong>모바일 이용 안내</strong>
                    </div>
                    <div style="font-size: 0.8rem; line-height: 1.4;">
                        본 대시보드는 PC 환경에 최적화되어 있습니다.<br>
                        모바일에서는 <strong>가로 모드</strong> 사용을 권장합니다.
                    </div>
                    <div style="margin-top: 6px;">
                        <a href="javascript:void(0);" onclick="switchToPCVersion()" style="color: #ffd700; text-decoration: underline; font-size: 0.8rem; font-weight: 500;">PC 버전으로 보기</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container">

        <!-- 네비게이션 -->
        <nav class="navigation">
            <div class="nav-container" style="position: relative;">
                <!-- 왼쪽 스크롤 표시 화살표 -->
                <div id="nav-arrow-left" class="nav-scroll-arrow nav-arrow-left" onclick="scrollNavLeft()" style="
                    position: absolute;
                    left: 5px;
                    top: 50%;
                    transform: translateY(-50%);
                    pointer-events: auto;
                    cursor: pointer;
                    color: #ffffff;
                    font-size: 20px;
                    font-weight: bold;
                    z-index: 100;
                    background: rgba(0, 0, 0, 0.7);
                    border-radius: 50%;
                    border: none;
                    width: 30px;
                    height: 30px;
                    text-align: center;
                    line-height: 30px;
                ">←</div>
                
                <div class="nav-menu" id="nav-menu">
                    <a href="magic-number/index.html" class="nav-item magic-number-nav">🎯 매직넘버</a>
                    <a href="#season-progress" class="nav-item">📈 진행률</a>
                    <a href="#daily-stats" class="nav-item">📅 일별통계</a>
                    <a href="#standings" class="nav-item">🏆 종합순위</a>
                    <a href="#teamdetail" class="nav-item">👥 팀상세</a>
                    <a href="#gamerecords" class="nav-item">🎮 게임기록</a>
                    <a href="#wingap-chart-section" class="nav-item">📊 승차추이</a>
                    <a href="#win-count-chart-section" class="nav-item">🏆 승수추이</a>
                    <a href="#rank-chart-section" class="nav-item">📈 순위변동</a>
                    <a href="#winrate-chart-section" class="nav-item">📉 승률추이</a>
                    <a href="#half-season-stats" class="nav-item">⚾ 전후반기</a>
                    <a href="#pythagorean" class="nav-item">📊 피타고리안</a>
                    <a href="#clutch" class="nav-item">⚾ 클러치</a>
                    <a href="#homeaway" class="nav-item">🏠 홈/원정</a>
                    <a href="#matrix" class="nav-item">📋 상대전적</a>
                    <a href="#remaining-games" class="nav-item">🔢 팀간잔여</a>
                    <a href="#monthly" class="nav-item">📅 월별</a>
                    <a href="#weekly" class="nav-item">📈 주차별</a>
                    <a href="#weekday" class="nav-item">📆 요일별</a>
                    <a href="#streak-records" class="nav-item">🔥 연승/연패</a>
                    <a href="#series" class="nav-item">⚔️ 시리즈</a>
                    <a href="#stadium" class="nav-item">🏟️ 경기장별</a>
                    <a href="#broadcaster-stats" class="nav-item">📺 중계사별</a>
                </div>
                
                <!-- 오른쪽 스크롤 표시 화살표 -->
                <div id="nav-arrow-right" class="nav-scroll-arrow nav-arrow-right" onclick="scrollNavRight()" style="
                    position: absolute;
                    right: 5px;
                    top: 50%;
                    transform: translateY(-50%);
                    pointer-events: auto;
                    cursor: pointer;
                    color: #ffffff;
                    font-size: 20px;
                    font-weight: bold;
                    z-index: 100;
                    background: rgba(0, 0, 0, 0.7);
                    border-radius: 50%;
                    border: none;
                    width: 30px;
                    height: 30px;
                    text-align: center;
                    line-height: 30px;
                ">→</div>
            </div>
        </nav>

        <!-- 네비게이션 드래그 스크롤 스크립트 -->
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            const navMenu = document.getElementById('nav-menu');
            const leftArrow = document.getElementById('nav-arrow-left');
            const rightArrow = document.getElementById('nav-arrow-right');
            let isDown = false;
            let startX;
            let scrollLeft;
            let hasMoved = false;

            // 스크롤 위치에 따라 화살표 표시/숨김
            function updateScrollArrows() {
                const scrollLeft = navMenu.scrollLeft;
                const maxScroll = navMenu.scrollWidth - navMenu.clientWidth;
                const scrollThreshold = 10; // 스크롤 임계값
                
                
                // 맨 왼쪽(시작): 오른쪽 화살표만
                if (scrollLeft <= scrollThreshold) {
                    leftArrow.style.display = 'none';
                    rightArrow.style.display = maxScroll > 0 ? 'block' : 'none';
                }
                // 맨 오른쪽(끝): 왼쪽 화살표만  
                else if (scrollLeft >= maxScroll - scrollThreshold) {
                    leftArrow.style.display = 'block';
                    rightArrow.style.display = 'none';
                }
                // 중간: 양쪽 화살표 모두
                else {
                    leftArrow.style.display = 'block';
                    rightArrow.style.display = 'block';
                }
            }

            // 네비게이션 스크롤 함수들
            window.scrollNavLeft = function() {
                const scrollAmount = navMenu.clientWidth * 0.7; // 화면 너비의 70%만큼 스크롤
                navMenu.scrollBy({
                    left: -scrollAmount,
                    behavior: 'smooth'
                });
            };
            
            window.scrollNavRight = function() {
                const scrollAmount = navMenu.clientWidth * 0.7; // 화면 너비의 70%만큼 스크롤
                navMenu.scrollBy({
                    left: scrollAmount,
                    behavior: 'smooth'
                });
            };
            
            // 페이지 로드 시 및 스크롤 시 화살표 업데이트
            updateScrollArrows();
            navMenu.addEventListener('scroll', updateScrollArrows);
            window.addEventListener('resize', updateScrollArrows);

            navMenu.addEventListener('mousedown', (e) => {
                isDown = true;
                hasMoved = false;
                startX = e.pageX - navMenu.offsetLeft;
                scrollLeft = navMenu.scrollLeft;
                navMenu.style.cursor = 'grabbing';
            });

            navMenu.addEventListener('mouseleave', () => {
                isDown = false;
                navMenu.classList.remove('dragging');
                navMenu.style.cursor = 'grab';
            });

            navMenu.addEventListener('mouseup', (e) => {
                // 드래그하지 않고 클릭만 했다면 링크 동작 허용
                if (!hasMoved && e.target.classList.contains('nav-item')) {
                    // 링크 클릭 허용 (기본 동작)
                } else if (hasMoved) {
                    // 드래그했다면 링크 클릭 방지
                    e.preventDefault();
                }
                
                isDown = false;
                hasMoved = false;
                navMenu.classList.remove('dragging');
                navMenu.style.cursor = 'grab';
            });

            navMenu.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                
                const x = e.pageX - navMenu.offsetLeft;
                const distance = Math.abs(x - startX);
                
                // 5px 이상 움직였을 때만 드래그로 인식
                if (distance > 5) {
                    hasMoved = true;
                    navMenu.classList.add('dragging');
                    e.preventDefault();
                    
                    const walk = (x - startX) * 1.5; // 스크롤 속도 조절
                    navMenu.scrollLeft = scrollLeft - walk;
                }
            });

            // 드래그 시작할 때 링크 클릭 방지
            navMenu.addEventListener('dragstart', (e) => {
                e.preventDefault();
            });

            // 드래그 중 링크 클릭 방지
            navMenu.addEventListener('click', (e) => {
                if (hasMoved || navMenu.classList.contains('dragging')) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // 초기 커서 설정
            navMenu.style.cursor = 'grab';
        });
        </script>

        <!-- 드래그 스크롤을 위한 CSS -->
        <style>
        .nav-menu {
            overflow-x: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
            scroll-behavior: smooth;
            padding: 0; /* 양쪽 여백 제거 */
            position: relative;
        }

        .nav-menu::before,
        .nav-menu::after {
            content: '';
            display: inline-block;
            width: 5px;
            height: 1px;
            flex-shrink: 0;
        }

        .nav-menu::-webkit-scrollbar { 
            display: none; /* WebKit browsers */
        }

        .nav-menu.dragging {
            scroll-behavior: auto;
        }

        .nav-menu.dragging .nav-item {
            pointer-events: none; /* 드래그 중 링크 클릭 방지 */
        }

        /* 네비게이션 아이템 간격을 원래대로 복원 */
        .nav-item {
            margin: 0 !important;
        }

        /* 네비게이션 화살표 블링크 애니메이션 */
        .nav-scroll-arrow {
            animation: navArrowBlink 2s ease-in-out infinite;
        }

        @keyframes navArrowBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }

        /* 매직넘버 네비게이션 아이템 - 개별적으로 플래싱 */
        .magic-number-nav {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
            color: white !important;
            font-weight: 600 !important;
            border: none !important;
            animation: magicNavFlash 2.5s infinite !important;
            position: relative !important;
            overflow: hidden !important;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.2) !important;
        }

        /* 매직넘버 네비 아이템은 active 클래스 무시 */
        .magic-number-nav.active {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
            color: white !important;
            animation: magicNavFlash 2.5s infinite !important;
        }

        .magic-number-nav:hover {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
            color: white !important;
            animation-play-state: paused !important;
            transform: translateY(-4px) !important;
            box-shadow: 0 12px 30px rgba(16, 185, 129, 0.3) !important;
        }

        @keyframes magicNavFlash {
            0%, 70%, 100% {
                box-shadow: 0 8px 25px rgba(16, 185, 129, 0.2);
                transform: translateY(0);
            }
            15%, 55% {
                box-shadow: 0 12px 30px rgba(16, 185, 129, 0.4);
                transform: translateY(-2px);
            }
        }

        /* 매직넘버 네비 아이템에 펄스 효과 추가 */
        .magic-number-nav::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 100%);
            animation: magicPulse 2s infinite;
            pointer-events: none;
        }

        @keyframes magicPulse {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        </style>

        <!-- 매직넘버 계산기 링크 카드 -->
        <div class="card magic-number-card" style="margin-bottom: 30px; padding: 28px 24px;">
            <div class="magic-number-content">
                <div class="magic-number-left">
                    <div class="magic-number-icon">📊</div>
                    <div class="magic-number-text">
                        <h3>🎯 KBO 매직넘버 전용 계산기 바로가기</h3>
                        <p>우승·플레이오프 매직넘버, 경우의수, 시나리오 시뮬레이션까지!<br>
                        <span style="font-size: 0.85rem; opacity: 0.9;">별도 페이지에서 더 자세한 분석을 확인하세요</span></p>
                    </div>
                </div>
                <div class="magic-number-right">
                    <a href="magic-number/index.html" class="magic-number-button">
                        <span>매직넘버 계산기 열기</span>
                        <span class="arrow">↗️</span>
                    </a>
                </div>
            </div>
        </div>

        <!-- AdSense 광고: 매직넘버 카드 후 -->
        <div class="ad-card">
            <div class="adsense-ad-wrapper">
                <div>광고</div>
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="7298546648"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
                <!-- Lazy loading으로 대체됨 -->
            </div>
        </div>

        <!-- 시즌 진행률 카드 -->
        <div class="card" id="season-progress">
            <div class="card-header">
                <span class="card-icon">📈</span>
                <h2 class="card-title">2025 KBO 시즌 진행률</h2>
            </div>
            <!-- 전체 시즌 진행률 -->
                <div style="margin-bottom: 25px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-weight: 600; font-size: 1.1rem; color: #374151;">전체 시즌 진행률</span>
                        <span id="overall-progress-text" style="font-weight: 700; font-size: 1.2rem; color: #059669;">0%</span>
                    </div>
                    <div style="background: #e5e7eb; border-radius: 10px; height: 20px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                        <div id="overall-progress-bar" style="height: 100%; background: linear-gradient(90deg, #10b981 0%, #059669 100%); width: 0%; transition: width 1.2s ease-out; border-radius: 10px; position: relative; will-change: width;">
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);"></div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.9rem; color: #6b7280;">
                        <span>시즌 시작</span>
                        <span id="games-info">0/720 경기 완료</span>
                        <span>정규시즌 종료</span>
                    </div>
                </div>

                <!-- 팀별 경기 소화율 -->
                <div>
                    <h3 style="font-weight: 600; font-size: 1.1rem; color: #374151; margin-bottom: 15px; border-bottom: 2px solid #e5e7eb; padding-bottom: 8px;">팀별 경기 소화율</h3>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; max-width: 100%;" id="team-progress-container" class="team-progress-grid">
                        <!-- 팀별 진행률이 여기에 동적으로 생성됩니다 -->
                    </div>
                </div>

                <!-- 시즌 주요 일정 -->
                <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                    <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">🗓️ 시즌 주요 일정</div>
                    <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                        <div style="margin-bottom: 6px;"><strong>정규시즌:</strong> 3월 ~ 9월</div>
                        <div style="margin-bottom: 6px;"><strong>총 경기:</strong> 720경기 (팀당 144경기)</div>
                        <div style="margin-bottom: 6px;"><strong>올스타전:</strong> 7월 11~12일 (대전)</div>
                        <div style="margin-bottom: 6px;"><strong>와일드카드:</strong> 10월 초</div>
                        <div style="margin-bottom: 6px;"><strong>플레이오프:</strong> 10월 중순</div>
                        <div><strong>한국시리즈:</strong> 10월 말</div>
                    </div>
                </div>
        </div>

        <style>
        /* 일별 통계 모바일 반응형 스타일 */
        @media (max-width: 768px) {
            .daily-stats-content-grid {
                grid-template-columns: 1fr !important;
            }
            
            .daily-stats-controls {
                flex-wrap: wrap !important;
                gap: 3px !important;
                justify-content: center !important;
            }
            
            .daily-stats-date-display {
                font-size: 12px !important;
                padding: 6px 10px !important;
                min-width: 130px !important;
                flex-shrink: 0;
            }
            
            .daily-stats-nav-buttons {
                gap: 2px !important;
            }
            
            .daily-stats-btn {
                padding: 6px 8px !important;
                font-size: 11px !important;
                flex-shrink: 0;
            }
            
            .daily-stats-date-input {
                padding: 6px 8px !important;
                font-size: 11px !important;
                width: 100px !important;
                flex-shrink: 0;
            }
            
            .daily-stats-animation-controls {
                gap: 2px !important;
            }
        }
        
        /* 버튼 호버 효과 */
        .daily-stats-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .daily-stats-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        </style>

        <!-- Google AdSense: 디스플레이 가로 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":867629,"trackingCode":"AF6959276","template":"carousel","width":"700","height":"140","tsource":""});
                </script>
            </div>
        </div>

        <!-- 일별 종합지표 분석 카드 -->
        <div class="card" id="daily-stats">
            <div class="card-header">
                <span class="card-icon">📅</span>
                <h2 class="card-title">일자별 순위·게임차·승률 그래프</h2>
            </div>
            
            <!-- 날짜 네비게이션 -->
            <div class="daily-stats-header" style="position: sticky; top: 58px; z-index: 100; margin-bottom: 15px; margin-top: 0; padding: 10px 12px; background: rgba(248, 249, 250, 0.95); backdrop-filter: blur(10px); border-radius: 8px; border: 1px solid #e9ecef; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                <div class="daily-stats-controls" style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap; justify-content: center;">
                    <div class="daily-stats-date-display" style="font-size: 14px; font-weight: 600; color: #2563eb; padding: 7px 14px; background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 7px; border: 1px solid #cbd5e1; min-width: 160px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.05);" id="daily-stats-current-date">
                        2025년 3월 22일 (금)
                    </div>
                    <div class="daily-stats-nav-buttons" style="display: flex; gap: 5px;">
                        <button class="daily-stats-btn daily-stats-btn-secondary" style="padding: 8px 12px; border: none; border-radius: 7px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s ease; background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); color: #475569; border: 1px solid #cbd5e1; box-shadow: 0 2px 4px rgba(0,0,0,0.05);" id="daily-stats-prev-btn" onclick="dailyStatsChangeDate(-1)" onmouseover="this.style.background='linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%)'" onmouseout="this.style.background='linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%)'" aria-label="이전 날짜로 이동">← 이전날</button>
                        <button class="daily-stats-btn daily-stats-btn-primary" style="padding: 8px 14px; border: none; border-radius: 7px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s ease; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; box-shadow: 0 2px 5px rgba(59, 130, 246, 0.3);" id="daily-stats-today-btn" onclick="dailyStatsGoToday()" onmouseover="this.style.background='linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%)'" onmouseout="this.style.background='linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)'" aria-label="오늘 날짜로 이동">오늘</button>
                        <button class="daily-stats-btn daily-stats-btn-secondary" style="padding: 8px 12px; border: none; border-radius: 7px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s ease; background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); color: #475569; border: 1px solid #cbd5e1; box-shadow: 0 2px 4px rgba(0,0,0,0.05);" id="daily-stats-next-btn" onclick="dailyStatsChangeDate(1)" onmouseover="this.style.background='linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%)'" onmouseout="this.style.background='linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%)'" aria-label="다음 날짜로 이동">다음날 →</button>
                    </div>
                    <input type="date" class="daily-stats-date-input" style="padding: 8px 11px; border: 1px solid #cbd5e1; border-radius: 7px; font-size: 13px; background: white; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.05);" id="daily-stats-date-input" min="2025-03-22" max="" value="" onchange="dailyStatsSelectDate(this.value)" onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" onblur="this.style.borderColor='#cbd5e1'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.05)'">
                    <div class="daily-stats-animation-controls" style="display: flex; gap: 5px; align-items: center; flex-wrap: wrap;">
                        <button class="daily-stats-btn daily-stats-btn-primary" style="padding: 8px 14px; border: none; border-radius: 7px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s ease; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; box-shadow: 0 2px 5px rgba(16, 185, 129, 0.3);" id="daily-stats-animation-btn" onclick="dailyStatsToggleAnimation()" onmouseover="this.style.background='linear-gradient(135deg, #059669 0%, #047857 100%)'" onmouseout="this.style.background='linear-gradient(135deg, #10b981 0%, #059669 100%)'" aria-label="순위 변동 애니메이션 토글">▶️ 애니메이션</button>
                        <button class="daily-stats-btn daily-stats-btn-secondary" style="padding: 8px 12px; border: none; border-radius: 7px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s ease; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; box-shadow: 0 2px 5px rgba(245, 158, 11, 0.3);" id="daily-stats-reset-btn" onclick="dailyStatsResetAnimation()" onmouseover="this.style.background='linear-gradient(135deg, #d97706 0%, #b45309 100%)'" onmouseout="this.style.background='linear-gradient(135deg, #f59e0b 0%, #d97706 100%)'" aria-label="애니메이션 개막부터 재생">⏮️ 개막부터</button>
                        
                        <!-- 애니메이션 속도 조절 -->
                        <div class="animation-speed-control" style="display: flex; align-items: center; gap: 4px; margin-left: 8px; padding: 6px 10px; background: rgba(255,255,255,0.9); border-radius: 6px; border: 1px solid #e5e7eb;">
                            <span style="font-size: 11px; color: #6b7280; font-weight: 600;">🐌</span>
                            <input type="range" id="animation-speed-slider" min="1" max="5" value="3" step="1" 
                                   style="width: 60px; height: 4px; background: #e5e7eb; outline: none; border-radius: 2px; cursor: pointer;"
                                   oninput="dailyStatsUpdateAnimationSpeed(this.value)"
                                   title="애니메이션 속도 조절">
                            <span style="font-size: 11px; color: #6b7280; font-weight: 600;">🚀</span>
                            <span id="speed-display" style="font-size: 10px; color: #9ca3af; font-weight: 600; min-width: 20px;">보통</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 컨텐츠 그리드 -->
            <div class="daily-stats-content-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <!-- 순위표 카드 -->
                <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 16px; border: 1px solid #e9ecef; height: 480px; display: flex; flex-direction: column;">
                    <h3 style="color: #333; font-size: 16px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb; flex-shrink: 0;">📊 팀 순위표</h3>
                    <div id="daily-stats-standings-container" class="loading" style="flex: 1; overflow: hidden;">
                        데이터를 불러오는 중...
                    </div>
                </div>
                
                <!-- 경기 결과 카드 -->
                <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 16px; border: 1px solid #e9ecef; height: 480px; display: flex; flex-direction: column;">
                    <h3 style="color: #333; font-size: 16px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb; flex-shrink: 0;">⚾ 경기 결과</h3>
                    <div id="daily-stats-games-container" class="loading" style="flex: 1; overflow-y: auto;">
                        데이터를 불러오는 중...
                    </div>
                </div>
            </div>
            
            <!-- 게임차 차트 -->
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; margin-bottom: 20px; height: 520px; display: flex; flex-direction: column;">
                <h3 style="color: #333; font-size: 16px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb; flex-shrink: 0;">📊 게임차 변화</h3>
                <div style="position: relative; height: 300px; margin-bottom: 15px; flex-shrink: 0;">
                    <canvas id="daily-stats-game-gap-chart"></canvas>
                </div>
                <div id="daily-stats-game-gap-info" style="padding: 12px; background: white; border-radius: 6px; font-size: 13px; line-height: 1.6; border: 1px solid #e5e7eb; flex: 1; overflow-y: auto;">
                    <div style="font-weight: 600; color: #374151; margin-bottom: 8px;">📋 순위별 게임차 정보</div>
                    <div id="daily-stats-game-gap-list" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">
                        <!-- 동적으로 채워짐 -->
                    </div>
                </div>
            </div>
            
            <!-- 승차 변화 차트 (전체 너비) -->
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; margin-bottom: 20px; height: 535px; display: flex; flex-direction: column;">
                <h3 style="color: #333; font-size: 16px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb; flex-shrink: 0;">📈 일간 승차 변화</h3>
                <div style="position: relative; flex: 1;">
                    <canvas id="daily-stats-win-gap-chart"></canvas>
                </div>
                <div id="daily-stats-win-gap-legend" style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; padding: 8px; margin-top: 10px;">
                    <!-- 동적으로 생성됨 -->
                </div>
            </div>
            
            <!-- 승수 변동 추이 차트 (전체 너비) -->
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; margin-bottom: 20px; height: 535px; display: flex; flex-direction: column;">
                <h3 style="color: #333; font-size: 16px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb; flex-shrink: 0;">🏆 일간 승수 변동</h3>
                <div style="position: relative; flex: 1;">
                    <canvas id="daily-stats-win-count-chart"></canvas>
                </div>
                <div id="daily-stats-win-count-legend" style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; padding: 8px; margin-top: 10px;">
                    <!-- 동적으로 생성됨 -->
                </div>
            </div>
            
            <!-- 순위 변동 차트 (전체 너비) -->
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; margin-bottom: 20px; height: 535px; display: flex; flex-direction: column;">
                <h3 style="color: #333; font-size: 16px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb; flex-shrink: 0;">📊 일간 순위 변동</h3>
                <div style="position: relative; flex: 1;">
                    <canvas id="daily-stats-rank-chart"></canvas>
                </div>
                <div id="daily-stats-rank-legend" style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; padding: 8px; margin-top: 10px;">
                    <!-- 동적으로 생성됨 -->
                </div>
            </div>
            
            <!-- 승률 추이 차트 (전체 너비) - 일별통계 섹션 내 승률 추이 (ROOT INDEX 메인 카드와는 별개) -->
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; height: 535px; display: flex; flex-direction: column;">
                <h3 style="color: #333; font-size: 16px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb; flex-shrink: 0;">📉 일간 승률 변동</h3>
                <div style="position: relative; flex: 1; min-height: 0; overflow: hidden;">
                    <canvas id="daily-stats-win-rate-chart"></canvas>
                </div>
                <div id="daily-stats-win-rate-legend" style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; padding: 8px; margin-top: 10px;">
                    <!-- 동적으로 생성됨 -->
                </div>
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📖 일별 종합지표 이용 가이드</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>날짜 네비게이션:</strong> ← → 버튼으로 날짜 이동, 날짜 입력으로 직접 선택, 오늘 버튼으로 최신 경기일로 이동</div>
                    <div style="margin-bottom: 6px;"><strong>애니메이션:</strong> ▶️ 버튼으로 시즌 시작부터 자동 진행, ⏸️로 일시정지, ⏮️로 시작일(3월 22일)로 이동, 🐌🚀 슬라이더로 속도 조절</div>
                    <div style="margin-bottom: 6px;"><strong>날짜 색상:</strong> 평일은 파란색, 주말/공휴일은 빨간색으로 표시</div>
                    <div style="margin-bottom: 6px;"><strong>차트 조작:</strong> 팀 로고 클릭으로 해당 팀 선 표시/숨김, 마우스 오버로 상세 정보 확인</div>
                    <div><strong>데이터 범위:</strong> 2025년 3월 22일(개막일)부터 현재까지의 실제 경기 결과 기반</div>
                </div>
            </div>
        </div>

        <!-- 쿠팡 파트너스 광고 1 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 1. 종합 순위표 (전체 지표) -->
        <div class="card" id="standings">
            <div class="card-header">
                <span class="card-icon">🏆</span>
                <h2 class="card-title">종합 순위 - 전체 지표</h2>
            </div>
            <div class="table-container">
                <table class="full-standings-table" id="fullStandingsTable" role="table" aria-label="KBO 2025 종합 순위표 - 20개 지표별 정렬 가능">
                    <thead>
                        <tr>
                            <th>순위</th>
                            <th>팀</th>
                            <th>경기</th>
                            <th>승</th>
                            <th>패</th>
                            <th>무</th>
                            <th>승패마진</th>
                            <th>승률</th>
                            <th>게임차</th>
                            <th>잔여경기</th>
                            <th>최근10경기</th>
                            <th onclick="event.stopPropagation(); sortByStreakNew();" class="no-sort" style="cursor: pointer;">연승패</th>
                            <th>홈성적</th>
                            <th>홈승률</th>
                            <th>원정성적</th>
                            <th>원정승률</th>
                            <th onclick="event.stopPropagation(); sortByMaxWinStreak();" class="no-sort" style="cursor: pointer;">최대연승</th>
                            <th onclick="event.stopPropagation(); sortByMaxLoseStreak();" class="no-sort" style="cursor: pointer;">최대연패</th>
                            <th onclick="event.stopPropagation(); sortByMaxRank();" class="no-sort" style="cursor: pointer;">최대순위</th>
                            <th onclick="event.stopPropagation(); sortByMinRank();" class="no-sort" style="cursor: pointer;">최소순위</th>
                        </tr>
                    </thead>
                    <tbody id="fullStandingsBody">
                        <!-- 동적으로 생성 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 주요 지표 설명 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📈 주요 지표 간단 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>승패마진:</strong> 승수-패수 (양수일수록 우수)</div>
                    <div style="margin-bottom: 6px;"><strong>잔여경기:</strong> 정규시즌 총 144경기 중 남은 경기수</div>
                    <div style="margin-bottom: 6px;"><strong>최근10경기:</strong> 최근 10경기의 승-패-무 기록</div>
                    <div style="margin-bottom: 6px;"><strong>홈/원정:</strong> 홈경기와 원정경기의 승-패-무 기록</div>
                    <div style="margin-bottom: 6px;"><strong>홈승률/원정승률:</strong> 홈경기와 원정경기에서의 승률 (무승부 제외)</div>
                    <div style="margin-bottom: 6px;"><strong>연승패:</strong> 현재 연속 승/패 상태</div>
                    <div style="margin-bottom: 6px;"><strong>최대연승/연패:</strong> 시즌 중 기록한 최대 연속 승부 기록</div>
                    <div style="margin-bottom: 6px;"><strong>최대순위:</strong> 전승시 도달 가능한 최고 순위 (숫자가 작을수록 좋음)</div>
                    <div style="margin-bottom: 6px;"><strong>최소순위:</strong> 전패시 도달 가능한 최저 순위 (숫자가 클수록 나쁨)</div>
                    <div><em style="color: #666; font-size: 11px;">※ 시즌 종료시 해당 팀이 도달할 수 있는 순위 범위를 나타냄</em></div>
                </div>
            </div>
        </div>

        <!-- Google AdSense: 디스플레이 가로 (종합 순위 후) -->
        <div class="ad-card">
            <div class="adsense-ad-wrapper">
                <div>광고</div>
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-format="autorelaxed"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="9345718962"></ins>
<!-- Lazy loading으로 대체됨 -->
            </div>
        </div>

        <!-- 2. 팀별 상세 게임 기록 및 경기 일정 -->
        <div class="card" id="teamdetail">
            <div class="card-header">
                <span class="card-icon">👥</span>
                <h2 class="card-title">팀별 상세 게임 기록 및 경기 일정</h2>
            </div>
            <div id="teamDetailedRecordsContent">
                <div style="text-align: center; padding: 40px; color: #666;">
                    데이터를 로드하고 있습니다...
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 팀상세 후 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":867629,"trackingCode":"AF6959276","template":"carousel","width":"700","height":"140","tsource":""});
                </script>
            </div>
        </div>

        <!-- 3. 게임별 연속 기록 -->
        <div class="card" id="gamerecords">
            <div class="card-header">
                <span class="card-icon">🎮</span>
                <h2 class="card-title">게임별 연속 기록</h2>
            </div>
            <div id="gameRecordsContent">
                <div style="text-align: center; padding: 40px; color: #666;">
                    데이터를 로드하고 있습니다...
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 게임기록 후 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":867629,"trackingCode":"AF6959276","template":"carousel","width":"700","height":"140","tsource":""});
                </script>
            </div>
        </div>

        <!-- 4. 승차 변화 추이 그래프 -->
        <div class="card" id="wingap-chart-section" style="margin-bottom: 30px;">
            <div class="card-header">
                <span class="card-icon">📈</span>
                <h2 class="card-title">승차 변화 추이</h2>
            </div>
            
            <!-- 그래프 네비게이션 -->
            <div class="chart-nav" id="wingap-chart-nav" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 0 10px;">
                <div style="min-width: 120px; display: flex; justify-content: flex-start;">
                    <button id="prevPeriodWinGap" class="nav-btn" onclick="handlePrevPeriodWinGap()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " aria-label="이전 달 승차 변화 추이 차트 보기">로딩중...</button>
                </div>
                
                <!-- 토글 버튼 (기간 정보 + 모드 전환) -->
                <button id="periodToggleWinGap" onclick="handlePeriodToggleWinGap()" style="
                    background: linear-gradient(135deg, #28a745, #34ce57);
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
                    min-width: 220px;
                " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(40, 167, 69, 0.4)'" 
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(40, 167, 69, 0.3)'" 
                   aria-label="승차 변화 추이 전체 기간과 구간 보기 전환">
                    📊 전체 시즌 보기
                </button>
                
                <div style="min-width: 120px; display: flex; justify-content: flex-end;">
                    <button id="nextPeriodWinGap" class="nav-btn" onclick="handleNextPeriodWinGap()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " aria-label="다음 달 승차 변화 추이 차트 보기">로딩중...</button>
                </div>
            </div>
            
            <!-- 현재 기간 텍스트 (월 단위 모드에서만) -->
            <div id="currentPeriodTextWinGap" style="
                text-align: center;
                margin: 0;
                height: 18px;
                font-size: 13px;
                color: #666;
                font-weight: 500;
                line-height: 18px;
                visibility: hidden;
            ">
                현재 보는 기간: -
            </div>
            
            <!-- 진행 인디케이터 -->
            <div class="progress-indicator" style="
                display: flex; 
                justify-content: center; 
                margin-bottom: 8px;
                gap: 4px;
            " id="progressDotsWinGap"></div>
            
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; margin-bottom: 20px; height: 535px; display: flex; flex-direction: column;">
                <div style="position: relative; flex: 1; min-width: 900px;">
                    <!-- 메인 승차변화추이 카드 캔버스 -->
                    <canvas id="winGapChart"></canvas>
                </div>
            </div>
            
            <!-- 팀 레전드 (순위 변동 추이와 동일한 형식) -->
            <div id="winGapChartLegend" style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; padding: 0; background: transparent; border: none; flex-shrink: 0; max-height: 60px; overflow-y: auto; margin-bottom: 0;">
                <!-- 동적으로 생성됨 -->
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📈 일간 승차 변화 그래프 이용 가이드</div>
                <ul style="margin: 6px 0; padding-left: 16px; line-height: 1.5; font-size: var(--font-sm); color: var(--text-secondary);">
                    <li><strong>기간:</strong> 3월 22일 개막~현재</li>
                    <li><strong>승차:</strong> 1위팀과의 승수 차이</li>
                    <li><strong>PO 기준:</strong> 5위까지 포스트시즌 진출</li>
                </ul>
                <div style="margin-top: 8px; font-size: 11px; color: #666;">
                    <strong>💡 사용법:</strong>
                    <ul style="margin: 6px 0 0 0; padding-left: 16px; line-height: 1.4; font-size: 12px;">
                        <li><strong>📊 전체시즌:</strong> 전체/30일 전환</li>
                        <li><strong>로고클릭:</strong> 팀 라인 숨기기</li>
                        <li><strong>마우스오버:</strong> 날짜별 승차표</li>
                    </ul>
                </div>
                <div style="margin-top: 8px; font-size: 11px; color: #666;">
                    📌 팀명 순서는 현재 순위 기준 고정, 마우스 오버로 날짜별 승차 확인
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 승차 변화 추이 후 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 2. 승수 변동 추이 -->
        <div class="card" id="win-count-chart-section" style="margin-bottom: 30px;">
            <div class="card-header">
                <span class="card-icon">🏆</span>
                <h2 class="card-title">승수 변동 추이</h2>
            </div>
            
            <!-- 그래프 네비게이션 -->
            <div class="chart-nav" id="win-count-chart-nav" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 0 10px;">
                <div style="min-width: 120px; display: flex; justify-content: flex-start;">
                    <button id="prevPeriodWinCount" class="nav-btn" onclick="handlePrevPeriodWinCount()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " aria-label="이전 달 승수 변동 차트 보기">로딩중...</button>
                </div>
                
                <!-- 토글 버튼 (기간 정보 + 모드 전환) -->
                <button id="periodToggleWinCount" onclick="handlePeriodToggleWinCount()" style="
                    background: linear-gradient(135deg, #28a745, #34ce57);
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
                    min-width: 220px;
                " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(40, 167, 69, 0.4)'" 
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(40, 167, 69, 0.3)'" 
                   aria-label="전체 기간과 구간 보기 전환">
                    📊 전체 시즌 보기
                </button>
                
                <div style="min-width: 120px; display: flex; justify-content: flex-end;">
                    <button id="nextPeriodWinCount" class="nav-btn" onclick="handleNextPeriodWinCount()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " aria-label="다음 달 승수 변동 차트 보기">로딩중...</button>
                </div>
            </div>
            
            <!-- 현재 기간 텍스트 (월 단위 모드에서만) -->
            <div id="currentPeriodTextWinCount" style="
                text-align: center;
                margin: 0;
                height: 18px;
                font-size: 13px;
                color: #666;
                font-weight: 500;
                line-height: 18px;
                visibility: hidden;
            ">
                현재 보는 기간: -
            </div>
            
            <!-- 진행 인디케이터 -->
            <div class="progress-indicator" style="
                display: flex; 
                justify-content: center; 
                margin-bottom: 8px;
                gap: 4px;
            " id="progressDotsWinCount"></div>
            
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; margin-bottom: 20px; height: 535px; display: flex; flex-direction: column;">
                <div style="position: relative; flex: 1; min-width: 900px;">
                    <!-- 메인 승수변동추이 카드 캔버스 -->
                    <canvas id="winCountChart"></canvas>
                </div>
            </div>
            
            <!-- 팀 레전드 (순위 변동 추이와 동일한 형식) -->
            <div id="winCountChartLegend" style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; padding: 0; background: transparent; border: none; flex-shrink: 0; max-height: 60px; overflow-y: auto; margin-bottom: 0;">
                <!-- 동적으로 생성됨 -->
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">🏆 일간 승수 변동 그래프 이용 가이드</div>
                <ul style="margin: 6px 0; padding-left: 16px; line-height: 1.5; font-size: var(--font-sm); color: var(--text-secondary);">
                    <li><strong>기간:</strong> 3월 22일 개막~현재</li>
                    <li><strong>승수:</strong> 각 팀의 시즌 누적 승리 횟수</li>
                    <li><strong>추이:</strong> 시즌 진행에 따른 승수 증가 패턴</li>
                </ul>
                <div style="margin-top: 8px; font-size: 11px; color: #666;">
                    <strong>💡 사용법:</strong>
                    <ul style="margin: 6px 0 0 0; padding-left: 16px; line-height: 1.4; font-size: 12px;">
                        <li><strong>📊 전체시즌:</strong> 전체/30일 전환</li>
                        <li><strong>로고클릭:</strong> 팀 라인 숨기기</li>
                        <li><strong>마우스오버:</strong> 날짜별 승수 확인</li>
                    </ul>
                </div>
                <div style="margin-top: 8px; font-size: 11px; color: #666;">
                    📌 팀명 순서는 현재 순위 기준 고정, 마우스 오버로 날짜별 승수 확인
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 순위 변동 그래프 전 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":867629,"trackingCode":"AF6959276","template":"carousel","width":"700","height":"140","tsource":""});
                </script>
            </div>
        </div>

        <!-- 3. 순위 변동 그래프 -->
        <div class="card" id="rank-chart-section" style="margin-bottom: 30px;">
            <div class="card-header">
                <span class="card-icon">📈</span>
                <h2 class="card-title">순위 변동 추이</h2>
            </div>
            
            <!-- 그래프 네비게이션 -->
            <div class="chart-nav" id="main-rank-chart-nav" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 0 10px;">
                <div style="min-width: 120px; display: flex; justify-content: flex-start;">
                    <button id="prevPeriod" class="nav-btn" onclick="handlePrevPeriod()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " aria-label="이전 달 순위 변동 차트 보기">로딩중...</button>
                </div>
                
                <!-- 토글 버튼 (기간 정보 + 모드 전환) -->
                <button id="periodToggle" onclick="handlePeriodToggle()" style="
                    background: linear-gradient(135deg, #28a745, #34ce57);
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
                    min-width: 220px;
                " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(40, 167, 69, 0.4)'" 
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(40, 167, 69, 0.3)'" 
                   aria-label="전체 기간과 구간 보기 전환">
                    📊 전체 시즌 보기
                </button>
                
                <div style="min-width: 120px; display: flex; justify-content: flex-end;">
                    <button id="nextPeriod" class="nav-btn" onclick="handleNextPeriod()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " aria-label="다음 달 순위 변동 차트 보기">로딩중...</button>
                </div>
            </div>
            
            <!-- 현재 기간 텍스트 (월 단위 모드에서만) -->
            <div id="currentPeriodText" style="
                text-align: center;
                margin: 0;
                height: 18px;
                font-size: 13px;
                color: #666;
                font-weight: 500;
                line-height: 18px;
                visibility: hidden;
            ">
                현재 보는 기간: -
            </div>
            
            <!-- 진행 인디케이터 -->
            <div class="progress-indicator" style="
                display: flex; 
                justify-content: center; 
                margin-bottom: 8px;
                gap: 4px;
            " id="progressDots"></div>
            
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; margin-bottom: 20px; height: 535px; display: flex; flex-direction: column;">
                <div style="position: relative; flex: 1; min-width: 900px;">
                    <!-- 📈 메인 순위 변동 차트 캔버스 - magic-number/scripts/ui-charts.js에서 관리 -->
                    <canvas id="rankChart"></canvas>
                </div>
            </div>
            
            <!-- 
            ⚠️ 메인 순위 차트 레전드 - 중요한 위치 정보 ⚠️
            =================================================================
            📍 이 요소는 magic-number/scripts/ui-charts.js에서 완전히 관리됨
            📍 createCustomLegend() 함수가 innerHTML을 덮어씀 (420번째 줄)
            📍 "전체 선택 (7/10)" 형태의 팀 수 표시 기능 포함
            📍 직접 HTML 수정 시 JavaScript가 덮어쓰므로 주의!
            =================================================================
            -->
            <div id="mainRankChartLegend" style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; padding: 0; background: transparent; border: none; flex-shrink: 0; max-height: 60px; overflow-y: auto; margin-bottom: 0;">
                <!-- ✅ ui-charts.js의 createCustomLegend()에서 동적으로 생성됨 -->
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📈 순위 변동 그래프 이용 가이드</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>기간:</strong> 2025년 3월 22일 개막부터 현재까지 실제 경기 결과 기반</div>
                    <div style="margin-bottom: 6px;"><strong>순위 계산:</strong> 각 날짜별 누적 승률과 승차로 산정된 실제 순위</div>
                    <div style="margin-bottom: 6px;"><strong>플레이오프 기준:</strong> 빨간 선(5.5위)이 플레이오프 진출 경계선</div>
                    <div style="margin-bottom: 6px;"><strong>조작 방법:</strong> ← → 버튼으로 월별 이동, 📊 버튼으로 전체/구간 전환, 팀 로고 클릭으로 표시/숨김</div>
                    <div><strong>팁:</strong> 차트에 마우스를 올리면 해당 날짜의 순위표를 볼 수 있습니다</div>
                </div>
            </div>
        </div>

        <!-- AdSense 광고: 순위 변동 추이 후 -->
        <div class="ad-card">
            <div class="adsense-ad-wrapper">
                <div>광고</div>
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-format="autorelaxed"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="9345718962"></ins>
                <!-- Lazy loading으로 대체됨 -->
            </div>
        </div>

        <!-- 3. 승률 변동 그래프 - ROOT INDEX 메인 승률 추이 카드 (일별통계 섹션과는 별개) -->
        <div class="card" id="winrate-chart-section" style="margin-bottom: 30px;">
            <div class="card-header">
                <span class="card-icon">📉</span>
                <h2 class="card-title">승률 추이</h2>
            </div>
            
            <!-- 그래프 네비게이션 -->
            <div class="chart-nav" id="winrate-chart-nav" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 0 10px;">
                <div style="min-width: 120px; display: flex; justify-content: flex-start;">
                    <button id="prevPeriodWinRate" class="nav-btn" onclick="handlePrevPeriodWinRate()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " aria-label="이전 달 승률 추이 차트 보기">로딩중...</button>
                </div>
                
                <!-- 토글 버튼 (기간 정보 + 모드 전환) -->
                <button id="periodToggleWinRate" onclick="handlePeriodToggleWinRate()" style="
                    background: linear-gradient(135deg, #28a745, #34ce57);
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
                    min-width: 220px;
                " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(40, 167, 69, 0.4)'" 
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(40, 167, 69, 0.3)'" 
                   aria-label="승률 추이 전체 기간과 구간 보기 전환">
                    📊 전체 시즌 보기
                </button>
                
                <div style="min-width: 120px; display: flex; justify-content: flex-end;">
                    <button id="nextPeriodWinRate" class="nav-btn" onclick="handleNextPeriodWinRate()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " aria-label="다음 달 승률 추이 차트 보기">로딩중...</button>
                </div>
            </div>
            
            <!-- 현재 기간 텍스트 (월 단위 모드에서만) -->
            <div id="currentPeriodTextWinRate" style="
                text-align: center;
                margin: 0;
                height: 18px;
                font-size: 13px;
                color: #666;
                font-weight: 500;
                line-height: 18px;
                visibility: hidden;
            ">
                현재 보는 기간: -
            </div>
            
            <!-- 진행 인디케이터 -->
            <div class="progress-indicator" style="
                display: flex; 
                justify-content: center; 
                margin-bottom: 8px;
                gap: 4px;
            " id="progressDotsWinRate"></div>
            
            <div class="daily-stats-sub-card" style="background: #f8f9fa; border-radius: 8px; padding: 15px; border: 1px solid #e9ecef; margin-bottom: 20px; height: 535px; display: flex; flex-direction: column;">
                <div style="position: relative; flex: 1; min-width: 900px;">
                    <!-- 메인 승률추이 카드 캔버스 -->
                    <canvas id="winRateChart"></canvas>
                </div>
            </div>
            
            <!-- 팀 레전드 (순위 변동 추이와 동일한 형식) -->
            <div id="winRateChartLegend" style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; padding: 0; background: transparent; border: none; flex-shrink: 0; max-height: 60px; overflow-y: auto; margin-bottom: 0;">
                <!-- 동적으로 생성됨 -->
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📉 일간 승률 변동 그래프 이용 가이드</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>기간:</strong> 2025년 3월 22일 개막부터 현재까지 실제 경기 결과 기반</div>
                    <div style="margin-bottom: 6px;"><strong>승률 계산:</strong> 각 날짜별 누적 승률 (무승부 제외)</div>
                    <div style="margin-bottom: 6px;"><strong>승률 표시:</strong> 소수점 세 자리까지 표시</div>
                    <div style="margin-bottom: 6px;"><strong>조작 방법:</strong> ← → 버튼으로 월별 이동, 📊 버튼으로 전체/구간 전환, 팀 로고 클릭으로 표시/숨김</div>
                    <div><strong>팁:</strong> 차트에 마우스를 올리면 해당 날짜의 승률을 볼 수 있습니다</div>
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 전반기/후반기 성적 비교 전 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 전반기/후반기 성적 비교 -->
        <div class="card" id="half-season-stats">
            <div class="card-header">
                <span class="card-icon">⚾</span>
                <h2 class="card-title">전반기/후반기 성적 비교</h2>
            </div>
            
            
            <!-- 전반기/후반기 성적 테이블 -->
            <div class="table-container" style="overflow-x: auto;">
                <table id="half-season-table" class="half-season-table" role="table" aria-label="전반기 후반기 성적 비교표">
                    <thead>
                        <tr>
                            <th rowspan="3" class="half-season-header rank-cell" onclick="sortHalfSeasonTable('rank')">순위</th>
                            <th rowspan="3" class="half-season-header team-cell">팀명</th>
                            <th colspan="2" rowspan="2" class="half-season-header current-header">현재</th>
                            <th colspan="10" class="half-season-header first-half-main">전반기 (개막~7/12)</th>
                            <th colspan="10" class="half-season-header second-half-main">후반기 (7/13~현재)</th>
                            <th rowspan="3" class="half-season-header change-cell" onclick="sortHalfSeasonTable('performance.winRateChange')">성적<br>변화</th>
                        </tr>
                        <tr>
                            <th colspan="4" class="half-season-header sub-group-first">기본 성적</th>
                            <th colspan="2" class="half-season-header sub-group-first">득실점</th>
                            <th colspan="2" class="half-season-header sub-group-first">특수 승률</th>
                            <th colspan="2" class="half-season-header sub-group-first last">연속 기록</th>
                            <th colspan="4" class="half-season-header sub-group-second">기본 성적</th>
                            <th colspan="2" class="half-season-header sub-group-second">득실점</th>
                            <th colspan="2" class="half-season-header sub-group-second">특수 승률</th>
                            <th colspan="2" class="half-season-header sub-group-second">연속 기록</th>
                        </tr>
                        <tr>
                            <!-- 현재 시즌 -->
                            <th class="half-season-header current-record" onclick="sortHalfSeasonTable('currentSeason.wins')">승-패-무</th>
                            <th class="half-season-header current-winrate" onclick="sortHalfSeasonTable('currentSeason.winRate')">승률</th>
                            <!-- 전반기 -->
                            <th class="half-season-header detail-first games" onclick="sortHalfSeasonTable('firstHalf.games')">경기</th>
                            <th class="half-season-header detail-first record" onclick="sortHalfSeasonTable('firstHalf.wins')">승-패-무</th>
                            <th class="half-season-header detail-first winrate" onclick="sortHalfSeasonTable('firstHalf.winRate')">승률</th>
                            <th class="half-season-header detail-first rank" onclick="sortHalfSeasonTable('firstHalf.rank')">순위</th>
                            <th class="half-season-header detail-first runs" onclick="sortHalfSeasonTable('firstHalf.runsPerGame')">득점<br>평균</th>
                            <th class="half-season-header detail-first runs" onclick="sortHalfSeasonTable('firstHalf.runsAllowedPerGame')">실점<br>평균</th>
                            <th class="half-season-header detail-first runs" onclick="sortHalfSeasonTable('firstHalf.oneRunWinRate')">1점차</th>
                            <th class="half-season-header detail-first runs" onclick="sortHalfSeasonTable('firstHalf.threeRunWinRate')">3점차</th>
                            <th class="half-season-header detail-first runs" onclick="sortHalfSeasonTable('firstHalf.maxWinStreak')">최대<br>연승</th>
                            <th class="half-season-header detail-first runs last" onclick="sortHalfSeasonTable('firstHalf.maxLoseStreak')">최대<br>연패</th>
                            <!-- 후반기 -->
                            <th class="half-season-header detail-second games" onclick="sortHalfSeasonTable('secondHalf.games')">경기</th>
                            <th class="half-season-header detail-second record" onclick="sortHalfSeasonTable('secondHalf.wins')">승-패-무</th>
                            <th class="half-season-header detail-second winrate" onclick="sortHalfSeasonTable('secondHalf.winRate')">승률</th>
                            <th class="half-season-header detail-second rank" onclick="sortHalfSeasonTable('secondHalf.rank')">순위</th>
                            <th class="half-season-header detail-second runs" onclick="sortHalfSeasonTable('secondHalf.runsPerGame')">득점<br>평균</th>
                            <th class="half-season-header detail-second runs" onclick="sortHalfSeasonTable('secondHalf.runsAllowedPerGame')">실점<br>평균</th>
                            <th class="half-season-header detail-second runs" onclick="sortHalfSeasonTable('secondHalf.oneRunWinRate')">1점차</th>
                            <th class="half-season-header detail-second runs" onclick="sortHalfSeasonTable('secondHalf.threeRunWinRate')">3점차</th>
                            <th class="half-season-header detail-second runs" onclick="sortHalfSeasonTable('secondHalf.maxWinStreak')">최대<br>연승</th>
                            <th class="half-season-header detail-second runs last" onclick="sortHalfSeasonTable('secondHalf.maxLoseStreak')">최대<br>연패</th>
                        </tr>
                    </thead>
                    <tbody id="half-season-tbody" style="border-top: 1px solid #ddd;">
                        <!-- JavaScript로 동적 생성 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 전반기/후반기 성적 설명 -->
            <div class="half-season-legend" style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">⚾ 전반기/후반기 성적 가이드</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px;">
                        <div>
                            <strong style="color: #2d3748; font-size: 13px;">📊 기본 정보</strong>
                            <ul style="margin: 6px 0 0 0; padding-left: 16px; line-height: 1.4; font-size: 12px;">
                                <li><strong>전반기:</strong> 개막(3/22) ~ 올스타전 전(7/12)</li>
                                <li><strong>후반기:</strong> 올스타전 후(7/13) ~ 현재</li>
                                <li><strong>승률:</strong> 무승부 제외 계산</li>
                                <li><strong>순위:</strong> 각 기간별 승률 기준</li>
                            </ul>
                        </div>
                        <div>
                            <strong style="color: #2d3748; font-size: 13px;">📈 세부 통계</strong>
                            <ul style="margin: 6px 0 0 0; padding-left: 16px; line-height: 1.4; font-size: 12px;">
                                <li><strong>득점평균:</strong> 경기당 평균 득점</li>
                                <li><strong>실점평균:</strong> 경기당 평균 실점</li>
                                <li><strong>1점차:</strong> 1점차 경기 승률</li>
                                <li><strong>3점차:</strong> 3점차 이내 경기 승률</li>
                            </ul>
                        </div>
                        <div>
                            <strong style="color: #2d3748; font-size: 13px;">🔄 성적 변화</strong>
                            <ul style="margin: 6px 0 0 0; padding-left: 16px; line-height: 1.4; font-size: 12px;">
                                <li><strong>📈 상승:</strong> 승률 +0.05 이상</li>
                                <li><strong>➡️ 유지:</strong> 승률 변화 ±0.05 이내</li>
                                <li><strong>📉 하락:</strong> 승률 -0.05 이하</li>
                                <li><strong>연속기록:</strong> 최대 연승/연패</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <!-- Google AdSense: 피타고리안 분석 전 (멀티플렉스) -->
        <div class="ad-card">
            <div class="adsense-ad-wrapper">
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-format="autorelaxed"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="9345718962"></ins>
<!-- Lazy loading으로 대체됨 -->
            </div>
        </div>

        <!-- 3. 피타고리안 & 운 분석 -->
        <div class="card" id="pythagorean">
            <div class="card-header">
                <span class="card-icon">⚡</span>
                <h2 class="card-title">피타고리안 기대승률 & 운 지수 분석</h2>
            </div>
            
            <div class="table-container">
                <table class="detail-table" id="pythagoreanTable" style="table-layout: fixed; width: 100%;" role="table" aria-label="피타고리안 기대승률 및 운 지수 분석표">
                    <thead>
                        <tr>
                            <th rowspan="2" style="width: 4%;">순위</th>
                            <th rowspan="2" style="width: 8%;">팀</th>
                            <th colspan="3">실제 기록</th>
                            <th colspan="3">기대 기록</th>
                            <th colspan="2">승률 비교</th>
                            <th colspan="2">운 지수 분석</th>
                            <th colspan="2">득실점 현황</th>
                            <th colspan="2">득실차 분석</th>
                        </tr>
                        <tr>
                            <th style="width: 5%; cursor: pointer;" onclick="sortPythagoreanTable('actualWins')">승</th>
                            <th style="width: 5%; cursor: pointer;" onclick="sortPythagoreanTable('actualLosses')">패</th>
                            <th style="width: 5%; cursor: pointer;" onclick="sortPythagoreanTable('actualDraws')">무</th>
                            <th style="width: 5%; cursor: pointer;" onclick="sortPythagoreanTable('expectedWins')">기대 승</th>
                            <th style="width: 5%; cursor: pointer;" onclick="sortPythagoreanTable('expectedLosses')">기대 패</th>
                            <th style="width: 5%; cursor: pointer;" onclick="sortPythagoreanTable('expectedDraws')">기대 무</th>
                            <th style="width: 7%; cursor: pointer;" onclick="sortPythagoreanTable('actualWinRate')">실제승률</th>
                            <th style="width: 7%; cursor: pointer;" onclick="sortPythagoreanTable('expectedWinRate')">기대승률</th>
                            <th style="width: 7%; cursor: pointer;" onclick="sortPythagoreanTable('luckIndex')">운 지수</th>
                            <th style="width: 9%; cursor: pointer;" onclick="sortPythagoreanTable('luckStatus')">운 상태</th>
                            <th style="width: 7%; cursor: pointer;" onclick="sortPythagoreanTable('runsScored')">득점</th>
                            <th style="width: 7%; cursor: pointer;" onclick="sortPythagoreanTable('runsAllowed')">실점</th>
                            <th style="width: 8%; cursor: pointer;" onclick="sortPythagoreanTable('runDiff')">실제 득실차</th>
                            <th style="width: 8%; cursor: pointer;" onclick="sortPythagoreanTable('expectedRunDiff')">기대 득실차</th>
                        </tr>
                    </thead>
                    <tbody id="pythagoreanBody">
                        <!-- 동적으로 생성 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📊 지표 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>피타고리안 기대승률:</strong> 득점과 실점으로 계산한 '이론적' 승률 (득점²÷(득점²+실점²))</div>
                    <div style="margin-bottom: 6px;"><strong>기대 승-패-무:</strong> 피타고리안 승률을 바탕으로 계산한 이론적 승부 기록</div>
                    <div style="margin-bottom: 6px;"><strong>운 지수:</strong> 실제승률 - 기대승률 (양수: 운이 좋음, 음수: 운이 나쁨)</div>
                    <div style="margin-bottom: 6px;"><strong>운 상태:</strong> +0.05 이상(매우 좋음), +0.03~0.05(좋음), +0.01~0.03(약간 좋음), ±0.01(평균적), -0.01~-0.03(약간 나쁨), -0.03~-0.05(나쁨), -0.05 이하(매우 나쁨)</div>
                    <div style="margin-bottom: 6px;"><strong>기대 득실차:</strong> 피타고리안 승률 기반으로 계산한 이론적 득실차</div>
                    <div><strong>색상 구분:</strong> 검정(실제), 파랑(기대), 녹색/빨강(운 지수)</div>
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 클러치 상황 분석 전 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":867629,"trackingCode":"AF6959276","template":"carousel","width":"700","height":"140","tsource":""});
                </script>
            </div>
        </div>

        <!-- 3. 클러치 상황 분석 -->
        <div class="card" id="clutch">
            <div class="card-header">
                <span class="card-icon">🎯</span>
                <h2 class="card-title">클러치 상황 분석</h2>
            </div>
            
            <div class="table-container">
                <table class="detail-table" id="clutchTable" role="table" aria-label="클러치 상황 분석표">
                    <thead>
                        <tr>
                            <th>순위</th>
                            <th>팀</th>
                            <th>1점차승</th>
                            <th>1점차패</th>
                            <th>1점차승률</th>
                            <th>3점차내승</th>
                            <th>3점차내패</th>
                            <th>3점차내승률</th>
                            <th>대량득점</th>
                            <th>대량실점</th>
                            <th>완봉승</th>
                            <th>완봉패</th>
                            <th>클러치지수</th>
                        </tr>
                    </thead>
                    <tbody id="clutchBody">
                        <!-- 동적으로 생성 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">🎯 클러치 지표 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-Height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>클러치:</strong> 중요한 순간, 특히 승부가 갈리는 상황에서의 경기력</div>
                    <div style="margin-bottom: 6px;"><strong>1점차 승률:</strong> 1점 차이로 승부가 난 경기에서의 승률 (가장 치열한 접전)</div>
                    <div style="margin-bottom: 6px;"><strong>2점차 승률:</strong> 2점 차이로 승부가 난 경기에서의 승률</div>
                    <div style="margin-bottom: 6px;"><strong>3점차 승률:</strong> 3점 차이로 승부가 난 경기에서의 승률</div>
                    <div style="margin-bottom: 6px;"><strong>클러치 지수:</strong> 1점차, 2점차, 3점차 승률을 종합한 접전 상황 경기력 지표</div>
                    <div style="margin-bottom: 6px;"><strong>색상 구분:</strong> 녹색(0.500 초과), 노란색(0.500 기준), 빨간색(0.500 미만)</div>
                    <div><strong>대량득점/실점:</strong> 7점 이상 득점하거나 7점차 이상 패배 경기 수</div>
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 클러치 분석 후 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 4. 홈/원정 상세 분석 -->
        <div class="card" id="homeaway">
            <div class="card-header">
                <span class="card-icon">🏟️</span>
                <h2 class="card-title">홈/원정 상세 분석</h2>
            </div>
            
            <div class="table-container">
                <table class="detail-table" id="homeAwayTable" role="table" aria-label="홈 원정 경기 상세 분석표">
                    <thead>
                        <tr>
                            <th>순위</th>
                            <th style="min-width: 70px;">팀</th>
                            <th>홈 경기</th>
                            <th>홈 승</th>
                            <th>홈 패</th>
                            <th>홈 무</th>
                            <th>홈 승률</th>
                            <th>원정 경기</th>
                            <th>원정 승</th>
                            <th>원정 패</th>
                            <th>원정 무</th>
                            <th>원정 승률</th>
                            <th>홈 어드밴티지</th>
                            <th style="min-width: 140px;">홈구장</th>
                        </tr>
                    </thead>
                    <tbody id="homeAwayBody">
                        <!-- 동적으로 생성 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">🏟️ 홈/원정 지표 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>홈 경기:</strong> 자기 팀 구장에서 치르는 경기 (관중 응원, 환경 익숙함 등 유리)</div>
                    <div style="margin-bottom: 6px;"><strong>원정 경기:</strong> 상대 팀 구장에서 치르는 경기 (불리한 환경)</div>
                    <div style="margin-bottom: 6px;"><strong>홈 어드밴티지:</strong> 홈승률 - 원정승률 (양수일수록 홈에서 강함, 음수일수록 원정에서 강함)</div>
                    <div><strong>승률 색상:</strong> <span style="color: #15803d; font-weight: 600;">진한 녹색(0.65↑)</span>, <span style="color: #059669; font-weight: 600;">연한 녹색(0.5 초과)</span>, <span style="color: #d97706; font-weight: 600;">주황색(정확히 0.5)</span>, <span style="color: #dc2626; font-weight: 600;">연한 빨강(0.5 미만)</span>, <span style="color: #991b1b; font-weight: 600;">진한 빨강(0.35↓)</span></div>
                    <div style="margin-top: 6px;"><strong>홈 어드밴티지 색상:</strong> <span style="color: #15803d; font-weight: 600;">진한 녹색(+0.15↑)</span>, <span style="color: #059669; font-weight: 600;">연한 녹색(양수)</span>, <span style="color: #d97706; font-weight: 600;">주황색(정확히 0)</span>, <span style="color: #dc2626; font-weight: 600;">연한 빨강(음수)</span>, <span style="color: #991b1b; font-weight: 600;">진한 빨강(-0.15↓)</span></div>
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 상대전적 매트릭스 전 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":867629,"trackingCode":"AF6959276","template":"carousel","width":"700","height":"140","tsource":""});
                </script>
            </div>
        </div>

        <!-- 5. 상대전적 매트릭스 -->
        <div class="card" id="matrix">
            <div class="card-header">
                <span class="card-icon">⚔️</span>
                <h2 class="card-title">팀간 상대전적 매트릭스</h2>
            </div>
            
            <div class="table-container">
                <div id="matrixContent">
                    <!-- 동적으로 생성 -->
                </div>
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">⚔️ 상대전적 매트릭스 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>매트릭스 읽는 법:</strong> 세로축 팀이 가로축 팀과의 전적 (예: LG행-KIA열 = LG가 KIA와의 전적)</div>
                    <div style="margin-bottom: 6px;"><strong>표시 형식:</strong> 승-패-무 (승률) + 홈🏠/원정✈️ 성적</div>
                    <div style="margin-bottom: 6px;"><strong>우위/열세 표시:</strong> <span style="font-weight: 600;">⭐ 9승 이상(우위 확정)</span>, <span style="font-weight: 600;">🔻 9패 이상(열세 확정)</span></div>
                    <div style="margin-bottom: 6px;"><strong>대각선 표시:</strong> 자기 자신과의 경기는 없으므로 "-"로 표시</div>
                    <div style="margin-bottom: 6px;"><strong>시즌 기준:</strong> KBO 정규시즌 팀당 16경기씩 맞대결 (총 144경기)</div>
                    <div><strong>색상 구분:</strong> <span style="color: #16a34a; font-weight: 600;">녹색(0.500 초과, 우위)</span>, <span style="color: #eab308; font-weight: 600;">노란색(정확히 0.500, 동등)</span>, <span style="color: #dc2626; font-weight: 600;">빨간색(0.500 미만, 열세)</span></div>
                </div>
            </div>
        </div>

        <!-- 광고 5: 상대전적 매트릭스 후 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 5-2. 팀간 잔여경기수 -->
        <div class="card" id="remaining-games">
            <div class="card-header">
                <span class="card-icon">📅</span>
                <h2 class="card-title">팀간 잔여경기수</h2>
            </div>
            <div class="table-container">
                <div id="remainingGamesContent">
                    <!-- 동적으로 생성 -->
                </div>
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📅 잔여경기수 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>매트릭스 읽는 법:</strong> 세로축 팀이 가로축 팀과 남은 경기수 (예: LG행-KIA열 = LG와 KIA의 남은 경기수)</div>
                    <div style="margin-bottom: 6px;"><strong>대각선 표시:</strong> 자기 자신과의 경기는 없으므로 "-"로 표시</div>
                    <div style="margin-bottom: 6px;"><strong>정규시즌 기준:</strong> 각 팀당 총 16경기 (홈/원정 불균등 배분)</div>
                    <div style="margin-bottom: 6px;"><strong>홈/원정 배분:</strong> 2025시즌 기준 홈/원정 경기 배분 (총 144경기)</div>
                    <div><strong>색상 구분:</strong> <span style="color: #22c55e; font-weight: 600;">녹색(7경기 이상)</span>, <span style="color: #eab308; font-weight: 600;">노란색(4-6경기)</span>, <span style="color: #f97316; font-weight: 600;">주황색(1-3경기)</span>, <span style="color: #9ca3af; font-weight: 600;">회색(경기 종료)</span></div>
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 월별 성적 분석 전 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 6. 월별 성적 완전 분석 -->
        <div class="card" id="monthly">
            <div class="card-header">
                <span class="card-icon">📊</span>
                <h2 class="card-title">월별 성적 분석</h2>
            </div>
            <div class="table-container">
                <table class="detail-table" id="monthlyTable" role="table" aria-label="월별 성적 분석표">
                    <thead id="monthlyTableHead">
                        <!-- 동적으로 생성 -->
                    </thead>
                    <tbody id="monthlyBody">
                        <!-- 동적으로 생성 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 월별 성적 분석 설명 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📊 월별 성적 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>월별 성적:</strong> 3월부터 10월까지 각 월별 승패 기록과 승률 분석</div>
                    <div style="margin-bottom: 6px;"><strong>최고월/최저월:</strong> 각 팀의 가장 좋았던 월과 나빴던 월을 배경색으로 강조</div>
                    <div style="margin-bottom: 10px;"><strong>색상 구분:</strong> <span style="background: var(--positive-bg-medium); padding: 2px 6px; border-radius: 3px;">0.500 초과 (좋음)</span> <span style="background: var(--neutral-bg-light); padding: 2px 6px; border-radius: 3px;">0.500 (보통)</span> <span style="background: var(--negative-bg-medium); padding: 2px 6px; border-radius: 3px;">0.500 미만 (나쁨)</span></div>
                </div>
                <div style="font-size: var(--font-xs); color: #8e9194; border-top: 1px solid #e9ecef; padding-top: 8px;">
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 6px;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="width: 16px; height: 12px; background: var(--positive-bg-strong); border-radius: 2px;"></div>
                            <span>최고월 강조</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="width: 16px; height: 12px; background: var(--negative-bg-strong); border-radius: 2px;"></div>
                            <span>최저월 강조</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <!-- Google AdSense: 월별 분석 후 (멀티플렉스) -->
        <div class="ad-card">
            <div class="adsense-ad-wrapper">
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-format="autorelaxed"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="9345718962"></ins>
<!-- Lazy loading으로 대체됨 -->
            </div>
        </div>

        <!-- 7. 주차별 성적 분석 -->
        <div class="card" id="weekly">
            <div class="card-header">
                <span class="card-icon">📅</span>
                <h2 class="card-title">주차별 성적 분석</h2>
            </div>
            <div id="weeklyStatsContent">
                <div style="text-align: center; padding: 40px; color: #666;">
                    데이터를 로드하고 있습니다...
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 요일별 성적 분석 전 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":867629,"trackingCode":"AF6959276","template":"carousel","width":"700","height":"140","tsource":""});
                </script>
            </div>
        </div>

        <!-- 8. 요일별 성적 완전 분석 -->
        <div class="card" id="weekday">
            <div class="card-header">
                <span class="card-icon">📅</span>
                <h2 class="card-title">요일별 성적 분석</h2>
            </div>
            <div class="table-container">
                <table class="detail-table" id="weekdayTable" role="table" aria-label="요일별 성적 분석표">
                    <thead id="weekdayTableHead">
                        <!-- 동적으로 생성 -->
                    </thead>
                    <tbody id="weekdayBody">
                        <!-- 동적으로 생성 -->
                    </tbody>
                </table>
            </div>

            <!-- 요일별 성적 분석 설명 - 행/열 반전 구조 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📅 요일별 성적 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>테이블 구조:</strong> 요일(월~일)이 좌측 행, 팀명이 상단 열로 배치</div>
                    <div style="margin-bottom: 6px;"><strong>데이터 형식:</strong> 각 셀에 "승-패-무 (승률)" + "경기수" 형태로 표시</div>
                    <div style="margin-bottom: 6px;"><strong>평일/주말 성적:</strong> 각 요일별 성적 하단에 평일성적(월~금), 주말성적(토~일) 요약</div>
                    <div style="margin-bottom: 6px;"><strong>라벨 색상:</strong> <span style="background: #e9ecef; color: #495057; padding: 2px 6px; border-radius: 3px; border: 1px solid #dee2e6;">평일 요일/평일성적</span> <span style="background: #e9ecef; color: #dc2626; padding: 2px 6px; border-radius: 3px; border: 1px solid #dee2e6;">주말 요일/주말성적</span></div>
                    <div><strong>승률 색상:</strong> <span style="background: var(--positive-bg-medium); padding: 2px 6px; border-radius: 3px;">0.500 초과</span> <span style="background: var(--neutral-bg-light); padding: 2px 6px; border-radius: 3px;">0.500</span> <span style="background: var(--negative-bg-medium); padding: 2px 6px; border-radius: 3px;">0.500 미만</span></div>
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고 2: 요일별 성적 분석 후 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 9. (추후 재배치됨) -->

        <!-- 10. 연승/연패 기록 분석 -->
        <div class="card" id="streak-records">
            <div class="card-header">
                <span class="card-icon">📊</span>
                <h2 class="card-title">연승/연패 기록 분석</h2>
            </div>
            
            <!-- 연승/연패 기록 표시 영역 -->
            <div id="streakRecordsContent">
                <div style="text-align: center; padding: 40px; color: #666;">
                    연승/연패 기록을 로드하고 있습니다...
                </div>
            </div>
            
            <!-- 설명 -->
            <div style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📊 연승/연패 기록 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>1승:</strong> 단독 승리 후 패배한 경우의 횟수</div>
                    <div style="margin-bottom: 6px;"><strong>2연승:</strong> 정확히 2경기 연속 승리한 횟수</div>
                    <div style="margin-bottom: 6px;"><strong>3연승 이상:</strong> 3경기 이상 연속 승리한 모든 연승의 횟수</div>
                    <div style="margin-bottom: 6px;"><strong>연패 기록:</strong> 연승과 동일한 방식으로 계산 (무승부는 연승/연패를 끊음)</div>
                    <div><strong>최대 기록:</strong> 시즌 중 기록한 최장 연승/연패 횟수</div>
                </div>
            </div>
        </div>


        <!-- Google AdSense: 연승/연패 분석 후 -->
        <div class="ad-card">
            <div class="adsense-ad-wrapper">
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="7298546648"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
<!-- Lazy loading으로 대체됨 -->
            </div>
        </div>

        <!-- 11. 위닝/루징 시리즈 및 스윕 -->
        <div class="card" id="series">
            <div class="card-header">
                <span class="card-icon">⚔️</span>
                <h2 class="card-title">위닝/루징 시리즈 분석</h2>
            </div>
            <div id="seriesAnalysisContent">
                <div style="text-align: center; padding: 40px; color: #666;">
                    데이터를 로드하고 있습니다...
                </div>
            </div>
        </div>

        <!-- 광고 7: 위닝/루징 시리즈 분석 후 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 12. 경기장별 성적 완전 분석 -->
        <div class="card" id="stadium">
            <div class="card-header">
                <span class="card-icon">🏟️</span>
                <h2 class="card-title">경기장별 성적 분석</h2>
            </div>
            <div class="table-container">
                <table class="detail-table" id="stadiumTable" role="table" aria-label="경기장별 성적 분석표">
                    <thead id="stadiumTableHead">
                        <!-- 동적으로 생성 -->
                    </thead>
                    <tbody id="stadiumTableBody">
                        <!-- 동적으로 생성 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">🏟️ 경기장별 성적 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>파란색 배경:</strong> 해당 팀의 홈구장 (🏠 표시) - 홈팀이 유리한 환경</div>
                    <div><strong>경기수:</strong> 해당 경기장에서 치른 총 경기 수</div>
                </div>
            </div>
        </div>

        <!-- 쿠팡 광고: 중계사별 승률 분석 전 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 최종. 중계사별 승률 분석 -->
        <div class="card" id="broadcaster-stats">
            <div class="card-header">
                <span class="card-icon">📺</span>
                <h2 class="card-title">중계사별 승률 분석</h2>
            </div>
            <div class="table-container">
                <table class="detail-table" id="broadcasterTable" style="table-layout: fixed; width: 100%;" role="table" aria-label="중계사별 승률 분석표">
                    <thead id="broadcasterHeader">
                        <!-- 동적으로 생성 -->
                    </thead>
                    <tbody id="broadcasterBody">
                        <!-- 동적으로 생성 -->
                    </tbody>
                </table>
            </div>

            <!-- 중계사별 승률 설명 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📺 중계사별 승률 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>지상파:</strong> KBS, MBC, SBS 중계 경기에서의 팀별 승률</div>
                    <div style="margin-bottom: 6px;"><strong>케이블:</strong> KBS Sports, MBC Sports+, SBS Sports, SPOTV, SPOTV 2 등 전문 스포츠 채널</div>
                    <div style="margin-bottom: 6px;"><strong>총 합계:</strong> 5개 주요 중계사 (KBS, MBC, SBS, SPOTV, SPOTV2) 기준</div>
                    <div><strong>색상 구분:</strong> <span style="background: var(--positive-bg-medium); padding: 2px 6px; border-radius: 3px;">0.500 초과</span> <span style="background: var(--neutral-bg-light); padding: 2px 6px; border-radius: 3px;">0.500</span> <span style="background: var(--negative-bg-medium); padding: 2px 6px; border-radius: 3px;">0.500 미만</span></div>
                </div>
            </div>
        </div>

        <!-- 마지막 광고 -->
        <div class="ad-card">
            <div class="coupang-ad-wrapper">
                <div>광고</div>
                <script src="https://ads-partners.coupang.com/g.js"></script>
                <script>
                    new PartnersCoupang.G({"id":918101,"trackingCode":"AF6959276","template":"carousel","width":"1300","height":"180","tsource":""});
                </script>
            </div>
        </div>

        <!-- 개선 제안 카드 -->
        <div class="card">
            <div class="card-header">
                <span class="card-icon">💡</span>
                <h2 class="card-title">개선 제안을 보내주세요</h2>
            </div>
            <div class="improvement-suggestion-content">
                <p class="improvement-suggestion-text">
                    더 나은 서비스를 위해 여러분의 의견이 필요합니다<br>
                    <span class="improvement-suggestion-subtext">회원가입 없이 간편하게 제출 가능합니다</span>
                </p>
                <a href="https://docs.google.com/forms/d/e/1FAIpQLSdsKAxcN6CuEf2f7WkEscHxdub20VlkaNTtis_okXUh-I4BTQ/viewform?usp=header"
                   target="_blank"
                   rel="noopener"
                   class="improvement-suggestion-btn">
                    📝 개선 제안 설문지 작성하기
                </a>
            </div>
        </div>

    </div>

    <script>
        // 콘솔 로그 비활성화
        console.log = function() {};
        
        let dashboardData = null;
        let clutchData = null;
        let weeklyAnalysisData = null;
        let gameRecordsData = null;
        let futureScheduleData = null;
        let currentSelectedTeam = '전체';
        let currentOpponentFilter = 'all';
        let currentVenueFilter = 'all';
        
        // 승률에 따른 0.5 기준 그라데이션 함수
        function getWinRateClass(winRate) {
            if (typeof winRate === 'string') {
                winRate = parseFloat(winRate);
            }
            
            // 0.5 기준 그라데이션
            if (winRate >= 0.65) {
                return 'positive-very-strong';  // 0.65 이상 - 가장 진한 녹색
            } else if (winRate >= 0.6) {
                return 'positive-strong';       // 0.6~0.65 - 진한 녹색
            } else if (winRate >= 0.55) {
                return 'positive-medium';       // 0.55~0.6 - 보통 녹색
            } else if (winRate > 0.5) {
                return 'positive-light';        // 0.5 초과~0.55 - 연한 녹색
            } else if (winRate === 0.5) {
                return 'neutral-medium';        // 정확히 0.5 - 중립
            } else if (winRate >= 0.45) {
                return 'negative-light';        // 0.45~0.5 - 연한 빨강
            } else if (winRate >= 0.4) {
                return 'negative-medium';       // 0.4~0.45 - 보통 빨강
            } else if (winRate >= 0.35) {
                return 'negative-strong';       // 0.35~0.4 - 진한 빨강
            } else {
                return 'negative-very-strong';  // 0.35 미만 - 가장 진한 빨강
            }
        }

        // 득실차에 따른 5단계 클래스 반환 함수
        function getRunDiffClass(runDiff) {
            if (typeof runDiff === 'string') {
                runDiff = parseInt(runDiff);
            }
            
            if (runDiff >= 100) {
                return 'positive-very-strong';  // 매우 좋음 (+100 이상)
            } else if (runDiff >= 50) {
                return 'positive-strong';        // 좋음 (+50 ~ +99)
            } else if (runDiff >= 20) {
                return 'positive-medium';        // 약간 좋음 (+20 ~ +49)
            } else if (runDiff > 0) {
                return 'positive-light';         // 미세하게 좋음 (+1 ~ +19)
            } else if (runDiff === 0) {
                return 'neutral-medium';         // 균형 (0)
            } else if (runDiff >= -19) {
                return 'negative-light';         // 미세하게 나쁨 (-19 ~ -1)
            } else if (runDiff >= -49) {
                return 'negative-medium';        // 약간 나쁨 (-49 ~ -20)
            } else if (runDiff >= -99) {
                return 'negative-strong';        // 나쁨 (-99 ~ -50)
            } else {
                return 'negative-very-strong';   // 매우 나쁨 (-100 이하)
            }
        }
        
        // CSS 변수를 JavaScript에서 직접 정의 (인라인 스타일 호환성을 위해)
        const colorScheme = {
            positive: {
                bgLight: 'rgba(34, 197, 94, 0.05)',
                bgMedium: 'rgba(34, 197, 94, 0.1)',
                bgStrong: 'rgba(34, 197, 94, 0.15)',
                color: '#059669'
            },
            negative: {
                bgLight: 'rgba(239, 68, 68, 0.05)',
                bgMedium: 'rgba(239, 68, 68, 0.1)',
                bgStrong: 'rgba(239, 68, 68, 0.15)',
                color: '#dc2626'
            },
            neutral: {
                bgLight: 'rgba(255, 193, 7, 0.1)',
                bgMedium: 'rgba(255, 193, 7, 0.2)',
                bgStrong: 'rgba(255, 193, 7, 0.3)',
                color: '#f59e0b'
            },
            default: {
                bg: '#f8f9fa',
                color: '#666'
            }
        };

        // 통합 색상 관리 함수 - 승률에 따라 배경색과 텍스트 색상을 모두 반환
        function getUnifiedCellStyle(winRate) {
            let backgroundColor = colorScheme.default.bg;
            let textColor = colorScheme.default.color;
            
            if (winRate === 0.5) {
                // 정확히 50% 동률인 경우만 - 노란색 배경
                backgroundColor = colorScheme.neutral.bgMedium;
                textColor = colorScheme.neutral.color;
            } else if (winRate > 0.6) {
                backgroundColor = colorScheme.positive.bgStrong;
                textColor = colorScheme.positive.color;
            } else if (winRate > 0.5) {
                backgroundColor = colorScheme.positive.bgMedium;
                textColor = colorScheme.positive.color;
            } else if (winRate < 0.4) {
                backgroundColor = colorScheme.negative.bgStrong;
                textColor = colorScheme.negative.color;
            } else if (winRate < 0.5) {
                backgroundColor = colorScheme.negative.bgMedium;
                textColor = colorScheme.negative.color;
            }
            
            return { backgroundColor, textColor };
        }

        // 팀 로고 매핑 (통합)
        const teamLogos = {
            'LG': 'magic-number/images/teams/lg.png',
            'KIA': 'magic-number/images/teams/kia.png',
            'SSG': 'magic-number/images/teams/ssg.png',
            '두산': 'magic-number/images/teams/doosan.png',
            '삼성': 'magic-number/images/teams/samsung.png',
            'KT': 'magic-number/images/teams/kt.png',
            'NC': 'magic-number/images/teams/nc.png',
            '롯데': 'magic-number/images/teams/lotte.png',
            '키움': 'magic-number/images/teams/kiwoom.png',
            '한화': 'magic-number/images/teams/hanwha.png'
        };

        // 최근 10경기 데이터를 승-패-무 형태로 변환하는 함수
        function formatRecent10(recent10Text) {
            if (!recent10Text || recent10Text === '-') return '-';
            
            // "7승1무2패" 형태를 "7승-2패-1무" 형태로 변환 (승-패-무 순서)
            const wins = recent10Text.match(/(\d+)승/);
            const losses = recent10Text.match(/(\d+)패/);
            const draws = recent10Text.match(/(\d+)무/);
            
            const winsNum = wins ? wins[1] : '0';
            const lossesNum = losses ? losses[1] : '0';
            const drawsNum = draws ? draws[1] : '0';
            
            return `${winsNum}승-${lossesNum}패-${drawsNum}무`;
        }

        // 팀명과 로고를 함께 표시하는 함수 (통합)
        function getTeamWithLogo(teamName, className = 'team-logo-small') {
            const logoPath = teamLogos[teamName];
            if (logoPath) {
                return `<span class="team-name-with-logo">
                    <img src="${logoPath}" 
                         alt="${teamName}" 
                         class="${className}" 
                         style="width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;"
                         onerror="this.style.display='none'; console.warn('로고 로드 실패:', '${teamName}', '${logoPath}');">
                    ${teamName}
                </span>`;
            }
            console.warn('팀 로고 매핑 없음:', teamName);
            return `<span>${teamName}</span>`;
        }

        // ========== 통합된 순위 시스템 (단일 함수) ==========
        
        
        // 실시간 KBO 순위 시스템 (동률 처리 포함)
        function getRankingSystem() {
            if (!dashboardData?.standings) {
                return {
                    teams: [],
                    teamRanks: {},
                    teamsWithRanks: []
                };
            }
            
            // dashboardData.standings는 이미 sortStandingsByWinRateAndHeadToHead()로 정렬됨
            // 그 정렬 순서 그대로 사용하고 displayRank 기준으로 재정렬
            const sortedStandings = [...dashboardData.standings].sort((a, b) => {
                const aRank = a.displayRank || a.rank || 999;
                const bRank = b.displayRank || b.rank || 999;
                return aRank - bRank;
            });
            
            const teams = [];
            const teamRanks = {};
            const teamsWithRanks = [];
            
            sortedStandings.forEach((team, index) => {
                // displayRank가 KBO 동률 처리 결과이므로 그대로 사용
                const displayRank = team.displayRank || team.rank || (index + 1);
                
                teams.push(team.team_name);
                teamRanks[team.team_name] = displayRank;
                teamsWithRanks.push({
                    name: team.team_name,
                    rank: displayRank
                });
            });
            
            return {
                teams,
                teamRanks,  
                teamsWithRanks
            };
        }
        
        

        // 공식 연속 기록 클래스 반환 (종합 순위와 동일)
        function getOfficialStreakClass(teamName) {
            if (!dashboardData || !dashboardData.standings) return '';
            
            const teamData = dashboardData.standings.find(t => t.team_name === teamName);
            if (!teamData || !teamData.current_streak) return '';
            
            if (teamData.current_streak.includes('W')) return 'win-color';
            if (teamData.current_streak.includes('L')) return 'loss-color';
            return '';
        }

        // 공식 연속 기록 표시 텍스트 반환 (종합 순위와 동일)
        function getOfficialStreakDisplay(teamName) {
            if (!dashboardData || !dashboardData.standings) return '-';
            
            const teamData = dashboardData.standings.find(t => t.team_name === teamName);
            if (!teamData || !teamData.current_streak) return '-';
            
            const match = teamData.current_streak.match(/(\d+)([WL])/);
            if (match) {
                const [, count, type] = match;
                if (type === 'W') return `${count}연승`;
                if (type === 'L') return `${count}연패`;
            }
            
            if (teamData.current_streak === 'D' || teamData.current_streak.includes('무')) {
                return '무승부';
            }
            
            return teamData.current_streak;
        }

        // 공식 최장연승 반환 (종합 순위와 동일)
        function getOfficialMaxWinStreak(teamName) {
            if (!dashboardData || !dashboardData.streakAnalysis) return '-';
            
            const streakData = dashboardData.streakAnalysis.find(t => t.team_name === teamName);
            return streakData ? streakData.max_win_streak || 0 : 0;
        }

        // 공식 최장연패 반환 (종합 순위와 동일)
        function getOfficialMaxLoseStreak(teamName) {
            if (!dashboardData || !dashboardData.streakAnalysis) return '-';
            
            const streakData = dashboardData.streakAnalysis.find(t => t.team_name === teamName);
            return streakData ? streakData.max_lose_streak || 0 : 0;
        }

        // 데이터 정보 업데이트 함수 (header + footer)
        function updateDataInfo(data) {
            try {
                // stats-comprehensive.json에서는 updateTime 필드 사용
                const updateTimeField = data?.lastUpdated || data?.updateTime;
                if (updateTimeField) {
                    const lastUpdated = new Date(updateTimeField);
                    const updateTimeText = lastUpdated.toLocaleString('ko-KR', { 
                        year: 'numeric',
                        month: 'numeric', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    }).replace(/\. /g, '. ').replace(/\.$/, '');
                    
                    // 헤더 업데이트
                    const updateInfoElement = document.getElementById('updateInfo');
                    if (updateInfoElement) {
                        updateInfoElement.textContent = `📅 ${updateTimeText} 데이터 사용중`;
                    }
                    
                    // Footer 업데이트
                    const dataInfoElement = document.querySelector('.data-info');
                    if (dataInfoElement) {
                        dataInfoElement.textContent = `${updateTimeText} 데이터 사용중`;
                    }
                } else {
                    console.warn('⚠️ 데이터 정보 업데이트 실패: updateTime/lastUpdated 데이터 없음', data);
                }
            } catch (error) {
                console.error('❌ 데이터 정보 업데이트 실패:', error);
            }
        }
        
        // 승률과 상대전적 기준으로 순위 정렬
        async function sortStandingsByWinRateAndHeadToHead() {
            try {
                // 상대전적 데이터 로드
                let recordsData = null;
                try {
                    const response = await fetch(`magic-number/data/calc-head-to-head.json?v=${Date.now()}`);
                    recordsData = await response.json();
                } catch (error) {
                    console.warn('⚠️ 상대전적 데이터 로드 실패, 승률만으로 정렬:', error);
                }

                // KBO 규정에 따른 순위 정렬
                dashboardData.standings.sort((a, b) => {
                    // 승률을 직접 계산하여 정확한 비교 (무승부 제외)
                    const aWinRate = a.wins / (a.wins + a.losses);
                    const bWinRate = b.wins / (b.wins + b.losses);
                    
                    // 1차: 4자리까지 정확한 승률 비교 (내림차순)
                    const aWinRateRounded = Math.round(aWinRate * 10000) / 10000;
                    const bWinRateRounded = Math.round(bWinRate * 10000) / 10000;
                    if (aWinRateRounded !== bWinRateRounded) {
                        return bWinRateRounded - aWinRateRounded;
                    }
                    
                    // 승률이 같을 때는 공동순위로 처리 (KBO 규정)
                    // 상대전적, 다승, 득실차 비교 없이 팀명 순서만 유지
                    return a.team_name.localeCompare(b.team_name);
                });
                
                
                // 정렬 후 동률 처리하여 순위 재할당
                assignRanksWithTies();
                
            } catch (error) {
                console.error('❌ 순위 정렬 실패:', error);
            }
        }

        // KBO 규정에 따른 순위 할당 (공동 순위 가능)
        function assignRanksWithTies() {
            if (!dashboardData.standings || dashboardData.standings.length === 0) return;
            
            let currentRank = 1;
            
            for (let i = 0; i < dashboardData.standings.length; i++) {
                if (i === 0) {
                    // 첫 번째 팀은 항상 1위
                    dashboardData.standings[i].rank = 1;
                    dashboardData.standings[i].displayRank = 1;
                } else {
                    const currentTeam = dashboardData.standings[i];
                    const previousTeam = dashboardData.standings[i - 1];
                    
                    // 모든 순위 결정 기준이 완전히 같은지 확인
                    const currentWinRate = Math.round((currentTeam.wins / (currentTeam.wins + currentTeam.losses)) * 10000) / 10000;
                    const previousWinRate = Math.round((previousTeam.wins / (previousTeam.wins + previousTeam.losses)) * 10000) / 10000;
                    
                    const currentRunDiff = (currentTeam.runs_scored || 0) - (currentTeam.runs_allowed || 0);
                    const previousRunDiff = (previousTeam.runs_scored || 0) - (previousTeam.runs_allowed || 0);
                    
                    // 승률이 같으면 공동 순위 (KBO 규정)
                    if (currentWinRate === previousWinRate) {
                        // 공동 순위
                        currentTeam.rank = previousTeam.rank;
                        currentTeam.displayRank = previousTeam.displayRank;
                        console.log(`🟡 ${currentTeam.team_name}: 공동 ${currentTeam.displayRank}위 (승률: ${currentWinRate.toFixed(4)}, 다승: ${currentTeam.wins}, 듍실차: ${currentRunDiff})`);
                    } else {
                        // 다른 순위
                        currentRank = i + 1;
                        currentTeam.rank = currentRank;
                        currentTeam.displayRank = currentRank;
                        console.log(`🔵 ${currentTeam.team_name}: ${currentTeam.displayRank}위 (승률: ${currentWinRate.toFixed(4)}, 다승: ${currentTeam.wins}, 듍실차: ${currentRunDiff})`);
                    }
                }
            }
            
        }

        // 데이터 로드
        async function loadDashboardData() {
            try {
                // 캐시 강제 삭제를 위한 fetch 옵션 추가
                const response = await fetch(`magic-number/data/stats-comprehensive.json?v=${Date.now()}`, {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                dashboardData = await response.json();
                
                // stats-comprehensive.json에서 피타고리안 운 지수 계산 (우선 실행)
                if (dashboardData.standings) {
                    dashboardData.standings.forEach(team => {
                        // stats-comprehensive.json에서 득실점 데이터를 사용해 피타고리안 계산
                        const runsScored = team.runs_scored || 0;
                        const runsAllowed = team.runs_allowed || 0;
                        
                        if (runsScored > 0 && runsAllowed > 0) {
                            // 피타고리안 승률 계산: RS² / (RS² + RA²)
                            const pythagoreanWinRate = (runsScored * runsScored) / (runsScored * runsScored + runsAllowed * runsAllowed);
                            const actualWinRate = parseFloat(team.win_rate) || 0;
                            const luckIndex = actualWinRate - pythagoreanWinRate;
                            
                            // 데이터 추가
                            team.runsScored = runsScored;
                            team.runsAllowed = runsAllowed;
                            team.runDiff = team.run_differential || (runsScored - runsAllowed);
                            team.pythagoreanWinRate = pythagoreanWinRate;
                            team.luckIndex = luckIndex;
                            
                            // 운 상태 계산
                            if (luckIndex >= 0.05) team.luckRating = '매우 좋음';
                            else if (luckIndex >= 0.03) team.luckRating = '좋음';
                            else if (luckIndex >= 0.01) team.luckRating = '약간 좋음';
                            else if (luckIndex >= -0.01) team.luckRating = '평균적';
                            else if (luckIndex >= -0.03) team.luckRating = '약간 나쁨';
                            else if (luckIndex >= -0.05) team.luckRating = '나쁨';
                            else team.luckRating = '매우 나쁨';
                        }
                    });
                }
                
                // 홈/원정 승률 계산 (stats-comprehensive.json에서 이미 제공됨)
                if (dashboardData.standings) {
                    dashboardData.standings.forEach(team => {
                        // 홈/원정 승률 계산
                        const homeWins = team.homeWins || 0;
                        const homeLosses = team.homeLosses || 0;
                        const awayWins = team.awayWins || 0;
                        const awayLosses = team.awayLosses || 0;

                        team.homeWinRate = (homeWins + homeLosses) > 0 ? homeWins / (homeWins + homeLosses) : 0;
                        team.awayWinRate = (awayWins + awayLosses) > 0 ? awayWins / (awayWins + awayLosses) : 0;
                    });
                }
                console.log('✅ 통합된 stats-comprehensive.json 사용 - 별도 병합 불필요');
                
                // 승률과 상대전적 기준으로 순위 정렬
                await sortStandingsByWinRateAndHeadToHead();
                
                
                await renderDashboard();
                
                // KBO 규정 순위 적용 후 4개 테이블 렌더링
                renderWeeklyTable();
                renderGameByGameTable();
                renderTeamDetailedRecords();
                
                // 위닝/루징 시리즈 분석도 순위 정렬 후 로드
                loadSeriesAnalysisData().catch(error => {
                    console.error('시리즈 분석 데이터 로드 실패:', error);
                });
                
                // 데이터 정보 업데이트 (renderDashboard 호출 후)
                updateDataInfo(dashboardData);
                return Promise.resolve();
            } catch (error) {
                console.error('❌ 데이터 로드 실패:', error);
                const updateInfoElement = document.getElementById('updateInfo');
                if (updateInfoElement) {
                    updateInfoElement.textContent = '❌ 데이터 로드 실패';
                }
                return Promise.reject(error);
            }
        }

        // clean.txt에서 미래 경기 일정 데이터 로드
        async function loadFutureScheduleData() {
            try {
                console.log('📅 clean.txt에서 미래 경기 일정 로드 중...');

                const response = await fetch(`magic-number/data/2025-season-data-clean.txt?v=${Date.now()}`, {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                if (!response.ok) {
                    throw new Error(`clean.txt 로드 실패: HTTP ${response.status}`);
                }

                const text = await response.text();
                futureScheduleData = parseCleanTxtForFutureGames(text);

                console.log(`✅ 미래 경기 ${futureScheduleData.length}경기 로드 완료`);

            } catch (error) {
                console.error('❌ 미래 경기 일정 로드 실패:', error);
                futureScheduleData = [];
            }
        }

        // clean.txt에서 미래 경기 파싱
        function parseCleanTxtForFutureGames(text) {
            const lines = text.split('\n');
            const futureGames = [];
            let currentDate = null;

            for (const line of lines) {
                const trimmedLine = line.trim();

                // 날짜 라인 체크 (YYYY-MM-DD (요일) 형식 또는 기존 YYYY-MM-DD 형식)
                if (/^\d{4}-\d{2}-\d{2}(\s*\([월화수목금토일]\))?$/.test(trimmedLine)) {
                    currentDate = trimmedLine.replace(/\s*\([월화수목금토일]\)/, ''); // 요일 정보 제거
                } else if (trimmedLine && currentDate) {
                    // 새로운 형식 파싱: "시간 상태 구장 홈팀 어웨이팀 점수 방송사 구분"
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 7) { // 최소 7개 필드 (방송사 없어도 됨)
                        const [time, state, stadium, homeTeam, awayTeam, scoreOrStatus, ...remainingParts] = parts;

                        // 페넌트레이스가 포함된 경우 찾기
                        const categoryIndex = remainingParts.findIndex(part => part === '페넌트레이스');

                        if (categoryIndex >= 0) {
                            // 방송사는 scoreOrStatus 다음부터 페넌트레이스 전까지
                            const broadcastParts = remainingParts.slice(0, categoryIndex);
                            const broadcast = broadcastParts.join(' ').trim() || '';
                            const category = remainingParts.slice(categoryIndex).join(' ');

                            // 미래 경기 조건: 페넌트레이스 + 경기전 상태
                            if (state === '경기전' && scoreOrStatus === '경기전') {
                                futureGames.push({
                                    date: currentDate,
                                    time: time,
                                    homeTeam: homeTeam,
                                    awayTeam: awayTeam,
                                    stadium: stadium,
                                    broadcast: broadcast,
                                    state: state,
                                    category: category
                                });
                            }
                        }
                    }
                }
            }

            return futureGames;
        }


        // 주차별 분석 데이터 로드
        async function loadWeeklyAnalysisData() {
            try {
                
                const [weeklyResponse, recordsResponse] = await Promise.all([
                    fetch(`magic-number/data/analysis-weekly.json?v=${Date.now()}`),
                    fetch(`magic-number/data/raw-game-records.json?v=${Date.now()}`)
                ]);
                
                
                if (!weeklyResponse.ok) {
                    throw new Error(`주차별 데이터 HTTP ${weeklyResponse.status}: ${weeklyResponse.statusText}`);
                }
                if (!recordsResponse.ok) {
                    throw new Error(`게임별 데이터 HTTP ${recordsResponse.status}: ${recordsResponse.statusText}`);
                }
                
                weeklyAnalysisData = await weeklyResponse.json();
                gameRecordsData = await recordsResponse.json();
                
                
                // 연승/연패 기록 분석 초기화 (gameRecordsData 로드 직후)
                try {
                    if (gameRecordsData) {
                        console.log('renderDashboard: 연승/연패 분석 실행');
                        analyzeFromGameRecordsData();
                    } else {
                        console.log('renderDashboard: gameRecordsData 없음');
                    }
                } catch (e) {
                    console.error('연승/연패 분석 오류:', e);
                }
                
                // 미래 경기 일정 로드
                await loadFutureScheduleData();
                
                
            } catch (error) {
                console.error('❌ 주차별 분석 데이터 로드 실패:', error);
                document.getElementById('weeklyStatsContent').innerHTML = 
                    `<div style="text-align: center; padding: 40px; color: #e53e3e;">❌ 주차별 데이터 로드 실패: ${error.message}</div>`;
                document.getElementById('gameRecordsContent').innerHTML = 
                    `<div style="text-align: center; padding: 40px; color: #e53e3e;">❌ 게임별 데이터 로드 실패: ${error.message}</div>`;
                document.getElementById('teamDetailedRecordsContent').innerHTML = 
                    `<div style="text-align: center; padding: 40px; color: #e53e3e;">❌ 팀별 상세 데이터 로드 실패: ${error.message}</div>`;
            }
        }

        // 대시보드 렌더링
        async function renderDashboard() {
            if (!dashboardData) {
                console.error('❌ dashboardData가 없습니다');
                return;
            }

            
            // 업데이트 정보는 updateDataInfo 함수에서 처리됨

            try { renderFullStandings(); } catch(e) { console.error('renderFullStandings 오류:', e); }
            
            try { renderPythagoreanFullAnalysis(); } catch(e) { console.error('renderPythagoreanFullAnalysis 오류:', e); }
            
            try { 
                await renderClutchFullAnalysis(); 
                // 클러치 데이터 로드 후 전체 순위표 다시 렌더링
                renderFullStandings();
            } catch(e) { 
                console.error('renderClutchFullAnalysis 오류:', e); 
            }
            
            try { await renderHomeAwayFullAnalysis(); } catch(e) { console.error('renderHomeAwayFullAnalysis 오류:', e); }
            
            try { 
                if (typeof renderHeadToHeadMatrix === 'function') {
                    renderHeadToHeadMatrix(); 
                }
            } catch(e) { 
                console.error('renderHeadToHeadMatrix 오류:', e); 
                // 에러가 발생해도 계속 진행
            }

            try { 
                if (typeof renderRemainingGamesMatrix === 'function') {
                    renderRemainingGamesMatrix(); 
                }
            } catch(e) { 
                console.error('renderRemainingGamesMatrix 오류:', e); 
                // 에러가 발생해도 계속 진행
            }
            
            // 정렬 함수들을 render 함수들 호출 이전에 정의 (onclick 이벤트가 작동하도록)
            
            // 월별 승률 순 정렬 함수 (3단계: 내림차순 → 오름차순 → 원래순서)
            let monthlyRateSortState = {}; // 월별 정렬 상태
            let originalMonthlyTeamOrder = []; // 월별 원래 팀 순서 저장
            
            window.sortMonthlyByRate = function(monthNum) {
                const tbody = document.querySelector('#monthlyTable tbody');
                if (!tbody) return;
                
                // 현재 상태 확인 및 다음 상태로 전환
                const currentState = monthlyRateSortState[monthNum] || 0;
                const nextState = (currentState + 1) % 3; // 0: 내림차순, 1: 오름차순, 2: 원래순서
                
                // 다른 월 상태만 초기화 (현재 월 제외)
                Object.keys(monthlyRateSortState).forEach(key => {
                    if (key != monthNum) {
                        delete monthlyRateSortState[key];
                    }
                });
                monthlyRateSortState[monthNum] = nextState;
                
                console.log('월별 - 현재 상태:', currentState, '다음 상태:', nextState);
                
                const rows = Array.from(tbody.querySelectorAll('tr'));
                
                // 평균 행 제외하고 월 행만 정렬
                const monthRows = rows.filter(row => {
                    const firstCell = row.querySelector('td');
                    return firstCell && !firstCell.textContent.includes('평균');
                });
                
                const avgRows = rows.filter(row => {
                    const firstCell = row.querySelector('td');
                    return firstCell && firstCell.textContent.includes('평균');
                });
                
                // 해당 월의 행 찾기
                const targetRowIndex = monthRows.findIndex(row => {
                    const firstCell = row.querySelector('td');
                    const monthNames = ['3월', '4월', '5월', '6월', '7월', '8월'];
                    const monthName = monthNames[monthNum - 3]; // monthNum은 3부터 시작
                    return firstCell && firstCell.textContent.trim() === monthName;
                });
                
                if (targetRowIndex === -1) return;
                
                // 원래 순서 저장 (첫 번째 호출 시에만)
                if (originalMonthlyTeamOrder.length === 0) {
                    const thead = document.querySelector('#monthlyTable thead');
                    if (thead) {
                        const headerRow = thead.querySelector('tr');
                        if (headerRow) {
                            const teamHeaders = Array.from(headerRow.querySelectorAll('th')).slice(1);
                            // 팀 이름으로 원래 순서 저장
                            originalMonthlyTeamOrder = teamHeaders.map((th, index) => ({
                                index: index,
                                teamName: th.textContent.trim()
                            }));
                            console.log('월별 - 원래 팀 순서 저장됨 (팀 이름):', originalMonthlyTeamOrder);
                        }
                    }
                }
                
                let teamRates = [];
                
                if (nextState === 2) {
                    // 원래 순서로 복원
                    console.log('월별 - 원래 순서로 복원 중:', originalMonthlyTeamOrder);
                    teamRates = originalMonthlyTeamOrder.map((item, index) => ({
                        rate: 0, // 원래 순서에서는 승률 불필요
                        originalIndex: item.index
                    }));
                } else {
                    // 해당 월의 팀별 승률 데이터 수집
                    const targetRow = monthRows[targetRowIndex];
                    const cells = Array.from(targetRow.querySelectorAll('td')).slice(1); // 첫 번째 월 라벨 제외
                    
                    cells.forEach((cell, index) => {
                        const text = cell.textContent || cell.innerText || '';
                        const rateMatch = text.match(/\(([0-9.]+)\)/); // (승률) 추출
                        if (rateMatch) {
                            teamRates.push({
                                rate: parseFloat(rateMatch[1]),
                                index: index + 1, // +1은 첫 번째 월 라벨 컬럼 때문
                                originalIndex: index
                            });
                        } else {
                            // 데이터가 없는 경우 -1로 처리 (맨 뒤로)
                            teamRates.push({
                                rate: -1,
                                index: index + 1,
                                originalIndex: index
                            });
                        }
                    });
                    
                    // 승률 순으로 정렬
                    teamRates.sort((a, b) => {
                        if (a.rate === -1 && b.rate === -1) return 0;
                        if (a.rate === -1) return 1;
                        if (b.rate === -1) return -1;
                        
                        if (nextState === 0) {
                            return b.rate - a.rate; // 내림차순 (높은 승률 먼저)
                        } else {
                            return a.rate - b.rate; // 오름차순 (낮은 승률 먼저)
                        }
                    });
                }
                
                // 더 안정적인 DOM 조작 방식으로 전체 테이블 재구성
                console.log('월별 DOM 재구성 시작, teamRates:', teamRates);
                
                // 헤더 재배열
                const thead = document.querySelector('#monthlyTable thead');
                if (thead) {
                    const headerRow = thead.querySelector('tr');
                    if (headerRow) {
                        const headerCells = Array.from(headerRow.querySelectorAll('th'));
                        const monthHeader = headerCells[0].outerHTML; // 월 헤더
                        const teamHeaders = headerCells.slice(1);
                        
                        let newHeaderHtml = '<tr>' + monthHeader;
                        teamRates.forEach(item => {
                            newHeaderHtml += teamHeaders[item.originalIndex].outerHTML;
                        });
                        newHeaderHtml += '</tr>';
                        
                        thead.innerHTML = newHeaderHtml;
                    }
                }
                
                // 바디 재배열 (월 행과 평균 행 모두)
                let newBodyHtml = '';
                
                // 월 행들 먼저 처리
                monthRows.forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const monthLabel = cells[0].outerHTML;
                    const dataCells = cells.slice(1);
                    
                    let newRowHtml = '<tr>' + monthLabel;
                    teamRates.forEach(item => {
                        newRowHtml += dataCells[item.originalIndex].outerHTML;
                    });
                    newRowHtml += '</tr>';
                    
                    newBodyHtml += newRowHtml;
                });
                
                // 평균 행들 처리
                avgRows.forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const avgLabel = cells[0].outerHTML;
                    const dataCells = cells.slice(1);
                    
                    let newRowHtml = '<tr>' + avgLabel;
                    teamRates.forEach(item => {
                        newRowHtml += dataCells[item.originalIndex].outerHTML;
                    });
                    newRowHtml += '</tr>';
                    
                    newBodyHtml += newRowHtml;
                });
                
                tbody.innerHTML = newBodyHtml;
                
                // 클릭 이벤트 재바인딩 - 월별 (더 안정적인 방식)
                tbody.querySelectorAll('td.month-label').forEach(cell => {
                    // onclick 속성에서 monthNum 추출
                    const onclickAttr = cell.getAttribute('onclick');
                    if (onclickAttr) {
                        const match = onclickAttr.match(/sortMonthlyByRate\((\d+)\)/);
                        if (match) {
                            const monthNum = parseInt(match[1]);
                            // 새로운 클릭 이벤트 추가
                            cell.addEventListener('click', (e) => {
                                e.preventDefault();
                                sortMonthlyByRate(monthNum);
                            });
                        }
                    }
                });
                
                console.log('월별 DOM 재구성 및 이벤트 재바인딩 완료!');
            };
            
            // 요일별 승률 순 정렬 함수 (3단계: 내림차순 → 오름차순 → 원래순서)
            let weekdayRateSortState = {}; // 요일별 정렬 상태  
            let originalWeekdayTeamOrder = []; // 원래 팀 순서 저장
            
            window.sortWeekdayByRate = function(dayKey) {
                const tbody = document.querySelector('#weekdayTable tbody');
                if (!tbody) return;
                
                // 현재 상태 확인 및 다음 상태로 전환
                const currentState = weekdayRateSortState[dayKey] || 0;
                const nextState = (currentState + 1) % 3;
                
                // 다른 요일 상태만 초기화 (현재 요일 제외)
                Object.keys(weekdayRateSortState).forEach(key => {
                    if (key !== dayKey) {
                        delete weekdayRateSortState[key];
                    }
                });
                weekdayRateSortState[dayKey] = nextState;
                
                console.log('요일별 - 현재 상태:', currentState, '다음 상태:', nextState);
                
                const rows = Array.from(tbody.querySelectorAll('tr'));
                
                // 요약 행 제외하고 요일 행만 정렬
                const dayRows = rows.filter(row => {
                    const firstCell = row.querySelector('td');
                    return firstCell && !firstCell.textContent.includes('요약');
                });
                
                const summaryRows = rows.filter(row => {
                    const firstCell = row.querySelector('td');
                    return firstCell && firstCell.textContent.includes('요약');
                });
                
                // 해당 요일의 행 찾기
                const targetRowIndex = dayRows.findIndex(row => {
                    const firstCell = row.querySelector('td');
                    // dayKey가 '월', '화' 등으로 들어옴
                    const dayNames = { '월': '월요일', '화': '화요일', '수': '수요일', '목': '목요일', '금': '금요일', '토': '토요일', '일': '일요일' };
                    const dayName = dayNames[dayKey];
                    return firstCell && firstCell.textContent.trim() === dayName;
                });
                
                if (targetRowIndex === -1) return;
                
                // 원래 순서 저장 (첫 번째 호출 시에만)
                if (originalWeekdayTeamOrder.length === 0) {
                    const thead = document.querySelector('#weekdayTable thead');
                    if (thead) {
                        const headerRow = thead.querySelector('tr');
                        if (headerRow) {
                            const teamHeaders = Array.from(headerRow.querySelectorAll('th')).slice(1);
                            originalWeekdayTeamOrder = teamHeaders.map((th, index) => index);
                            console.log('요일별 - 원래 팀 순서 저장됨:', originalWeekdayTeamOrder);
                        }
                    }
                }
                
                let teamRates = [];
                
                if (nextState === 2) {
                    // 원래 순서로 복원
                    console.log('요일별 - 원래 순서로 복원 중:', originalWeekdayTeamOrder);
                    teamRates = originalWeekdayTeamOrder.map((item, index) => ({
                        rate: 0,
                        originalIndex: item.index
                    }));
                } else {
                    // 해당 요일의 팀별 승률 데이터 수집
                    const targetRow = dayRows[targetRowIndex];
                    const cells = Array.from(targetRow.querySelectorAll('td')).slice(1); // 첫 번째 요일 라벨 제외
                    
                    cells.forEach((cell, index) => {
                        const text = cell.textContent || cell.innerText || '';
                        const rateMatch = text.match(/\(([0-9.]+)\)/);
                        if (rateMatch) {
                            teamRates.push({
                                rate: parseFloat(rateMatch[1]),
                                originalIndex: index
                            });
                        } else {
                            teamRates.push({
                                rate: -1,
                                originalIndex: index
                            });
                        }
                    });
                    
                    // 승률 순으로 정렬
                    teamRates.sort((a, b) => {
                        if (a.rate === -1 && b.rate === -1) return 0;
                        if (a.rate === -1) return 1;
                        if (b.rate === -1) return -1;
                        
                        if (nextState === 0) {
                            return b.rate - a.rate; // 내림차순
                        } else {
                            return a.rate - b.rate; // 오름차순
                        }
                    });
                }
                
                // 헤더 재배열
                const thead = document.querySelector('#weekdayTable thead');
                if (thead) {
                    const headerRow = thead.querySelector('tr');
                    if (headerRow) {
                        const headerCells = Array.from(headerRow.querySelectorAll('th'));
                        const dayHeader = headerCells[0].outerHTML;
                        const teamHeaders = headerCells.slice(1);
                        
                        let newHeaderHtml = '<tr>' + dayHeader;
                        teamRates.forEach(item => {
                            newHeaderHtml += teamHeaders[item.originalIndex].outerHTML;
                        });
                        newHeaderHtml += '</tr>';
                        
                        thead.innerHTML = newHeaderHtml;
                    }
                }
                
                // 바디 재배열
                let newBodyHtml = '';
                
                dayRows.forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const dayLabel = cells[0].outerHTML;
                    const dataCells = cells.slice(1);
                    
                    let newRowHtml = '<tr>' + dayLabel;
                    teamRates.forEach(item => {
                        newRowHtml += dataCells[item.originalIndex].outerHTML;
                    });
                    newRowHtml += '</tr>';
                    
                    newBodyHtml += newRowHtml;
                });
                
                summaryRows.forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const summaryLabel = cells[0].outerHTML;
                    const dataCells = cells.slice(1);
                    
                    let newRowHtml = '<tr>' + summaryLabel;
                    teamRates.forEach(item => {
                        newRowHtml += dataCells[item.originalIndex].outerHTML;
                    });
                    newRowHtml += '</tr>';
                    
                    newBodyHtml += newRowHtml;
                });
                
                tbody.innerHTML = newBodyHtml;
                
                // 클릭 이벤트 재바인딩 - 요일별 (더 안정적인 방식)
                tbody.querySelectorAll('td.day-label').forEach(cell => {
                    // onclick 속성에서 dayKey 추출
                    const onclickAttr = cell.getAttribute('onclick');
                    if (onclickAttr) {
                        const match = onclickAttr.match(/sortWeekdayByRate\('([^']+)'\)/);
                        if (match) {
                            const dayKey = match[1];
                            // 새로운 클릭 이벤트 추가
                            cell.addEventListener('click', (e) => {
                                e.preventDefault();
                                sortWeekdayByRate(dayKey);
                            });
                        }
                    }
                });
                
                console.log('요일별 DOM 재구성 및 이벤트 재바인딩 완료');
            };
            
            // 경기장별 승률 순 정렬 함수 (3단계: 내림차순 → 오름차순 → 원래순서)
            let stadiumRateSortState = {}; // 경기장별 정렬 상태
            let originalStadiumTeamOrder = []; // 원래 팀 순서 저장
            
            window.sortStadiumByRate = function(stadiumName) {
                const tbody = document.querySelector('#stadiumTable tbody');
                if (!tbody) return;
                
                // 현재 상태 확인 및 다음 상태로 전환
                const currentState = stadiumRateSortState[stadiumName] || 0;
                const nextState = (currentState + 1) % 3;
                
                // 다른 경기장 상태만 초기화 (현재 경기장 제외)
                Object.keys(stadiumRateSortState).forEach(key => {
                    if (key !== stadiumName) {
                        delete stadiumRateSortState[key];
                    }
                });
                stadiumRateSortState[stadiumName] = nextState;
                
                console.log('경기장별 - 현재 상태:', currentState, '다음 상태:', nextState);
                
                const rows = Array.from(tbody.querySelectorAll('tr'));
                
                // 요약 행 제외하고 경기장 행만 정렬
                const stadiumRows = rows.filter(row => {
                    const firstCell = row.querySelector('td');
                    return firstCell && !firstCell.textContent.includes('요약');
                });
                
                const summaryRows = rows.filter(row => {
                    const firstCell = row.querySelector('td');
                    return firstCell && firstCell.textContent.includes('요약');
                });
                
                // 해당 경기장의 행 찾기
                const targetRowIndex = stadiumRows.findIndex(row => {
                    const firstCell = row.querySelector('td');
                    if (!firstCell) return false;
                    
                    // 경기장명이 div 안에 있는 경우
                    const stadiumNameDiv = firstCell.querySelector('div');
                    if (stadiumNameDiv) {
                        return stadiumNameDiv.textContent.trim() === stadiumName;
                    }
                    
                    // fallback: 전체 텍스트 비교
                    return firstCell.textContent.trim().includes(stadiumName);
                });
                
                if (targetRowIndex === -1) return;
                
                // 원래 순서 저장 (첫 번째 호출 시에만)
                if (originalStadiumTeamOrder.length === 0) {
                    const thead = document.querySelector('#stadiumTable thead');
                    if (thead) {
                        const headerRow = thead.querySelector('tr');
                        if (headerRow) {
                            const teamHeaders = Array.from(headerRow.querySelectorAll('th')).slice(1);
                            originalStadiumTeamOrder = teamHeaders.map((th, index) => index);
                            console.log('경기장별 - 원래 팀 순서 저장됨:', originalStadiumTeamOrder);
                        }
                    }
                }
                
                let teamRates = [];
                
                if (nextState === 2) {
                    // 원래 순서로 복원
                    console.log('경기장별 - 원래 순서로 복원 중:', originalStadiumTeamOrder);
                    teamRates = originalStadiumTeamOrder.map((item, index) => ({
                        rate: 0,
                        originalIndex: item.index
                    }));
                } else {
                    // 해당 경기장의 팀별 승률 데이터 수집
                    const targetRow = stadiumRows[targetRowIndex];
                    const cells = Array.from(targetRow.querySelectorAll('td')).slice(1); // 첫 번째 경기장 라벨 제외
                    
                    cells.forEach((cell, index) => {
                        const text = cell.textContent || cell.innerText || '';
                        const rateMatch = text.match(/\(([0-9.]+)\)/);
                        if (rateMatch) {
                            teamRates.push({
                                rate: parseFloat(rateMatch[1]),
                                originalIndex: index
                            });
                        } else {
                            teamRates.push({
                                rate: -1,
                                originalIndex: index
                            });
                        }
                    });
                    
                    // 승률 순으로 정렬
                    teamRates.sort((a, b) => {
                        if (a.rate === -1 && b.rate === -1) return 0;
                        if (a.rate === -1) return 1;
                        if (b.rate === -1) return -1;
                        
                        if (nextState === 0) {
                            return b.rate - a.rate; // 내림차순
                        } else {
                            return a.rate - b.rate; // 오름차순
                        }
                    });
                }
                
                // 헤더 재배열
                const thead = document.querySelector('#stadiumTable thead');
                if (thead) {
                    const headerRow = thead.querySelector('tr');
                    if (headerRow) {
                        const headerCells = Array.from(headerRow.querySelectorAll('th'));
                        const stadiumHeader = headerCells[0].outerHTML;
                        const teamHeaders = headerCells.slice(1);
                        
                        let newHeaderHtml = '<tr>' + stadiumHeader;
                        teamRates.forEach(item => {
                            newHeaderHtml += teamHeaders[item.originalIndex].outerHTML;
                        });
                        newHeaderHtml += '</tr>';
                        
                        thead.innerHTML = newHeaderHtml;
                    }
                }
                
                // 바디 재배열
                let newBodyHtml = '';
                
                stadiumRows.forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const stadiumLabel = cells[0].outerHTML;
                    const dataCells = cells.slice(1);
                    
                    let newRowHtml = '<tr>' + stadiumLabel;
                    teamRates.forEach(item => {
                        newRowHtml += dataCells[item.originalIndex].outerHTML;
                    });
                    newRowHtml += '</tr>';
                    
                    newBodyHtml += newRowHtml;
                });
                
                summaryRows.forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const summaryLabel = cells[0].outerHTML;
                    const dataCells = cells.slice(1);
                    
                    let newRowHtml = '<tr>' + summaryLabel;
                    teamRates.forEach(item => {
                        newRowHtml += dataCells[item.originalIndex].outerHTML;
                    });
                    newRowHtml += '</tr>';
                    
                    newBodyHtml += newRowHtml;
                });
                
                tbody.innerHTML = newBodyHtml;
                
                // 클릭 이벤트 재바인딩 - 경기장별 (더 안정적인 방식)
                tbody.querySelectorAll('td[onclick*="sortStadiumByRate"]').forEach(cell => {
                    // onclick 속성에서 stadiumName 추출
                    const onclickAttr = cell.getAttribute('onclick');
                    if (onclickAttr) {
                        const match = onclickAttr.match(/sortStadiumByRate\('([^']+)'\)/);
                        if (match) {
                            const stadiumName = match[1];
                            // 새로운 클릭 이벤트 추가
                            cell.addEventListener('click', (e) => {
                                e.preventDefault();
                                sortStadiumByRate(stadiumName);
                            });
                        }
                    }
                });
                
                console.log('경기장별 DOM 재구성 및 이벤트 재바인딩 완료');
            };
            
            try { renderMonthlyFullAnalysis(); } catch(e) { console.error('renderMonthlyFullAnalysis 오류:', e); }
            
            try { renderWeekdayFullAnalysis(); } catch(e) { console.error('renderWeekdayFullAnalysis 오류:', e); }
            
            try { renderStadiumFullAnalysis(); } catch(e) { console.error('renderStadiumFullAnalysis 오류:', e); }
            
        }

        // 팀 변경
        function changeSelectedTeam(team) {
            currentSelectedTeam = team;
            renderTeamDetailedRecords();
        }

        // 주차별 성적 테이블 렌더링 (종합 순위와 동일한 방식)
        function renderWeeklyTable() {
            if (!weeklyAnalysisData || !weeklyAnalysisData.weeklyAnalysis) {
                console.error('주차별 데이터가 올바르지 않습니다');
                return;
            }
            
            if (!dashboardData?.standings) return;

            // 종합 순위 기준 팀 순서 사용 (정렬된 순서)
            const rankingSystem = getRankingSystem();
            const teams = rankingSystem.teams;
            const maxWeeks = weeklyAnalysisData.currentWeek || 21;

            let html = `
            <div class="table-scroll-wrapper">
                <table class="weekly-table">
                    <thead>
                        <tr>
                            <th style="min-width: 50px; font-size: var(--font-sm); cursor: pointer;" onclick="sortWeeklyByWeek()">주차</th>
                            <th style="min-width: 120px;">기간</th>
                            ${teams.map(team => `<th class="team-header sortable-team" style="cursor: pointer;" data-team="${team}">${getTeamWithLogo(team, 'team-logo-small')}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>`;

            for (let week = 1; week <= maxWeeks; week++) {
                let weekStart, weekEnd, startStr, endStr;
                
                if (week === 1) {
                    // 1주차는 특별히 3월 22일, 23일 (토일)
                    weekStart = new Date('2025-03-22');
                    weekEnd = new Date('2025-03-23');
                } else {
                    // 2주차부터는 화요일 시작으로 계산
                    const baseDate = new Date('2025-03-25'); // 3월 25일 화요일부터 2주차 시작
                    weekStart = new Date(baseDate);
                    weekStart.setDate(baseDate.getDate() + (week - 2) * 7);
                    weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 6);
                }

                startStr = weekStart.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' });
                endStr = weekEnd.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' });
                
                // 올스타 브레이크 주차 확인 (17주차)
                const isAllStarBreak = week === 17;
                const weekCellContent = isAllStarBreak ? `${week}주차 ⭐` : `${week}주차`;
                
                html += `
                    <tr>
                        <td class="week-cell" style="max-width: 50px; width: 50px; padding: 6px 2px; text-align: center;">${weekCellContent}</td>
                        <td class="date-cell" style="max-width: 120px; width: 120px; font-size: var(--font-xs); padding: 6px 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${startStr} ~ ${endStr}</td>
                        ${teams.map(team => {
                            const teamAnalysis = weeklyAnalysisData.weeklyAnalysis[team];
                            const weekStats = teamAnalysis?.weeklyStats?.[week] || { 
                                games: 0, wins: 0, losses: 0, draws: 0, winRate: '0.0' 
                            };
                            // weekStats.winRate가 퍼센테이지인지 소수점인지 확인 후 적절히 변환
                            const winRateValue = parseFloat(weekStats.winRate);
                            const normalizedWinRate = winRateValue > 1 ? winRateValue / 100 : winRateValue;
                            const winRateClass = getWinRateClass(normalizedWinRate);
                            const totalGames = weekStats.wins + weekStats.losses + weekStats.draws;
                            
                            // 경기가 없는 경우 특별 처리
                            if (totalGames === 0) {
                                return `<td style="color: #999; font-size: var(--font-sm); padding: 8px; text-align: center;">-</td>`;
                            }
                            
                            return `
                                <td class="${winRateClass}" style="font-size: var(--font-sm); padding: 6px; line-height: 1.2; text-align: center;">
                                    <div style="font-weight: var(--font-weight-semibold); margin-bottom: 1px;">${weekStats.wins}-${weekStats.losses}-${weekStats.draws} (<span class="baseball-winrate-inline">${normalizedWinRate.toFixed(3)}</span>)</div>
                                    <div style="font-size: var(--font-xs); color: #666; margin-top: 1px;">${totalGames}경기</div>
                                </td>
                            `;
                        }).join('')}
                    </tr>`;
            }

            html += `</tbody></table></div>
            
            <!-- 설명 섹션 -->
            <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📅 주차별 성적 설명</div>
                <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                    <div style="margin-bottom: 6px;"><strong>올스타전:</strong> <span style="color: #ff9800; font-weight: var(--font-weight-semibold);">⭐ 7월 12일 (17주차)</span> - 1주차: 3월 22일~23일 개막 시리즈, 2주차 이후: 화요일~월요일 주간제</div>
                    <div><strong>승률 색상:</strong> <span style="background: rgba(34, 197, 94, 0.1); padding: 2px 6px; border-radius: 3px;">0.500 초과 (좋음)</span> <span style="background: rgba(234, 179, 8, 0.1); padding: 2px 6px; border-radius: 3px;">0.500 (보통)</span> <span style="background: rgba(239, 68, 68, 0.1); padding: 2px 6px; border-radius: 3px;">0.500 미만 (나쁨)</span></div>
                </div>
            </div>
            </tbody>
            </table>
            </div>`;
            
            document.getElementById('weeklyStatsContent').innerHTML = html;
            
            // 최신 주차로 스크롤 (하단으로)
            setTimeout(() => {
                const scrollContainer = document.querySelector('#weeklyStatsContent .table-scroll-wrapper');
                if (scrollContainer) {
                    scrollContainer.scrollTop = scrollContainer.scrollHeight;
                }
            }, 100);
            
            // 팀명 헤더에 클릭 이벤트 리스너 추가
            setTimeout(() => {
                const teamHeaders = document.querySelectorAll('.weekly-table .team-header[data-team]');
                teamHeaders.forEach(header => {
                    const teamName = header.getAttribute('data-team');
                    header.addEventListener('click', function() {
                        sortWeeklyTableByTeam(teamName);
                    });
                });
            }, 100);
        }

        // 주차별 성적 팀별 정렬 함수
        let weeklyTeamSortState = {}; // 팀별 정렬 상태 (0: 기본, 1: 오름차순, 2: 내림차순)
        
        window.sortWeeklyTableByTeam = function(teamName) {
            
            // 현재 팀의 정렬 상태 확인
            const currentState = weeklyTeamSortState[teamName] || 0;
            
            // 모든 정렬 상태 초기화
            weeklyTeamSortState = {};
            
            // 다음 정렬 상태로 변경
            const nextState = (currentState + 1) % 3;
            weeklyTeamSortState[teamName] = nextState;
            
            const tbody = document.querySelector('.weekly-table tbody');
            if (!tbody) return;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            if (nextState === 0) {
                // 기본 순서 (주차 순)
                rows.sort((a, b) => {
                    const weekA = parseInt(a.cells[0].textContent);
                    const weekB = parseInt(b.cells[0].textContent);
                    return weekA - weekB;
                });
            } else {
                // 해당 팀 컬럼 찾기 - 더 정확한 방법 사용
                const allHeaders = document.querySelectorAll('.weekly-table thead th');
                let teamIndex = -1;
                
                // 헤더에서 팀 이름을 포함한 열 찾기
                allHeaders.forEach((header, index) => {
                    const headerText = header.textContent || header.innerText;
                    if (headerText.includes(teamName) || (header.onclick && header.onclick.toString().includes(teamName))) {
                        teamIndex = index;
                    }
                });
                
                if (teamIndex !== -1) {
                    rows.sort((a, b) => {
                        const cellA = a.cells[teamIndex];
                        const cellB = b.cells[teamIndex];
                        
                        if (!cellA || !cellB) return 0;
                        
                        // 승률 추출 - 주차별 테이블 형식: "2-1-0 (0.667)\n6경기"
                        const textA = cellA.textContent || cellA.innerText;
                        const textB = cellB.textContent || cellB.innerText;
                        
                        // 괄호 안의 승률 추출 (예: "2-1-0 (0.667)" → 0.667)
                        const winRateA = parseFloat(textA.match(/\(([0-9.]+)\)/)?.[1] || '0');
                        const winRateB = parseFloat(textB.match(/\(([0-9.]+)\)/)?.[1] || '0');
                        
                        
                        
                        if (nextState === 1) {
                            return winRateB - winRateA; // 첫 번째 클릭: 내림차순 (높은 승률부터)
                        } else {
                            return winRateA - winRateB; // 두 번째 클릭: 오름차순 (낮은 승률부터)
                        }
                    });
                }
            }
            
            // 정렬된 행들을 다시 tbody에 추가
            tbody.innerHTML = '';
            rows.forEach((row, index) => {
                const weekText = row.cells[0]?.textContent;
                tbody.appendChild(row);
            });
        };

        // 주차별 성적 주차 정렬 함수
        let weeklyWeekSortState = 0; // 0: 1주차부터, 1: 최신 주차부터
        
        window.sortWeeklyByWeek = function() {
            const tbody = document.querySelector('.weekly-table tbody');
            if (!tbody) return;
            
            weeklyWeekSortState = (weeklyWeekSortState + 1) % 2;
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            rows.sort((a, b) => {
                const weekA = parseInt(a.cells[0].textContent);
                const weekB = parseInt(b.cells[0].textContent);
                
                if (weeklyWeekSortState === 0) {
                    return weekA - weekB; // 1주차부터
                } else {
                    return weekB - weekA; // 최신 주차부터
                }
            });
            
            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
        };

        // 게임별 기록 테이블 렌더링 (종합 순위와 동일한 방식)
        function renderGameByGameTable() {
            if (!gameRecordsData || !dashboardData?.standings) return;

            // 종합 순위 기준 팀 순서 사용 (정렬된 순서)
            const rankingSystem = getRankingSystem();
            const teams = rankingSystem.teams;
            
            // 각 팀의 게임 데이터를 날짜순으로 정렬하고 최대 경기 수 계산 (취소된 경기 제외)
            const teamSortedGames = {};
            teams.forEach(team => {
                if (gameRecordsData[team]?.games) {
                    teamSortedGames[team] = [...gameRecordsData[team].games]
                        .filter(game => game && game.date && game.date !== 'undefined' && !game.isCancelled)
                        .sort((a, b) => new Date(a.date) - new Date(b.date));
                } else {
                    teamSortedGames[team] = [];
                }
            });
            
            const maxGames = Math.max(...Object.values(teamSortedGames).map(games => games.length));
            
            let html = `
                <div class="table-scroll-wrapper">
                    <table class="all-teams-table">
                        <thead>
                            <tr>
                                <th>경기#</th>
                                ${teams.map(team => `<th class="team-header-column">${getTeamWithLogo(team, 'team-logo-small')}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>`;

            // 각 경기별로 행 생성
            for (let gameNum = 1; gameNum <= maxGames; gameNum++) {
                // 5게임 단위로 미묘한 배경색 구분과 구분선 추가
                const isEveryFifthGame = gameNum % 5 === 0;
                const rowBgColor = isEveryFifthGame ? 'rgba(52, 73, 94, 0.02)' : 'transparent';
                const gameNumBgColor = isEveryFifthGame ? 'rgba(52, 73, 94, 0.08)' : '#f8f9fa';
                const separatorClass = isEveryFifthGame ? ' fifth-game-separator' : '';
                
                html += `<tr class="game-row${separatorClass}" style="background: ${rowBgColor};">
                    <td class="game-number-cell" style="background: ${gameNumBgColor}; font-weight: var(--font-weight-bold);">${gameNum}</td>`;
                
                teams.forEach(team => {
                    const sortedGames = teamSortedGames[team] || [];
                    const game = sortedGames[gameNum - 1];
                    
                    if (game) {
                        // 현재 게임에서의 연승/연패 카운트 계산 (정렬된 데이터 사용)
                        const streakInfo = calculateStreakAtGame(sortedGames, gameNum - 1);
                        const streakNumber = streakInfo.count > 0 ? streakInfo.count : '';
                        
                        // 결과를 한글로 변환 (취소된 경기 처리 포함)
                        const resultText = game.isCancelled ? '취소' :
                                         game.result === 'W' ? '승' :
                                         game.result === 'L' ? '패' :
                                         game.result === 'D' || game.result === 'T' ? '무' :
                                         game.result || '취소';
                        
                        // 무승부 및 취소된 경기 특별한 클래스 추가
                        const isDraw = game.result === 'D' || game.result === 'T';
                        const isCancelled = game.isCancelled;
                        const resultClass = isCancelled ? 'result-letter cancelled-result' : isDraw ? 'result-letter draw-result' : 'result-letter';

                        html += `
                        <td class="game-result-cell ${isCancelled ? 'cell-cancelled' : game.result === 'W' ? 'cell-win' : game.result === 'L' ? 'cell-loss' : 'cell-draw'}" 
                            title="${team} vs ${game.opponent} (${game.score}) - ${game.date}">
                            <div class="result-display">
                                ${isCancelled ? `<span class="${resultClass}">${resultText}</span>` : isDraw ? `<span class="${resultClass}">${resultText}</span>` : (streakNumber ? `<span class="combined-result">${streakNumber}${resultText}</span>` : `<span class="${resultClass}">${resultText}</span>`)}
                            </div>
                        </td>`;
                    } else {
                        html += `<td class="game-result-cell cell-empty" style="text-align: center;">-</td>`;
                    }
                });
                
                html += `</tr>`;
            }

            html += `
                        </tbody>
                    </table>
                </div>
                
                <!-- 설명 섹션 -->
                <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                    <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">🎮 게임별 기록 설명</div>
                    <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                        <div style="margin-bottom: 6px;"><strong>승리 (W):</strong> <span style="background: #d4fdd4; color: #1e6f1e; padding: 2px 4px; border-radius: 3px; font-weight: var(--font-weight-semibold);">녹색 배경</span></div>
                        <div style="margin-bottom: 6px;"><strong>패배 (L):</strong> <span style="background: #fdd4d4; color: #b91c1c; padding: 2px 4px; border-radius: 3px; font-weight: var(--font-weight-semibold);">빨간색 배경</span></div>
                        <div style="margin-bottom: 6px;"><strong>무승부 (D):</strong> <span style="background: #fef3c7; color: #92400e; padding: 2px 4px; border-radius: 3px; font-weight: var(--font-weight-semibold);">노란색 배경</span></div>
                        <div><strong>연승/연패 표시:</strong> 이어질 때마다 숫자로 표시 (예: 1승→2승→3승 또는 1패→2패→3패)</div>
                    </div>
                </div>`;

            document.getElementById('gameRecordsContent').innerHTML = html;
            
            // 최신 경기로 스크롤 (우측 끝으로 + 하단으로)
            setTimeout(() => {
                const scrollContainer = document.querySelector('#gameRecordsContent .table-scroll-wrapper');
                if (scrollContainer) {
                    scrollContainer.scrollLeft = scrollContainer.scrollWidth;
                    scrollContainer.scrollTop = scrollContainer.scrollHeight;
                }
                
                // 최적화된 전체 게임 월별 탭 이벤트 리스너 (이벤트 위임 사용)
                initAllGamesMonthTabs();
            }, 100);
        }

        // 특정 게임에서의 연승/연패 카운트 계산 (무승부 무시)
        function calculateStreakAtGame(games, gameIndex) {
            if (gameIndex < 0 || gameIndex >= games.length) {
                return { type: null, count: 0 };
            }
            
            const currentGame = games[gameIndex];
            
            // 현재 게임이 무승부면 연속기록을 표시하지 않음
            if (currentGame.result === 'D' || currentGame.result === 'T') {
                return { type: null, count: 0 };
            }
            
            let count = 1;
            let streakType = currentGame.result;
            
            // 이전 게임들을 거슬러 올라가며 연속 기록 계산 (무승부는 무시)
            for (let i = gameIndex - 1; i >= 0; i--) {
                const prevGame = games[i];
                if (prevGame.result === 'D' || prevGame.result === 'T') {
                    // 무승부는 무시하고 계속
                    continue;
                } else if (prevGame.result === streakType) {
                    count++;
                } else {
                    // 다른 결과 만나면 연속 종료
                    break;
                }
            }
            
            return { type: streakType, count: count };
        }

        // 2025년 대한민국 공휴일
        const koreaHolidays2025 = {
            '2025-01-01': '신정',
            '2025-01-28': '설날 연휴',
            '2025-01-29': '설날',
            '2025-01-30': '설날 연휴',
            '2025-03-01': '3.1절',
            '2025-05-05': '어린이날',
            '2025-05-13': '부처님날',
            '2025-06-06': '현충일',
            '2025-08-15': '광복절',
            '2025-10-05': '추석 연휴',
            '2025-10-06': '추석',
            '2025-10-07': '추석 연휴',
            '2025-10-03': '개천절',
            '2025-10-09': '한글날',
            '2025-12-25': '크리스마스'
        };

        // 날짜가 공휴일인지 확인하는 함수
        function getHolidayInfo(dateString) {
            const holiday = koreaHolidays2025[dateString];
            if (holiday) {
                const date = new Date(dateString);
                const dayOfWeek = date.getDay();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                
                if (!isWeekend) {
                    return ` (${holiday})`;
                } else {
                    return ` 🎌`;
                }
            }
            return '';
        }

        // 팀별 상대전적 계산 함수 (해당 날짜까지의 누적 기록)
        function calculateTeamHeadToHead(team1, team2, upToDate = null) {
            if (!gameRecordsData) return null;

            const team1Record = gameRecordsData[team1];
            const team2Record = gameRecordsData[team2];

            if (!team1Record || !team2Record) return null;

            // 날짜 필터링 함수 (해당 날짜 포함)
            const isBeforeOrOnDate = (gameDate, targetDate) => {
                if (!targetDate) return true; // 날짜 제한이 없으면 모든 경기 포함
                return new Date(gameDate) <= new Date(targetDate);
            };

            // team1의 관점에서 team2와의 경기 기록 (해당 날짜까지)
            const team1Games = team1Record.games.filter(game =>
                game.opponent === team2 &&
                !game.isCancelled &&
                game.result &&
                game.result !== '' &&
                isBeforeOrOnDate(game.date, upToDate)
            );

            // team2의 관점에서 team1과의 경기 기록 (해당 날짜까지)
            const team2Games = team2Record.games.filter(game =>
                game.opponent === team1 &&
                !game.isCancelled &&
                game.result &&
                game.result !== '' &&
                isBeforeOrOnDate(game.date, upToDate)
            );

            // 모든 경기 합치기
            const allGames = [...team1Games, ...team2Games];

            // 중복 제거 (같은 날짜의 경기)
            const uniqueGames = [];
            const seenDates = new Set();

            for (const game of allGames) {
                const dateKey = `${game.date}`;
                if (!seenDates.has(dateKey)) {
                    seenDates.add(dateKey);
                    uniqueGames.push(game);
                }
            }

            let team1Wins = 0;
            let team2Wins = 0;
            let draws = 0;

            uniqueGames.forEach(game => {
                // 현재 게임이 어느 팀 관점인지 확인
                const isTeam1Game = team1Games.includes(game);

                if (isTeam1Game) {
                    // team1 관점의 게임
                    if (game.result === 'W') team1Wins++;
                    else if (game.result === 'L') team2Wins++;
                    else if (game.result === 'D' || game.result === 'T') draws++;
                } else {
                    // team2 관점의 게임
                    if (game.result === 'W') team2Wins++;
                    else if (game.result === 'L') team1Wins++;
                    else if (game.result === 'D' || game.result === 'T') draws++;
                }
            });

            // 전적이 없으면 null 반환
            if (team1Wins + team2Wins + draws === 0) {
                console.log(`No head-to-head found for ${team1} vs ${team2} up to ${upToDate}`);
                return null;
            }

            console.log(`Head-to-head for ${team1} vs ${team2} up to ${upToDate}: ${team1Wins}-${team2Wins}-${draws}`);
            return `${team1Wins}-${team2Wins}-${draws}`;
        }

        // 팀별 상세 게임 기록 렌더링 (종합 순위와 동일한 방식)
        function renderTeamDetailedRecords() {
            if (!gameRecordsData || !dashboardData?.standings) return;

            // 종합 순위 기준 팀 순서 사용 (정렬된 순서)
            const rankingSystem = getRankingSystem();
            const rankedTeams = rankingSystem.teams;
            const teams = ['전체', ...rankedTeams];
            
            let html = `
                <div class="team-selector" style="text-align: center; margin-bottom: 15px;">
                    <h3 style="margin-bottom: 10px; color: #2d3748; font-size: var(--font-xl); font-weight: var(--font-weight-semibold);">📋 팀 선택</h3>
                    <div class="team-tabs" style="display: flex; flex-wrap: nowrap; justify-content: center; gap: 6px; padding: 5px; background: #f8f9fa; border-radius: 8px; max-width: 100%; margin: 0 auto; border: 1px solid #e9ecef; overflow-x: auto; -webkit-overflow-scrolling: touch; scroll-behavior: smooth;">
                        ${teams.map(team => 
                            `<button onclick="changeSelectedTeam('${team}')" 
                                class="team-tab ${team === currentSelectedTeam ? 'active' : ''}" 
                                style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid ${team === currentSelectedTeam ? '#495057' : '#dee2e6'}; border-radius: 6px; background: ${team === currentSelectedTeam ? '#495057' : 'white'}; color: ${team === currentSelectedTeam ? 'white' : '#666'}; cursor: pointer; transition: all 0.2s ease; min-width: 75px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;"
                                onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }"
                                onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">
                                ${team === '전체' ? '📊 전체' : getTeamWithLogo(team, 'team-logo-small')}
                            </button>`
                        ).join('')}
                    </div>
                </div>`;

            // 전체 탭 선택 시 날짜/구장별 경기 결과 표시
            if (currentSelectedTeam === '전체') {
                html += renderAllTeamsStadiumView();
            } else {
                const teamRecord = gameRecordsData[currentSelectedTeam];
                if (teamRecord) {
                // 최근 10경기 기록 (취소된 경기 제외)
                const completedGames = teamRecord.games.filter(game => !game.isCancelled);
                const recentGames = completedGames.slice(-10);
                const recent10Record = recentGames.reduce((acc, game) => {
                    if (game.result === 'W') acc.wins++;
                    else if (game.result === 'L') acc.losses++;
                    else acc.draws++;
                    return acc;
                }, { wins: 0, losses: 0, draws: 0 });

                // 전체 기록
                const totalRecord = teamRecord.games.reduce((acc, game) => {
                    if (game.isCancelled) return acc; // 취소된 경기는 통계에서 제외
                    if (game.result === 'W') acc.wins++;
                    else if (game.result === 'L') acc.losses++;
                    else acc.draws++;
                    return acc;
                }, { wins: 0, losses: 0, draws: 0 });

                const winRate = totalRecord.wins > 0 ? (totalRecord.wins / (totalRecord.wins + totalRecord.losses)).toFixed(3) : '0.000';

                // 총 경기수 (취소된 경기 제외)
                const totalGames = totalRecord.wins + totalRecord.losses + totalRecord.draws;

                html += `
                <div class="selected-team-details">
                    <h3 style="text-align: center; margin-bottom: 12px; color: #2d3748; font-size: var(--font-xl); font-weight: var(--font-weight-semibold);">${currentSelectedTeam} 게임 기록</h3>
                    
                    <!-- 팀 통계 요약 (한줄 레이아웃) -->
                    <div class="team-stats-summary" style="margin-bottom: 12px; background: #f8f9fa; padding: 8px 12px; border-radius: 8px; border: 1px solid #e9ecef;">
                        <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 15px; max-width: 85%; margin: 0 auto;">
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <span style="font-size: var(--font-sm); color: #718096; font-weight: var(--font-weight-medium);">총경기</span>
                                <span style="font-size: var(--font-lg); font-weight: var(--font-weight-bold); color: #2d3748;">${totalGames}</span>
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <span style="font-size: var(--font-sm); color: #718096; font-weight: var(--font-weight-medium);">전체성적</span>
                                <span style="font-size: var(--font-lg); font-weight: var(--font-weight-bold); color: #2d3748;">${totalRecord.wins}-${totalRecord.losses}-${totalRecord.draws}</span>
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <span style="font-size: var(--font-sm); color: #718096; font-weight: var(--font-weight-medium);">승률</span>
                                <span style="font-size: var(--font-lg); font-weight: var(--font-weight-bold); color: #3182ce;">${winRate}</span>
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <span style="font-size: var(--font-sm); color: #718096; font-weight: var(--font-weight-medium);">최근10경기</span>
                                <span style="font-size: var(--font-lg); font-weight: var(--font-weight-bold); color: #2d3748;">${recent10Record.wins}-${recent10Record.losses}-${recent10Record.draws}</span>
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <span style="font-size: var(--font-sm); color: #718096; font-weight: var(--font-weight-medium);">현재연속</span>
                                <span style="font-size: var(--font-lg); font-weight: var(--font-weight-bold);" class="${getOfficialStreakClass(currentSelectedTeam)}">
                                    ${getOfficialStreakDisplay(currentSelectedTeam)}
                                </span>
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <span style="font-size: var(--font-sm); color: #718096; font-weight: var(--font-weight-medium);">최장연승</span>
                                <span style="font-size: var(--font-lg); font-weight: var(--font-weight-bold);" class="win-color">${getOfficialMaxWinStreak(currentSelectedTeam)}</span>
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <span style="font-size: var(--font-sm); color: #718096; font-weight: var(--font-weight-medium);">최장연패</span>
                                <span style="font-size: var(--font-lg); font-weight: var(--font-weight-bold);" class="loss-color">${getOfficialMaxLoseStreak(currentSelectedTeam)}</span>
                            </div>
                        </div>
                    </div>

                    <!-- 상세 게임 기록 테이블 -->
                    <div class="detailed-games-section" style="margin-top: 5px;">
                        <h3 style="text-align: center; margin: 5px 0 5px 0; color: #2d3748; font-size: var(--font-xl); font-weight: var(--font-weight-semibold);">📋 팀별 게임 기록 및 일정</h3>
                        
                        <!-- 팀별 필터 옵션 -->
                        <div class="team-filters" style="display: flex; justify-content: center; gap: 15px; margin-bottom: 10px; flex-wrap: wrap;">
                            <div class="filter-group">
                                <label style="font-size: var(--font-sm); color: #495057; font-weight: var(--font-weight-medium);">상대팀:</label>
                                <select id="opponentFilter" onchange="applyTeamFilters()" style="margin-left: 5px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: var(--font-sm);">
                                    <option value="all">전체 상대팀</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label style="font-size: var(--font-sm); color: #495057; font-weight: var(--font-weight-medium);">홈/원정:</label>
                                <div style="margin-left: 5px; display: inline-flex; background: #f8f9fa; border-radius: 5px; border: 1px solid #ddd; overflow: hidden;">
                                    <button id="venueAll" onclick="setVenueFilter('all')" style="padding: 4px 10px; border: none; background: #495057; color: white; font-size: var(--font-sm); cursor: pointer;">전체</button>
                                    <button id="venueHome" onclick="setVenueFilter('home')" style="padding: 4px 10px; border: none; background: transparent; color: #666; font-size: var(--font-sm); cursor: pointer;">홈</button>
                                    <button id="venueAway" onclick="setVenueFilter('away')" style="padding: 4px 10px; border: none; background: transparent; color: #666; font-size: var(--font-sm); cursor: pointer;">원정</button>
                                </div>
                            </div>
                        </div>

                        <!-- 팀별 월별 탭 (동적으로 생성됨) -->
                        <div class="team-month-tabs" id="team-month-tabs-container" style="text-align: center; margin-bottom: 8px; display: none;"></div>
                        
                        <div class="table-scroll-wrapper" id="team-detailed-table-wrapper">
                            <table class="detailed-game-table" id="detailedGameTable">
                                <thead>
                                    <tr>
                                        <th class="sortable" data-column="gameNumber">경기#</th>
                                        <th class="sortable" data-column="date">날짜</th>
                                        <th class="sortable" data-column="opponent">상대팀</th>
                                        <th class="sortable" data-column="venue">홈/원정</th>
                                        <th>스코어</th>
                                        <th class="sortable" data-column="result">결과</th>
                                        <th>상대전적</th>
                                        <th class="sortable" data-column="runs_scored">득점</th>
                                        <th class="sortable" data-column="runs_allowed">실점</th>
                                        <th class="sortable" data-column="scoreDiff">득실차</th>
                                    </tr>
                                </thead>
                                <tbody id="detailedGameTableBody">`;

                // 월별 첫 경기 추적을 위한 Set
                const teamMonthFirstGameAdded = new Set();
                
                teamRecord.games.forEach((game, index) => {
                    const scoreDiff = game.runs_scored - game.runs_allowed;
                    const scoreDiffText = scoreDiff > 0 ? `+${scoreDiff}` : scoreDiff.toString();
                    
                    // 날짜에서 요일 계산 (주말/평일 구분)
                    const gameDate = new Date(game.date);
                    const dayOfWeek = gameDate.getDay(); // 0=일요일, 6=토요일
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    
                    // 요일 이름 추가
                    const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
                    const dayName = dayNames[dayOfWeek];
                    
                    // 공휴일 정보 및 날짜 형식 처리 (모바일 최적화)
                    const isHoliday = koreaHolidays2025[game.date];
                    const holidayName = isHoliday || '';
                    
                    // 날짜를 월/일 형식으로 변환
                    const dateParts = game.date.split('-');
                    const monthDay = `${parseInt(dateParts[1])}월 ${parseInt(dateParts[2])}일`;
                    const monthNum = parseInt(dateParts[1]);
                    
                    // 월별 첫 경기에 ID 추가
                    let monthId = '';
                    if (!teamMonthFirstGameAdded.has(monthNum)) {
                        monthId = ` id="team-month-${monthNum}-start"`;
                        teamMonthFirstGameAdded.add(monthNum);
                    }
                    
                    // 공휴일이면 요일 아래 공휴일명, 아니면 요일만
                    let displayDate;
                    if (isHoliday) {
                        displayDate = `${monthDay}<br>(${dayName})<br><small>${holidayName}</small>`;
                    } else {
                        displayDate = `${monthDay}<br>(${dayName})`;
                    }
                    
                    // 날짜 클래스 결정 (공휴일 > 주말 > 평일 순서)
                    let dateClass = 'weekday-date';
                    if (isHoliday) {
                        dateClass = 'holiday-date';
                    } else if (isWeekend) {
                        dateClass = 'weekend-date';
                    }
                    
                    html += `
                        <tr class="${game.isCancelled ? 'cancelled-row' : game.result === 'W' ? 'win-row' : game.result === 'L' ? 'loss-row' : 'draw-row'}"${monthId}>
                            <td class="game-num-cell">${game.isCancelled ? '-' : game.gameNumber}</td>
                            <td class="date-cell ${dateClass}">${displayDate}</td>
                            <td class="opponent-cell">${getTeamWithLogo(game.opponent)}</td>
                            <td class="venue-cell ${game.isHome ? 'home-venue' : 'away-venue'}">${game.isHome ? '홈' : '원정'}</td>
                            <td class="score-cell">${game.score}</td>
                            <td class="result-cell">
                                <span class="result-badge ${game.isCancelled ? 'cancelled' : game.result.toLowerCase()}">${
                                    game.isCancelled ? '-' :
                                    game.result === 'W' ? '승' :
                                    game.result === 'L' ? '패' : '무'
                                }</span>
                            </td>
                            <td class="head-to-head-cell">${(() => {
                                const h2h = calculateTeamHeadToHead(currentSelectedTeam, game.opponent, game.date);
                                return h2h ? h2h : '-';
                            })()}</td>
                            <td class="runs-cell">${game.runs_scored}</td>
                            <td class="runs-cell">${game.runs_allowed}</td>
                            <td class="diff-cell ${getRunDiffClass(scoreDiff)}">${scoreDiffText}</td>
                        </tr>`;
                });

                // 미래 경기 일정 추가
                if (futureScheduleData && futureScheduleData.length > 0) {
                    const teamFutureGames = futureScheduleData.filter(game => 
                        game.homeTeam === currentSelectedTeam || game.awayTeam === currentSelectedTeam
                    );
                    
                    if (teamFutureGames.length > 0) {
                        // 구분선 추가
                        html += `
                            <tr style="background: #e9ecef; border-top: 2px solid #6c757d;">
                                <td colspan="10" style="text-align: center; padding: 10px 8px; font-weight: 600; color: #495057;">
                                    📅 예정 경기 (${teamFutureGames.length}경기)
                                </td>
                            </tr>`;
                        
                        teamFutureGames.forEach((game, index) => {
                            const isHome = game.homeTeam === currentSelectedTeam;
                            const opponent = isHome ? game.awayTeam : game.homeTeam;
                            
                            // 날짜에서 요일 계산 - UTC 문제 해결
                            const [yearNum, monthNum, dayNum] = game.date.split('-').map(Number);
                            const gameDate = new Date(yearNum, monthNum - 1, dayNum);
                            const dayOfWeek = gameDate.getDay();
                            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                            const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
                            const dayName = dayNames[dayOfWeek];
                            
                            // 날짜를 월/일 형식으로 변환
                            const dateParts = game.date.split('-');
                            const monthDay = `${parseInt(dateParts[1])}월 ${parseInt(dateParts[2])}일`;
                            const futureMonthNum = parseInt(dateParts[1]);
                            const displayDate = `<span class="date-main">${monthDay}</span><br><span class="date-day">(${dayName})</span><br><small class="date-time">${game.time}</small>`;
                            
                            // 월별 첫 경기에 ID 추가 (미래 경기도 포함)
                            let futureMonthId = '';
                            if (!teamMonthFirstGameAdded.has(futureMonthNum)) {
                                futureMonthId = ` id="team-month-${futureMonthNum}-start"`;
                                teamMonthFirstGameAdded.add(futureMonthNum);
                            }
                            
                            // 미래 경기는 별도 스타일
                            const dateClass = isWeekend ? 'weekend-date' : 'weekday-date';
                            
                            html += `
                                <tr class="future-game-row" style="background: #f8f9fa; opacity: 0.8;"${futureMonthId}>
                                    <td class="game-num-cell" style="color: #4b5563; text-align: center;">-</td>
                                    <td class="date-cell ${dateClass}">${displayDate}</td>
                                    <td class="opponent-cell">${getTeamWithLogo(opponent)}</td>
                                    <td class="venue-cell ${isHome ? 'home-venue' : 'away-venue'}">${isHome ? '홈' : '원정'}</td>
                                    <td class="score-cell" style="color: #4b5563;">vs</td>
                                    <td class="result-cell">
                                        <span class="result-badge future" style="background: #6c757d; color: white;">예정</span>
                                    </td>
                                    <td class="head-to-head-cell">${(() => {
                                        const h2h = calculateTeamHeadToHead(currentSelectedTeam, opponent, game.date);
                                        return h2h ? h2h : '-';
                                    })()}</td>
                                    <td class="runs-cell" style="color: #4b5563; text-align: center;">-</td>
                                    <td class="runs-cell" style="color: #4b5563; text-align: center;">-</td>
                                    <td class="diff-cell" style="color: #4b5563; text-align: center;">-</td>
                                </tr>`;
                        });
                    }
                }

                html += `
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- 설명 섹션 -->
                        <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                            <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📋 게임 기록 설명</div>
                            <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                                <div style="margin-bottom: 6px;"><strong>경기 기록:</strong> 시즌 전체 경기 결과 (승부, 점수, 홈/원정 정보)</div>
                                <div style="margin-bottom: 6px;"><strong>예정 경기:</strong> 선택한 팀의 남은 경기 일정 (날짜, 시간, 상대팀)</div>
                                <div style="margin-bottom: 6px;"><strong>필터 기능:</strong> 특정 팀 선택 시 상대팀별/홈원정별 필터링 가능 (순위순 정렬)</div>
                                <div style="margin-bottom: 6px;"><strong>홈/원정:</strong> <span style="color: #2563eb; font-weight: var(--font-weight-semibold);">홈</span> (파란색), <span style="color: #dc2626; font-weight: var(--font-weight-semibold);">원정</span> (빨간색)</div>
                                <div style="margin-bottom: 6px;"><strong>날짜:</strong> <span style="color: #1f2937;">평일</span> (검은색), <span style="color: #dc2626; font-weight: var(--font-weight-semibold);">주말</span> (빨간색)</div>
                                <div><strong>구분:</strong> 과거 경기는 승부 결과별 색상, 예정 경기는 회색 배경으로 표시</div>
                            </div>
                        </div>
                    </div>
                </div>`;
                }
            }

            html += ``;
            document.getElementById('teamDetailedRecordsContent').innerHTML = html;
            
            // 팀별 월별 탭 생성 및 이벤트 리스너 추가 (전체 탭이 아닌 경우에만)
            const teamMonthTabsContainer = document.getElementById('team-month-tabs-container');
            if (currentSelectedTeam !== '전체' && teamMonthTabsContainer) {
                // 10월 경기가 있는지 확인
                const hasOctoberGames = gameRecordsData[currentSelectedTeam]?.games?.some(game => {
                    const month = new Date(game.date).getMonth() + 1;
                    return month === 10;
                }) || false;
                
                // 월별 탭 HTML 생성
                const monthTabsHtml = `
                    <div class="team-month-tabs-container" style="display: flex; flex-wrap: nowrap; justify-content: center; gap: 6px; padding: 5px; background: #f8f9fa; border-radius: 8px; max-width: 100%; margin: 0 auto; border: 1px solid #e9ecef; overflow-x: auto; -webkit-overflow-scrolling: touch; scroll-behavior: smooth;">
                        <button class="team-month-tab active" data-month="current" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #495057; border-radius: 6px; background: #495057; color: white; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">📍 현재</button>
                        <button class="team-month-tab" data-month="3" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">3월</button>
                        <button class="team-month-tab" data-month="4" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">4월</button>
                        <button class="team-month-tab" data-month="5" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">5월</button>
                        <button class="team-month-tab" data-month="6" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">6월</button>
                        <button class="team-month-tab" data-month="7" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">7월</button>
                        <button class="team-month-tab" data-month="8" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">8월</button>
                        <button class="team-month-tab" data-month="9" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">9월</button>
                        ${hasOctoberGames ? `<button class="team-month-tab" data-month="10" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">10월</button>` : ''}
                    </div>
                `;
                teamMonthTabsContainer.innerHTML = monthTabsHtml;
                teamMonthTabsContainer.style.display = 'block';
            } else if (teamMonthTabsContainer) {
                // 전체 팀이 선택된 경우 탭 숨김
                teamMonthTabsContainer.style.display = 'none';
            }
            
            if (currentSelectedTeam !== '전체') {
                // DOM 업데이트 후 팀별 월별 탭 이벤트 리스너 추가
                setTimeout(() => {
                    initTeamMonthTabs();
                }, 100);
            } else {
                // 전체 탭 선택시 전체 게임 월별 탭 이벤트 리스너 추가
                setTimeout(() => {
                    initAllGamesMonthTabs();
                }, 100);
            }
            
            // 정렬 기능 초기화
            if (currentSelectedTeam !== '전체' && gameRecordsData[currentSelectedTeam]) {
                initializeDetailedTableSorting();
                // 필터 초기화
                initializeTeamFilters();
            }
            
            // 최적화된 테이블 렌더링 후 자동 스크롤
            requestAnimationFrame(() => {
                autoScrollToRecentGames(currentSelectedTeam);
            });
        }
        
        // 전체 팀 날짜별 경기 결과 뷰 렌더링 (개별 팀과 일관된 스타일)
        function renderAllTeamsStadiumView() {
            if (!gameRecordsData) return '';
            
            // 모든 팀의 게임 데이터 수집
            const allGames = [];
            // 종합 순위 기준 팀 순서 사용
            if (!dashboardData?.standings) return '';
            const teams = getRankingSystem().teams;
            
            teams.forEach(team => {
                if (gameRecordsData[team] && gameRecordsData[team].games) {
                    gameRecordsData[team].games.forEach(game => {
                        if (game && game.date && game.date !== 'undefined') {
                            allGames.push({
                                ...game,
                                team: team
                            });
                        }
                    });
                }
            });
            
            // 날짜별로 그룹화
            const gamesByDate = {};
            allGames.forEach(game => {
                if (!gamesByDate[game.date]) {
                    gamesByDate[game.date] = [];
                }
                gamesByDate[game.date].push(game);
            });
            
            // 날짜 목록 추출 및 정렬 (첫 경기부터)
            const dates = Object.keys(gamesByDate).filter(date => date && date !== 'undefined').sort();
            
            // 10월 경기가 있는지 확인 (모든 팀 경기 확인)
            const hasOctoberGamesAll = Object.values(gameRecordsData).some(teamData => {
                return teamData?.games?.some(game => {
                    const month = new Date(game.date).getMonth() + 1;
                    return month === 10;
                });
            }) || false;
            
            let html = `
            <div class="all-teams-overview">
                <h3 style="text-align: center; margin: 10px 0 8px 0; color: #2d3748; font-size: var(--font-xl); font-weight: var(--font-weight-semibold);">📊 전체 게임 기록 및 일정</h3>
                
                <!-- 전체 게임 월별 탭 -->
                <div class="all-games-month-tabs" style="text-align: center; margin-bottom: 8px;">
                    <div class="all-games-month-tabs-container" style="display: flex; flex-wrap: nowrap; justify-content: center; gap: 6px; padding: 5px; background: #f8f9fa; border-radius: 8px; max-width: 100%; margin: 0 auto; border: 1px solid #e9ecef; overflow-x: auto; -webkit-overflow-scrolling: touch; scroll-behavior: smooth;">
                        <button class="all-games-month-tab active" data-month="current" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #495057; border-radius: 6px; background: #495057; color: white; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">📍 현재</button>
                        <button class="all-games-month-tab" data-month="3" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">3월</button>
                        <button class="all-games-month-tab" data-month="4" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">4월</button>
                        <button class="all-games-month-tab" data-month="5" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">5월</button>
                        <button class="all-games-month-tab" data-month="6" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">6월</button>
                        <button class="all-games-month-tab" data-month="7" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">7월</button>
                        <button class="all-games-month-tab" data-month="8" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">8월</button>
                        <button class="all-games-month-tab" data-month="9" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">9월</button>
                        ${hasOctoberGamesAll ? `<button class="all-games-month-tab" data-month="10" style="padding: 6px 10px; font-size: var(--font-sm); font-weight: var(--font-weight-medium); border: 1px solid #dee2e6; border-radius: 6px; background: white; color: #666; cursor: pointer; transition: all 0.2s ease; min-width: 55px; display: inline-flex; align-items: center; justify-content: center; gap: 3px; flex-shrink: 0;" onmouseover="if(!this.classList.contains('active')) { this.style.background='#e9ecef'; this.style.borderColor='#495057'; this.style.color='#495057'; }" onmouseout="if(!this.classList.contains('active')) { this.style.background='white'; this.style.borderColor='#dee2e6'; this.style.color='#666'; }">10월</button>` : ''}
                    </div>
                </div>
                
                <div class="table-container" style="max-height: 800px; overflow-y: auto;">
                    <table class="all-teams-table detailed-game-table" style="width: 100%; border-collapse: collapse; font-size: var(--font-sm);">
                        <thead>
                            <tr style="background: #34495e; color: white; position: sticky; top: 0; z-index: 10;">
                                <th class="date-header-cell" style="padding: 1px 3px; border: 1px solid #495057; text-align: center; min-width: 140px;">날짜</th>
                                ${teams.map(team => 
                                    `<th style="padding: 1px 3px; border: 1px solid #495057; text-align: center; min-width: 80px; font-size: var(--font-xs);">${getTeamWithLogo(team, 'team-logo-small')}</th>`
                                ).join('')}
                            </tr>
                        </thead>
                        <tbody>`;
            
            // 날짜별 행 생성 (모든 경기 표시)
            const allGamesMonthFirstAdded = new Set();
            dates.forEach(date => {
                // 날짜 형식을 개별 팀과 동일하게 처리
                const gameDate = new Date(date);
                const dayOfWeek = gameDate.getDay();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                
                // 요일 이름 추가
                const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
                const dayName = dayNames[dayOfWeek];
                
                // 공휴일 정보 및 날짜 형식 처리 (모바일 최적화)
                const isHoliday = koreaHolidays2025[date];
                const holidayName = isHoliday || '';
                
                // 날짜를 월/일 형식으로 변환
                const dateParts = date.split('-');
                const monthDay = `${parseInt(dateParts[1])}월 ${parseInt(dateParts[2])}일`;
                const allGamesMonthNum = parseInt(dateParts[1]);
                
                // 월별 첫 날짜에 ID 추가
                let allGamesMonthId = '';
                if (!allGamesMonthFirstAdded.has(allGamesMonthNum)) {
                    allGamesMonthId = ` id="all-games-month-${allGamesMonthNum}-start"`;
                    allGamesMonthFirstAdded.add(allGamesMonthNum);
                }
                
                // 공휴일이면 요일 아래 공휴일명, 아니면 요일만
                let displayDate;
                if (isHoliday) {
                    displayDate = `<span class="date-main">${monthDay}</span><br><span class="date-day">(${dayName})</span><br><small class="date-holiday">${holidayName}</small>`;
                } else {
                    displayDate = `<span class="date-main">${monthDay}</span><br><span class="date-day">(${dayName})</span>`;
                }
                
                // 날짜 클래스 결정 (개별 팀과 동일)
                let dateClass = 'weekday-date';
                if (isHoliday) {
                    dateClass = 'holiday-date';
                } else if (isWeekend) {
                    dateClass = 'weekend-date';
                }
                
                html += `
                <tr style="border-bottom: 1px solid #e2e8f0;"${allGamesMonthId}>
                    <td class="date-cell ${dateClass}" style="padding: 1px 3px; border: 1px solid #e2e8f0; text-align: center; background: #f8f9fa; white-space: nowrap;">
                        ${displayDate}
                    </td>`;
                
                // 각 팀별로 해당 날짜의 경기 결과 표시
                teams.forEach(team => {
                    const teamGames = gamesByDate[date] ? gamesByDate[date].filter(game => game.team === team) : [];
                    
                    if (teamGames.length === 0) {
                        html += `<td style="padding: 1px 3px; border: 1px solid #e2e8f0; text-align: center; background: #f9f9f9; color: #999;">-</td>`;
                    } else {
                        // 해당 팀의 경기 결과 표시 (개별 팀과 동일한 스타일)
                        const gameResults = teamGames.map(game => {
                            // 개별 팀 테이블과 동일한 색상 적용
                            let rowClass = '';
                            if (game.isCancelled) rowClass = 'cancelled-row';
                            else if (game.result === 'W') rowClass = 'win-row';
                            else if (game.result === 'L') rowClass = 'loss-row';
                            else rowClass = 'draw-row';
                            
                            const venueIcon = game.isHome ? '🏠' : '✈️';
                            const venueClass = game.isHome ? 'home-venue' : 'away-venue';
                            
                            return `<div class="${rowClass}" style="margin: 1px 0; padding: 4px 5px; border-radius: 3px; font-weight: var(--font-weight-semibold); font-size: var(--font-sm); line-height: 1.6;">
                                <span class="${venueClass}">${venueIcon}</span> vs ${game.opponent}<br>
                                <span class="result-badge ${game.isCancelled ? 'cancelled' : game.result.toLowerCase()}">${game.isCancelled ? '-' : game.result === 'W' ? '승' : game.result === 'L' ? '패' : '무'}</span> ${game.score}
                            </div>`;
                        }).join('');
                        
                        html += `<td style="padding: 1px; border: 1px solid #e2e8f0; text-align: center;">${gameResults}</td>`;
                    }
                });
                
                html += `</tr>`;
            });
            
            // 미래 경기 일정 추가
            if (futureScheduleData && futureScheduleData.length > 0) {
                // 날짜별로 미래 경기 그룹화
                const futureGamesByDate = {};
                futureScheduleData.forEach(game => {
                    if (!futureGamesByDate[game.date]) {
                        futureGamesByDate[game.date] = [];
                    }
                    futureGamesByDate[game.date].push(game);
                });
                
                const futureDates = Object.keys(futureGamesByDate).sort();
                
                if (futureDates.length > 0) {
                    // 구분선 추가
                    html += `
                        <tr style="background: #e9ecef; border-top: 2px solid #6c757d;">
                            <td colspan="${teams.length + 1}" style="text-align: center; padding: 15px 8px; font-weight: 600; color: #495057;">
                                📅 예정 경기 (${futureScheduleData.length}경기)
                            </td>
                        </tr>`;
                    
                    // 미래 경기 날짜별 행 생성
                    futureDates.forEach(date => {
                        // Date 파싱 시 UTC 문제 해결
                        const [year, month, day] = date.split('-').map(Number);
                        const gameDate = new Date(year, month - 1, day);
                        const dayOfWeek = gameDate.getDay();
                        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                        
                        // 요일 이름 추가
                        const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
                        const dayName = dayNames[dayOfWeek];
                        
                        // 날짜를 월/일 형식으로 변환
                        const dateParts = date.split('-');
                        const monthDay = `${parseInt(dateParts[1])}월 ${parseInt(dateParts[2])}일`;
                        const displayDate = `<span class="date-main">${monthDay}</span><br><span class="date-day">(${dayName})</span>`;
                        
                        // 미래 경기는 별도 스타일
                        const dateClass = isWeekend ? 'weekend-date' : 'weekday-date';
                        
                        html += `
                        <tr class="future-game-row" style="background: #f8f9fa; opacity: 0.8; border-bottom: 1px solid #e2e8f0;">
                            <td class="date-cell ${dateClass}" style="padding: 1px 3px; border: 1px solid #e2e8f0; text-align: center; background: #f1f3f4; white-space: nowrap;">
                                ${displayDate}
                            </td>`;
                        
                        // 각 팀별로 해당 날짜의 미래 경기 표시
                        teams.forEach(team => {
                            const teamFutureGames = futureGamesByDate[date] ? 
                                futureGamesByDate[date].filter(game => 
                                    game.homeTeam === team || game.awayTeam === team
                                ) : [];
                            
                            if (teamFutureGames.length === 0) {
                                html += `<td style="padding: 1px 3px; border: 1px solid #e2e8f0; text-align: center; background: #f9f9f9; color: #999;">-</td>`;
                            } else {
                                const gameResults = teamFutureGames.map(game => {
                                    const isHome = game.homeTeam === team;
                                    const opponent = isHome ? game.awayTeam : game.homeTeam;
                                    const venueIcon = isHome ? '🏠' : '✈️';
                                    const venueClass = isHome ? 'home-venue' : 'away-venue';
                                    
                                    return `<div class="future-game" style="margin: 1px 0; padding: 4px 5px; border-radius: 3px; background: #e9ecef; font-weight: var(--font-weight-semibold); font-size: var(--font-sm); line-height: 1.6; color: #4b5563;">
                                        <span class="${venueClass}">${venueIcon}</span> vs ${opponent}<br>
                                        <span class="result-badge future" style="background: #6c757d; color: white; padding: 1px 4px; border-radius: 3px; font-size: var(--font-xs);">예정</span> ${game.time}
                                    </div>`;
                                }).join('');
                                
                                html += `<td style="padding: 1px; border: 1px solid #e2e8f0; text-align: center;">${gameResults}</td>`;
                            }
                        });
                        
                        html += `</tr>`;
                    });
                }
            }
            
            html += `
                        </tbody>
                    </table>
                </div>
                
                <!-- 설명 (개별 팀과 동일한 스타일) -->
                <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                    <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">📊 전체 경기 결과 & 일정 설명</div>
                    <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                        <div style="margin-bottom: 6px;"><strong>경기 기록:</strong> 전체 팀의 과거 경기 결과 (승부, 점수 포함)</div>
                        <div style="margin-bottom: 6px;"><strong>예정 경기:</strong> 시즌 남은 모든 팀의 경기 일정 (시간 포함)</div>
                        <div style="margin-bottom: 6px;"><strong>날짜:</strong> <span style="color: #1f2937;">평일</span> (검은색), <span style="color: #dc2626; font-weight: var(--font-weight-semibold);">주말</span> (빨간색)</div>
                        <div style="margin-bottom: 6px;"><strong>홈/원정:</strong> <span style="color: #2563eb; font-weight: var(--font-weight-semibold);">🏠</span> (홈경기), <span style="color: #dc2626; font-weight: var(--font-weight-semibold);">✈️</span> (원정경기)</div>
                        <div style="margin-bottom: 6px;"><strong>구분:</strong> 과거 경기는 승부 결과별 색상, 예정 경기는 회색 배경으로 표시</div>
                        <div><strong>표시:</strong> 각 팀의 해당 날짜 경기 정보 (상대팀, 점수/시간 포함)</div>
                    </div>
                </div>
            </div>`;
            
            return html;
        }

        // 팀별 상세 테이블 정렬 기능 초기화
        function initializeDetailedTableSorting() {
            const table = document.getElementById('detailedGameTable');
            const headers = table.querySelectorAll('th.sortable');
            
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.dataset.column;
                    sortDetailedTable(column);
                });
            });
        }

        // 팀별 상세 테이블 정렬 함수
        function sortDetailedTable(column) {
            const table = document.getElementById('detailedGameTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 현재 정렬 방향 확인
            const isAscending = table.dataset.sortDirection !== 'asc';
            table.dataset.sortDirection = isAscending ? 'asc' : 'desc';
            
            // 헤더 업데이트 (화살표 제거)
            table.querySelectorAll('th.sortable').forEach(th => {
                th.textContent = th.textContent.replace(/\s[↑↓↕️]/g, '');
            });
            const currentHeader = table.querySelector(`th[data-column="${column}"]`);
            currentHeader.textContent = currentHeader.textContent.replace(/\s[↑↓↕️]/g, '');
            
            // 행 정렬
            rows.sort((a, b) => {
                let aVal, bVal;
                
                switch(column) {
                    case 'gameNumber':
                        const aText = a.querySelector('.game-num-cell').textContent;
                        const bText = b.querySelector('.game-num-cell').textContent;
                        aVal = aText === '-' ? 0 : parseInt(aText);
                        bVal = bText === '-' ? 0 : parseInt(bText);
                        break;
                    case 'date':
                        aVal = new Date(a.querySelector('.date-cell').textContent);
                        bVal = new Date(b.querySelector('.date-cell').textContent);
                        break;
                    case 'opponent':
                        aVal = a.querySelector('.opponent-cell').textContent;
                        bVal = b.querySelector('.opponent-cell').textContent;
                        break;
                    case 'venue':
                        aVal = a.querySelector('.venue-cell').textContent;
                        bVal = b.querySelector('.venue-cell').textContent;
                        break;
                    case 'result':
                        aVal = a.querySelector('.result-badge').textContent;
                        bVal = b.querySelector('.result-badge').textContent;
                        // 승 > 무 > 패 순서로 정렬
                        const resultOrder = {'승': 3, '무': 2, '패': 1};
                        aVal = resultOrder[aVal] || 0;
                        bVal = resultOrder[bVal] || 0;
                        break;
                    case 'runs_scored':
                        aVal = parseInt(a.querySelectorAll('.runs-cell')[0].textContent);
                        bVal = parseInt(b.querySelectorAll('.runs-cell')[0].textContent);
                        break;
                    case 'runs_allowed':
                        aVal = parseInt(a.querySelectorAll('.runs-cell')[1].textContent);
                        bVal = parseInt(b.querySelectorAll('.runs-cell')[1].textContent);
                        break;
                    case 'scoreDiff':
                        const aDiff = a.querySelector('.diff-cell').textContent.replace('+', '');
                        const bDiff = b.querySelector('.diff-cell').textContent.replace('+', '');
                        aVal = parseInt(aDiff);
                        bVal = parseInt(bDiff);
                        break;
                    default:
                        aVal = a.cells[0].textContent;
                        bVal = b.cells[0].textContent;
                }
                
                if (aVal < bVal) return isAscending ? -1 : 1;
                if (aVal > bVal) return isAscending ? 1 : -1;
                return 0;
            });
            
            // 정렬된 행들을 테이블에 다시 추가
            rows.forEach(row => tbody.appendChild(row));
        }

        
        // 레거시 지원용 (0.xxx 형식 기준)
        function getWinRateColor(winRate) {
            if (winRate > 0.55) return 'rgba(34, 197, 94, 0.1)';   // positive와 동일
            if (winRate < 0.45) return 'rgba(239, 68, 68, 0.1)';   // negative와 동일
            return 'rgba(234, 179, 8, 0.1)';                       // neutral과 동일
        }

        // 간단한 테스트 함수
        var fixSortToggle = true; // true: 연승순, false: 연패순
        
        window.fixedSort = function() {
            // 함수 차단 제거 - 정상 동작하도록 함
            
            // 타이머 제거는 유지
            for (let i = 1; i < 99999; i++) window.clearTimeout(i);
            for (let i = 1; i < 99999; i++) window.clearInterval(i);
            
            const tbody = document.getElementById('fullStandingsBody');
            const rows = Array.from(tbody.children);
            
            // 정렬할 팀 데이터 생성 - 동적으로 생성
            const teamOrder = getRankingSystem().teams;
            const teams = teamOrder.map(name => {
                // 실제 데이터에서 연속 기록 가져오기
                const streakDisplay = getOfficialStreakDisplay(name);
                const value = streakDisplay.includes('연승') ? 
                    parseInt(streakDisplay) : 
                    (streakDisplay.includes('연패') ? -parseInt(streakDisplay) : 0);
                return {name, streak: streakDisplay, value};
            });
            
            if (fixSortToggle) {
                teams.sort((a, b) => b.value - a.value); // 연승 우선
            } else {
                teams.sort((a, b) => a.value - b.value); // 연패 우선
            }
            
            // 기존 행들을 팀 이름으로 매핑
            const rowMap = {};
            rows.forEach(row => {
                const teamName = row.cells[1].textContent.trim();
                rowMap[teamName] = row.cloneNode(true);
            });
            
            // 정렬된 순서로 테이블 재구성
            tbody.innerHTML = '';
            teams.forEach((team, index) => {
                const row = rowMap[team.name];
                if (row) {
                    row.cells[0].innerHTML = `<strong>${index + 1}</strong>`;
                    tbody.appendChild(row);
                }
            });
            
            alert(`강제 정렬 완료! 1위: ${teams[0].name} (${teams[0].streak})`);
            fixSortToggle = !fixSortToggle;
        }

        // 연승/연패로 정렬 - 데이터 레벨에서 정렬
        var streakSortMode = 0; // 0: 연승순, 1: 연패순
        var isCustomSorted = false; // 사용자 정렬 상태 추적
        
        window.sortByStreakNew = function() {
            if (!dashboardData || !dashboardData.standings) {
                alert('데이터가 로드되지 않았습니다');
                return;
            }
            
            // 다른 렌더링 함수들을 임시로 비활성화
            const originalRenderDashboard = window.renderDashboard;
            const originalLoadDashboardData = window.loadDashboardData;
            
            // 원본 데이터 백업 (첫 호출시에만)
            if (!dashboardData.originalStandings) {
                dashboardData.originalStandings = [...dashboardData.standings];
            }
            
            // 현재 데이터 상태 디버그
            
            streakSortMode = (streakSortMode + 1) % 2;
            console.log('🔢 현재 streakSortMode:', streakSortMode);
            
            if (streakSortMode === 0) {
                // 연승 우선 정렬 (승팀 → 패팀 순서)
                dashboardData.standings.sort((a, b) => {
                    const aMatch = a.current_streak.match(/(\d+)([WL])/);
                    const bMatch = b.current_streak.match(/(\d+)([WL])/);
                    
                    if (!aMatch || !bMatch) return 0;
                    
                    const aNum = parseInt(aMatch[1]);
                    const bNum = parseInt(bMatch[1]);
                    const aType = aMatch[2];
                    const bType = bMatch[2];
                    
                    // 승 vs 패: 승이 항상 앞
                    if (aType === 'W' && bType === 'L') return -1;
                    if (aType === 'L' && bType === 'W') return 1;
                    
                    // 승 vs 승: 연승 수가 많은 순
                    if (aType === 'W' && bType === 'W') {
                        return bNum - aNum;
                    }
                    
                    // 패 vs 패: 연패 수가 적은 순
                    if (aType === 'L' && bType === 'L') {
                        return aNum - bNum;
                    }
                    
                    return 0;
                });
                
                // 연승패 정렬 후에는 assignRanksWithTies 호출하지 않음 (승률 기준 재정렬을 방지)
                
                isCustomSorted = true;
            } else {
                // 연패 우선 정렬 (패팀 → 승팀 순서)
                dashboardData.standings.sort((a, b) => {
                    const aMatch = a.current_streak.match(/(\d+)([WL])/);
                    const bMatch = b.current_streak.match(/(\d+)([WL])/);
                    
                    if (!aMatch || !bMatch) return 0;
                    
                    const aNum = parseInt(aMatch[1]);
                    const bNum = parseInt(bMatch[1]);
                    const aType = aMatch[2];
                    const bType = bMatch[2];
                    
                    // 패 vs 승: 패가 항상 앞
                    if (aType === 'L' && bType === 'W') return -1;
                    if (aType === 'W' && bType === 'L') return 1;
                    
                    // 패 vs 패: 연패 수가 많은 순
                    if (aType === 'L' && bType === 'L') {
                        return bNum - aNum;
                    }
                    
                    // 승 vs 승: 연승 수가 많은 순 (연패 우선이어도 승팀끼리는 연승 많은 순)
                    if (aType === 'W' && bType === 'W') {
                        return bNum - aNum;
                    }
                    
                    return 0;
                });
                
                // 연승패 정렬 후에는 assignRanksWithTies 호출하지 않음 (승률 기준 재정렬을 방지)
                
                isCustomSorted = true;
            }
            
            // 다른 함수들이 실행되지 않도록 무력화
            window.renderDashboard = function() { console.log('renderDashboard 무력화됨'); };
            window.loadDashboardData = function() { console.log('loadDashboardData 무력화됨'); };
            
            // 테이블만 다시 렌더링
            try {
                renderFullStandings();
            } catch (error) {
                console.error('renderFullStandings 에러:', error);
            }
            
            // 정렬 상태 유지를 위해 복원 시간을 30초로 연장
            setTimeout(() => {
                // 커스텀 정렬 상태가 아닐 때만 복원
                if (!isCustomSorted) {
                    window.renderDashboard = originalRenderDashboard;
                    window.loadDashboardData = originalLoadDashboardData;
                    console.log('원래 함수들 복원');
                } else {
                }
            }, 30000);
        }

        // 최대연승 정렬 모드 (0: 원래순위, 1: 내림차순, 2: 오름차순)
        var maxWinStreakSortMode = 0;
        
        window.sortByMaxWinStreak = function() {
            if (!dashboardData || !dashboardData.standings) {
                alert('데이터가 로드되지 않았습니다');
                return;
            }
            
            // 원본 데이터 백업
            if (!dashboardData.originalStandings) {
                dashboardData.originalStandings = [...dashboardData.standings];
            }
            
            maxWinStreakSortMode = (maxWinStreakSortMode + 1) % 3;
            
            if (maxWinStreakSortMode === 0) {
                // 원래 순위 순서로 복원
                dashboardData.standings = [...dashboardData.originalStandings];
            } else if (maxWinStreakSortMode === 1) {
                // 최대연승 내림차순 정렬
                dashboardData.standings.sort((a, b) => {
                    const aStreak = dashboardData.streakAnalysis?.find(t => t.team_name === a.team_name)?.max_win_streak || 0;
                    const bStreak = dashboardData.streakAnalysis?.find(t => t.team_name === b.team_name)?.max_win_streak || 0;
                    return bStreak - aStreak;
                });
            } else {
                // 최대연승 오름차순 정렬
                dashboardData.standings.sort((a, b) => {
                    const aStreak = dashboardData.streakAnalysis?.find(t => t.team_name === a.team_name)?.max_win_streak || 0;
                    const bStreak = dashboardData.streakAnalysis?.find(t => t.team_name === b.team_name)?.max_win_streak || 0;
                    return aStreak - bStreak;
                });
            }
            
            renderFullStandings();
        }

        // 최대연패 정렬 모드 (0: 원래순위, 1: 내림차순, 2: 오름차순)
        var maxLoseStreakSortMode = 0;
        
        window.sortByMaxLoseStreak = function() {
            if (!dashboardData || !dashboardData.standings) {
                alert('데이터가 로드되지 않았습니다');
                return;
            }
            
            // 원본 데이터 백업
            if (!dashboardData.originalStandings) {
                dashboardData.originalStandings = [...dashboardData.standings];
            }
            
            maxLoseStreakSortMode = (maxLoseStreakSortMode + 1) % 3;
            
            if (maxLoseStreakSortMode === 0) {
                // 원래 순위 순서로 복원
                dashboardData.standings = [...dashboardData.originalStandings];
            } else if (maxLoseStreakSortMode === 1) {
                // 최대연패 내림차순 정렬
                dashboardData.standings.sort((a, b) => {
                    const aStreak = dashboardData.streakAnalysis?.find(t => t.team_name === a.team_name)?.max_lose_streak || 0;
                    const bStreak = dashboardData.streakAnalysis?.find(t => t.team_name === b.team_name)?.max_lose_streak || 0;
                    return bStreak - aStreak;
                });
            } else {
                // 최대연패 오름차순 정렬
                dashboardData.standings.sort((a, b) => {
                    const aStreak = dashboardData.streakAnalysis?.find(t => t.team_name === a.team_name)?.max_lose_streak || 0;
                    const bStreak = dashboardData.streakAnalysis?.find(t => t.team_name === b.team_name)?.max_lose_streak || 0;
                    return aStreak - bStreak;
                });
            }
            
            renderFullStandings();
        }

        // 최대 가능 순위 정렬 모드 (0: 원래순위, 1: 오름차순, 2: 내림차순)
        var maxRankSortMode = 0;
        
        window.sortByMaxRank = function() {
            if (!dashboardData || !dashboardData.standings) {
                alert('데이터가 로드되지 않았습니다');
                return;
            }
            
            // 원본 데이터 백업
            if (!dashboardData.originalStandings) {
                dashboardData.originalStandings = [...dashboardData.standings];
            }
            
            maxRankSortMode = (maxRankSortMode + 1) % 3;
            
            if (maxRankSortMode === 0) {
                // 원래 순위 순서로 복원
                dashboardData.standings = [...dashboardData.originalStandings];
            } else if (maxRankSortMode === 1) {
                // 최대 가능 순위 오름차순 정렬 (좋은 순위부터)
                dashboardData.standings.sort((a, b) => {
                    // A팀의 최대순위 계산 (전승했을 때)
                    let aMaxRank = 1;
                    const aMaxWins = a.wins + (144 - a.games_played); // A팀 전승시
                    const aMaxLosses = a.losses;
                    const aMaxWinRate = aMaxWins / (aMaxWins + aMaxLosses);
                    
                    dashboardData.originalStandings.forEach(team => {
                        if (team.team_name !== a.team_name) {
                            const otherMinWins = team.wins; // 상대팀 전패시
                            const otherMinLosses = team.losses + (144 - team.games_played);
                            const otherMinWinRate = otherMinWins / (otherMinWins + otherMinLosses);
                            
                            // KBO 동률 처리 규칙 적용
                            if (aMaxWinRate < otherMinWinRate) {
                                aMaxRank++;
                            } else if (Math.abs(aMaxWinRate - otherMinWinRate) < 0.0001) {
                                const aMaxMargin = aMaxWins - aMaxLosses;
                                const otherMinMargin = otherMinWins - otherMinLosses;
                                if (aMaxMargin < otherMinMargin) {
                                    aMaxRank++;
                                }
                            }
                        }
                    });
                    
                    // B팀의 최대순위 계산 (전승했을 때)
                    let bMaxRank = 1;
                    const bMaxWins = b.wins + (144 - b.games_played); // B팀 전승시
                    const bMaxLosses = b.losses;
                    const bMaxWinRate = bMaxWins / (bMaxWins + bMaxLosses);
                    
                    dashboardData.originalStandings.forEach(team => {
                        if (team.team_name !== b.team_name) {
                            const otherMinWins = team.wins; // 상대팀 전패시
                            const otherMinLosses = team.losses + (144 - team.games_played);
                            const otherMinWinRate = otherMinWins / (otherMinWins + otherMinLosses);
                            
                            // KBO 동률 처리 규칙 적용
                            if (bMaxWinRate < otherMinWinRate) {
                                bMaxRank++;
                            } else if (Math.abs(bMaxWinRate - otherMinWinRate) < 0.0001) {
                                const bMaxMargin = bMaxWins - bMaxLosses;
                                const otherMinMargin = otherMinWins - otherMinLosses;
                                if (bMaxMargin < otherMinMargin) {
                                    bMaxRank++;
                                }
                            }
                        }
                    });
                    
                    return aMaxRank - bMaxRank;
                });
            } else {
                // 최대 가능 순위 내림차순 정렬 (나쁜 순위부터)
                dashboardData.standings.sort((a, b) => {
                    // A팀의 최대순위 계산 (전승했을 때)
                    let aMaxRank = 1;
                    const aMaxWins = a.wins + (144 - a.games_played); // A팀 전승시
                    const aMaxLosses = a.losses;
                    const aMaxWinRate = aMaxWins / (aMaxWins + aMaxLosses);
                    
                    dashboardData.originalStandings.forEach(team => {
                        if (team.team_name !== a.team_name) {
                            const otherMinWins = team.wins; // 상대팀 전패시
                            const otherMinLosses = team.losses + (144 - team.games_played);
                            const otherMinWinRate = otherMinWins / (otherMinWins + otherMinLosses);
                            
                            // KBO 동률 처리 규칙 적용
                            if (aMaxWinRate < otherMinWinRate) {
                                aMaxRank++;
                            } else if (Math.abs(aMaxWinRate - otherMinWinRate) < 0.0001) {
                                const aMaxMargin = aMaxWins - aMaxLosses;
                                const otherMinMargin = otherMinWins - otherMinLosses;
                                if (aMaxMargin < otherMinMargin) {
                                    aMaxRank++;
                                }
                            }
                        }
                    });
                    
                    // B팀의 최대순위 계산 (전승했을 때)
                    let bMaxRank = 1;
                    const bMaxWins = b.wins + (144 - b.games_played); // B팀 전승시
                    const bMaxLosses = b.losses;
                    const bMaxWinRate = bMaxWins / (bMaxWins + bMaxLosses);
                    
                    dashboardData.originalStandings.forEach(team => {
                        if (team.team_name !== b.team_name) {
                            const otherMinWins = team.wins; // 상대팀 전패시
                            const otherMinLosses = team.losses + (144 - team.games_played);
                            const otherMinWinRate = otherMinWins / (otherMinWins + otherMinLosses);
                            
                            // KBO 동률 처리 규칙 적용
                            if (bMaxWinRate < otherMinWinRate) {
                                bMaxRank++;
                            } else if (Math.abs(bMaxWinRate - otherMinWinRate) < 0.0001) {
                                const bMaxMargin = bMaxWins - bMaxLosses;
                                const otherMinMargin = otherMinWins - otherMinLosses;
                                if (bMaxMargin < otherMinMargin) {
                                    bMaxRank++;
                                }
                            }
                        }
                    });
                    
                    return bMaxRank - aMaxRank;
                });
            }
            
            renderFullStandings();
        }

        // 최소 가능 순위 정렬 모드 (0: 원래순위, 1: 오름차순, 2: 내림차순)
        var minRankSortMode = 0;
        
        window.sortByMinRank = function() {
            if (!dashboardData || !dashboardData.standings) {
                alert('데이터가 로드되지 않았습니다');
                return;
            }
            
            // 원본 데이터 백업
            if (!dashboardData.originalStandings) {
                dashboardData.originalStandings = [...dashboardData.standings];
            }
            
            minRankSortMode = (minRankSortMode + 1) % 3;
            
            if (minRankSortMode === 0) {
                // 원래 순위 순서로 복원
                dashboardData.standings = [...dashboardData.originalStandings];
            } else if (minRankSortMode === 1) {
                // 최소 가능 순위 오름차순 정렬 (좋은 순위부터)
                dashboardData.standings.sort((a, b) => {
                    // A팀의 최소순위 계산 (전패했을 때)
                    let aMinRank = 1;
                    const aMinWins = a.wins; // A팀 전패시
                    const aMinLosses = a.losses + (144 - a.games_played);
                    const aMinWinRate = aMinWins / (aMinWins + aMinLosses);
                    
                    dashboardData.originalStandings.forEach(team => {
                        if (team.team_name !== a.team_name) {
                            const otherMaxWins = team.wins + (144 - team.games_played); // 상대팀 전승
                            const otherMaxLosses = team.losses;
                            const otherMaxWinRate = otherMaxWins / (otherMaxWins + otherMaxLosses);
                            
                            // KBO 동률 처리 규칙 적용
                            if (aMinWinRate < otherMaxWinRate) {
                                aMinRank++;
                            } else if (Math.abs(aMinWinRate - otherMaxWinRate) < 0.0001) {
                                const aMinMargin = aMinWins - aMinLosses;
                                const otherMaxMargin = otherMaxWins - otherMaxLosses;
                                if (aMinMargin < otherMaxMargin) {
                                    aMinRank++;
                                }
                            }
                        }
                    });
                    
                    // B팀의 최소순위 계산 (전패했을 때)
                    let bMinRank = 1;
                    const bMinWins = b.wins; // B팀 전패시
                    const bMinLosses = b.losses + (144 - b.games_played);
                    const bMinWinRate = bMinWins / (bMinWins + bMinLosses);
                    
                    dashboardData.originalStandings.forEach(team => {
                        if (team.team_name !== b.team_name) {
                            const otherMaxWins = team.wins + (144 - team.games_played); // 상대팀 전승
                            const otherMaxLosses = team.losses;
                            const otherMaxWinRate = otherMaxWins / (otherMaxWins + otherMaxLosses);
                            
                            // KBO 동률 처리 규칙 적용
                            if (bMinWinRate < otherMaxWinRate) {
                                bMinRank++;
                            } else if (Math.abs(bMinWinRate - otherMaxWinRate) < 0.0001) {
                                const bMinMargin = bMinWins - bMinLosses;
                                const otherMaxMargin = otherMaxWins - otherMaxLosses;
                                if (bMinMargin < otherMaxMargin) {
                                    bMinRank++;
                                }
                            }
                        }
                    });
                    
                    return aMinRank - bMinRank;
                });
            } else {
                // 최소 가능 순위 내림차순 정렬 (나쁜 순위부터)
                dashboardData.standings.sort((a, b) => {
                    // A팀의 최소순위 계산 (전패했을 때)
                    let aMinRank = 1;
                    const aMinWins = a.wins; // A팀 전패시
                    const aMinLosses = a.losses + (144 - a.games_played);
                    const aMinWinRate = aMinWins / (aMinWins + aMinLosses);
                    
                    dashboardData.originalStandings.forEach(team => {
                        if (team.team_name !== a.team_name) {
                            const otherMaxWins = team.wins + (144 - team.games_played); // 상대팀 전승
                            const otherMaxLosses = team.losses;
                            const otherMaxWinRate = otherMaxWins / (otherMaxWins + otherMaxLosses);
                            
                            // KBO 동률 처리 규칙 적용
                            if (aMinWinRate < otherMaxWinRate) {
                                aMinRank++;
                            } else if (Math.abs(aMinWinRate - otherMaxWinRate) < 0.0001) {
                                const aMinMargin = aMinWins - aMinLosses;
                                const otherMaxMargin = otherMaxWins - otherMaxLosses;
                                if (aMinMargin < otherMaxMargin) {
                                    aMinRank++;
                                }
                            }
                        }
                    });
                    
                    // B팀의 최소순위 계산 (전패했을 때)
                    let bMinRank = 1;
                    const bMinWins = b.wins; // B팀 전패시
                    const bMinLosses = b.losses + (144 - b.games_played);
                    const bMinWinRate = bMinWins / (bMinWins + bMinLosses);
                    
                    dashboardData.originalStandings.forEach(team => {
                        if (team.team_name !== b.team_name) {
                            const otherMaxWins = team.wins + (144 - team.games_played); // 상대팀 전승
                            const otherMaxLosses = team.losses;
                            const otherMaxWinRate = otherMaxWins / (otherMaxWins + otherMaxLosses);
                            
                            // KBO 동률 처리 규칙 적용
                            if (bMinWinRate < otherMaxWinRate) {
                                bMinRank++;
                            } else if (Math.abs(bMinWinRate - otherMaxWinRate) < 0.0001) {
                                const bMinMargin = bMinWins - bMinLosses;
                                const otherMaxMargin = otherMaxWins - otherMaxLosses;
                                if (bMinMargin < otherMaxMargin) {
                                    bMinRank++;
                                }
                            }
                        }
                    });
                    
                    return bMinRank - aMinRank;
                });
            }
            
            renderFullStandings();
        }

        // 전체 순위표 (모든 지표 포함)
        function renderFullStandings() {
            const tbody = document.getElementById('fullStandingsBody');
            tbody.innerHTML = '';

            // 각 팀의 실제 순위 유지 (정렬과 관계없이 원래 순위 사용)
            dashboardData.standings.forEach((team, index) => {
                // KBO 규정 동률 처리가 적용된 순위 사용
                const teamRanks = getRankingSystem().teamRanks;
                team.displayRank = teamRanks[team.team_name] || (index + 1);
                // 해당 팀의 상세 데이터 찾기
                const teamSummary = dashboardData.teamSummaries?.find(t => t.team_name === team.team_name);
                const pythagorean = dashboardData.pythagoreanAnalysis?.find(t => t.team_name === team.team_name);
                const oneRun = dashboardData.oneRunGames?.find(t => t.team_name === team.team_name);
                const clutchTeamData = clutchData ? clutchData.clutchAnalysis[team.team_name] : null;
                const homeAway = dashboardData.homeAwayStats?.find(t => t.team_name === team.team_name);
                const streak = dashboardData.streakAnalysis?.find(t => t.team_name === team.team_name);

                const row = document.createElement('tr');
                // row.className = index < 3 ? `rank-${index + 1}` : '';
                
                // 연승/연패 색상 클래스 및 표시 텍스트 결정
                let streakClass = 'streak-neutral';
                let streakNum = 0;
                let streakDisplay = team.current_streak || '-';
                
                if (team.current_streak) {
                    // "2W", "3L", "D" 등의 형식 처리
                    const match = team.current_streak.match(/(\d+)([WL])/);
                    
                    if (match) {
                        streakNum = parseInt(match[1]);
                        const streakType = match[2];
                        
                        // 한글로 변환
                        if (streakType === 'W') {
                            streakDisplay = `${streakNum}연승`;
                            if (streakNum >= 3) streakClass = 'streak-hot';
                            else streakClass = 'streak-warm';
                        } else if (streakType === 'L') {
                            streakDisplay = `${streakNum}연패`;
                            if (streakNum >= 3) streakClass = 'streak-cold';
                            else streakClass = 'streak-cool';
                        }
                    } else if (team.current_streak === '0' || team.current_streak === 'D' || team.current_streak.includes('무')) {
                        // 무승부인 경우 - 현재는 데이터에 무승부가 없으므로 임시 처리
                        streakDisplay = '무승부';
                        streakClass = 'streak-neutral';
                    }
                }

                // 승패마진 계산 (승 - 패)
                const winLossMargin = team.wins - team.losses;
                const marginClass = winLossMargin > 0 ? 'positive' : winLossMargin < 0 ? 'negative' : 'neutral';
                
                // 폰트 색상만 적용하는 함수들 (노란색은 중앙값만)
                function getRunDiffColor(runDiff) {
                    if (runDiff >= 100) return '#0d5e1a';  // 매우 좋음 (진한 녹색)
                    if (runDiff >= 50) return '#198f32';   // 좋음 (녹색)
                    if (runDiff >= 20) return '#28a745';   // 약간 좋음 (밝은 녹색)
                    if (runDiff > 0) return '#6c757d';     // 조금 좋음 (회색)
                    if (runDiff === 0) return '#ffc107';   // 중립 (노란색) - 중앙값만
                    if (runDiff > -20) return '#fd7e14';   // 조금 나쁨 (주황색)
                    if (runDiff >= -50) return '#dc3545';  // 약간 나쁨 (빨강)
                    if (runDiff >= -100) return '#c82333'; // 나쁨 (진한 빨강)
                    return '#a71d2a';                       // 매우 나쁨 (매우 진한 빨강)
                }
                
                function getWinRateColor(winRate) {
                    if (winRate >= 0.65) return '#0d5e1a';  // 0.65 이상 (진한 녹색)
                    if (winRate >= 0.6) return '#198f32';   // 0.6~0.65 (녹색)
                    if (winRate >= 0.55) return '#28a745';  // 0.55~0.6 (밝은 녹색)
                    if (winRate > 0.5) return '#6c757d';    // 0.5 초과~0.55 (회색)
                    if (winRate === 0.5) return '#ffc107';  // 정확히 0.5 (노란색) - 중앙값만
                    if (winRate >= 0.45) return '#6c757d';  // 0.45~0.5 미만 (회색)
                    if (winRate >= 0.4) return '#dc3545';   // 0.4~0.45 (빨강)
                    if (winRate >= 0.35) return '#c82333';  // 0.35~0.4 (진한 빨강)
                    return '#a71d2a';                        // 0.35 미만 (매우 진한 빨강)
                }
                
                // 가능한 순위 계산
                const remainingGames = 144 - team.games_played;
                const maxPossibleWins = team.wins + remainingGames; // 전승시
                const minPossibleWins = team.wins; // 전패시
                
                // 최대 가능 순위 (가장 좋은 순위, 숫자가 작음) - 전승했을 때
                let maxRank = 1;
                const myMaxLosses = team.losses; // 내 전승시 패수는 그대로
                const myMaxWinRate = maxPossibleWins / (maxPossibleWins + myMaxLosses); // 내 최고 승률 (무승부 제외)
                
                dashboardData.standings.forEach(otherTeam => {
                    if (otherTeam.team_name === team.team_name) return;
                    const otherMinWins = otherTeam.wins; // 상대팀 전패시
                    const otherMinLosses = otherTeam.losses + (144 - otherTeam.games_played); // 상대팀 전패시 패수
                    const otherMinWinRate = otherMinWins / (otherMinWins + otherMinLosses); // 상대팀 최저 승률 (무승부 제외)
                    
                    // KBO 동률 처리 규칙 적용 (승률 → 승패차 → 상대전적)
                    if (myMaxWinRate < otherMinWinRate) {
                        maxRank++;
                    } else if (Math.abs(myMaxWinRate - otherMinWinRate) < 0.0001) {
                        // 승률이 같을 때 승패차 비교
                        const myMaxMargin = maxPossibleWins - team.losses; // 내 전승시 승패차
                        const otherMinMargin = otherMinWins - otherMinLosses; // 상대 전패시 승패차
                        
                        if (myMaxMargin < otherMinMargin) {
                            maxRank++;
                        }
                        // 승률과 승패차가 모두 같을 경우는 상대전적 고려 필요하지만 복잡하므로 보수적으로 동순위 처리
                    }
                });
                
                // 최소 가능 순위 (가장 나쁜 순위, 숫자가 큼) - 전패했을 때
                let minRank = 1;
                const myMinLosses = team.losses + (144 - team.games_played); // 내 전패시 패수
                const myMinWinRate = minPossibleWins / (minPossibleWins + myMinLosses); // 내 최저 승률 (무승부 제외)
                
                dashboardData.standings.forEach(otherTeam => {
                    if (otherTeam.team_name === team.team_name) return;
                    const otherMaxWins = otherTeam.wins + (144 - otherTeam.games_played); // 상대팀 전승시
                    const otherMaxLosses = otherTeam.losses; // 상대팀 전승시 패수는 그대로
                    const otherMaxWinRate = otherMaxWins / (otherMaxWins + otherMaxLosses); // 상대팀 최고 승률 (무승부 제외)
                    
                    // KBO 동률 처리 규칙 적용 (승률 → 승패차 → 상대전적)
                    if (myMinWinRate < otherMaxWinRate) {
                        minRank++;
                    } else if (Math.abs(myMinWinRate - otherMaxWinRate) < 0.0001) {
                        // 승률이 같을 때 승패차 비교
                        const myMinMargin = minPossibleWins - myMinLosses; // 내 전패시 승패차
                        const otherMaxMargin = otherMaxWins - otherMaxLosses; // 상대 전승시 승패차
                        
                        if (myMinMargin < otherMaxMargin) {
                            minRank++;
                        } else if (Math.abs(myMinMargin - otherMaxMargin) < 0.0001) {
                            // 승률과 승패차가 모두 같을 경우, 상대전적으로 결정되므로 최악의 경우 가정
                            minRank++; // 보수적으로 상대방이 위에 있다고 가정 (최소순위는 가장 나쁜 경우)
                        }
                    }
                });
                
                // 순위는 10위를 넘을 수 없음
                maxRank = Math.min(maxRank, 10);
                minRank = Math.min(minRank, 10);
                
                row.innerHTML = `
                    <td class="${team.displayRank <= 3 ? `rank-${team.displayRank}` : ''}"><strong>${team.displayRank}</strong></td>
                    <td class="team-name"><strong>${getTeamWithLogo(team.team_name, 'team-logo-small')}</strong></td>
                    <td>${team.games_played}</td>
                    <td>${team.wins}</td>
                    <td>${team.losses}</td>
                    <td>${team.draws}</td>
                    <td class="${marginClass}" style="font-weight: 600;">${winLossMargin > 0 ? '+' : ''}${winLossMargin}</td>
                    <td><strong>${parseFloat(team.win_rate).toFixed(3)}</strong></td>
                    <td>${team.games_behind}</td>
                    <td>${144 - team.games_played}</td>
                    <td>${formatRecent10(team.recent10 || team.team_recent10)}</td>
                    <td class="${streakClass}">${streakDisplay}</td>
                    <td>${team.homeRecord || team.home_record || '-'}</td>
                    <td>${team.homeWinRate !== undefined ? team.homeWinRate.toFixed(3) : (team.home_win_rate || '-')}</td>
                    <td>${team.awayRecord || team.away_record || '-'}</td>
                    <td>${team.awayWinRate !== undefined ? team.awayWinRate.toFixed(3) : (team.away_win_rate || '-')}</td>
                    <td>${streak ? streak.max_win_streak : '-'}</td>
                    <td>${streak ? streak.max_lose_streak : '-'}</td>
                    <td>${maxRank}</td>
                    <td>${minRank}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // 피타고리안 테이블 정렬 함수
        let pythagoreanSortState = { column: null, direction: 'asc' };
        
        function sortPythagoreanTable(column) {
            if (!dashboardData || !dashboardData.standings) {
                alert('데이터가 로드되지 않았습니다');
                return;
            }
            
            // 정렬 방향 결정
            if (pythagoreanSortState.column === column) {
                pythagoreanSortState.direction = pythagoreanSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                pythagoreanSortState.column = column;
                pythagoreanSortState.direction = 'desc'; // 득점/실점은 기본적으로 내림차순
            }
            
            // 정렬할 데이터 준비 (종합 순위 기준으로)
            const teams = getRankingSystem().teams;
            const teamsToSort = teams.map(teamName => {
                const team = dashboardData.standings.find(t => t.team_name === teamName);
                if (!team) return null;
                const runsScored = team.runsScored || team.runs_scored || 0;
                const runsAllowed = team.runsAllowed || team.runs_allowed || 0;
                const runDiff = team.runDiff || team.run_differential || (runsScored - runsAllowed);
                
                // 기대 득실차 계산
                const totalWinLossGames = (team.wins || 0) + (team.losses || 0);
                const expectedRunDiff = team.pythagoreanWinRate && totalWinLossGames > 0 ? 
                    Math.round((team.pythagoreanWinRate - 0.5) * totalWinLossGames * 3) : 0; // 평균 3점차 가정
                
                return {
                    team_name: teamName,
                    runsScored: runsScored,
                    runsAllowed: runsAllowed,
                    runDiff: runDiff,
                    expectedRunDiff: expectedRunDiff,
                    pythagoreanWinRate: team.pythagoreanWinRate || 0,
                    luckIndex: team.luckIndex || 0,
                    luckRating: team.luckRating || '-',
                    // 기존 데이터도 포함
                    wins: team.wins,
                    losses: team.losses,
                    draws: team.draws,
                    winRate: parseFloat(team.win_rate) || 0,
                    win_rate: team.win_rate,
                    rank: team.rank
                };
            }).filter(Boolean); // null 값 제거
            
            // 정렬 실행
            teamsToSort.sort((a, b) => {
                let valueA, valueB;
                
                if (column === 'actualWins') {
                    valueA = a.wins || 0;
                    valueB = b.wins || 0;
                } else if (column === 'actualLosses') {
                    valueA = a.losses || 0;
                    valueB = b.losses || 0;
                } else if (column === 'actualDraws') {
                    valueA = a.draws || 0;
                    valueB = b.draws || 0;
                } else if (column === 'expectedWins') {
                    const totalGamesA = (a.wins || 0) + (a.losses || 0) + (a.draws || 0);
                    const winLossGamesA = totalGamesA - (a.draws || 0);
                    valueA = Math.round(winLossGamesA * (a.pythagoreanWinRate || 0));
                    const totalGamesB = (b.wins || 0) + (b.losses || 0) + (b.draws || 0);
                    const winLossGamesB = totalGamesB - (b.draws || 0);
                    valueB = Math.round(winLossGamesB * (b.pythagoreanWinRate || 0));
                } else if (column === 'expectedLosses') {
                    const totalGamesA = (a.wins || 0) + (a.losses || 0) + (a.draws || 0);
                    const winLossGamesA = totalGamesA - (a.draws || 0);
                    const expectedWinsA = Math.round(winLossGamesA * (a.pythagoreanWinRate || 0));
                    valueA = winLossGamesA - expectedWinsA;
                    const totalGamesB = (b.wins || 0) + (b.losses || 0) + (b.draws || 0);
                    const winLossGamesB = totalGamesB - (b.draws || 0);
                    const expectedWinsB = Math.round(winLossGamesB * (b.pythagoreanWinRate || 0));
                    valueB = winLossGamesB - expectedWinsB;
                } else if (column === 'expectedDraws') {
                    valueA = a.draws || 0;
                    valueB = b.draws || 0;
                } else if (column === 'actualWinRate') {
                    valueA = a.winRate || 0;
                    valueB = b.winRate || 0;
                } else if (column === 'expectedWinRate') {
                    valueA = a.pythagoreanWinRate || 0;
                    valueB = b.pythagoreanWinRate || 0;
                } else if (column === 'luckStatus') {
                    const luckValueA = a.luckIndex || 0;
                    const luckValueB = b.luckIndex || 0;
                    valueA = luckValueA;
                    valueB = luckValueB;
                } else if (column === 'runsScored') {
                    valueA = a.runsScored || 0;
                    valueB = b.runsScored || 0;
                } else if (column === 'runsAllowed') {
                    valueA = a.runsAllowed || 0;
                    valueB = b.runsAllowed || 0;
                } else if (column === 'luckIndex') {
                    valueA = a.luckIndex || 0;
                    valueB = b.luckIndex || 0;
                } else if (column === 'runDiff') {
                    valueA = a.runDiff || 0;
                    valueB = b.runDiff || 0;
                } else if (column === 'expectedRunDiff') {
                    valueA = a.expectedRunDiff || 0;
                    valueB = b.expectedRunDiff || 0;
                } else {
                    // 기본 정렬 (순위)
                    valueA = a.rank || 99;
                    valueB = b.rank || 99;
                }
                
                // 값이 같으면 팀명으로 보조 정렬
                if (valueA === valueB) {
                    return a.team_name.localeCompare(b.team_name);
                }
                
                if (pythagoreanSortState.direction === 'desc') {
                    return valueB - valueA;
                } else {
                    return valueA - valueB;
                }
            });
            
            // 테이블 다시 렌더링
            renderPythagoreanTableWithSortedData(teamsToSort);
        }
        
        // 정렬된 데이터로 피타고리안 테이블 렌더링
        function renderPythagoreanTableWithSortedData(sortedTeams) {
            const tbody = document.getElementById('pythagoreanBody');
            tbody.innerHTML = '';
            
            const ranking = getRankingSystem();
            
            sortedTeams.forEach((team, index) => {
                // 통합된 순위 시스템에서 순위 가져오기
                const rank = ranking.teamRanks[team.team_name] || 999;
                
                // 실제 기록
                const actualWins = team.wins || 0;
                const actualDraws = team.draws || 0;
                const actualLosses = team.losses || 0;
                const totalGames = actualWins + actualDraws + actualLosses;
                
                // 피타고리안 데이터
                const expectedWinRate = team.pythagoreanWinRate || 0;
                const actualWinRate = parseFloat(team.win_rate) || team.winRate || 0;
                
                // 기대 기록 계산
                const winLossGames = totalGames - actualDraws;
                const finalExpectedWins = Math.round(winLossGames * expectedWinRate);
                const finalExpectedLosses = winLossGames - finalExpectedWins;
                const finalExpectedDraws = actualDraws;
                
                // 득실점 및 득실차 계산
                const actualRunsScored = team.runsScored || 0;
                const actualRunsAllowed = team.runsAllowed || 0;
                const actualRunDiff = team.runDiff || (actualRunsScored - actualRunsAllowed);
                const expectedRunDiff = team.expectedRunDiff || 0;

                const row = document.createElement('tr');
                
                // 운지수 색상 클래스
                function getLuckClass(luckValue) {
                    if (luckValue >= 0.05) return 'positive-very-strong';
                    if (luckValue >= 0.03) return 'positive-strong';
                    if (luckValue >= 0.01) return 'positive-light';
                    if (luckValue >= -0.01 && luckValue <= 0.01) return 'neutral-medium';
                    if (luckValue >= -0.03) return 'negative-light';
                    if (luckValue >= -0.05) return 'negative-strong';
                    return 'negative-very-strong';
                }
                
                const luckClass = getLuckClass(team.luckIndex || 0);
                
                row.innerHTML = `
                    <td class="rank-${rank <= 3 ? rank : 'other'}" style="font-weight: var(--font-weight-bold); text-align: center;">${rank}</td>
                    <td class="team-name"><strong>${getTeamWithLogo(team.team_name, 'team-logo-small')}</strong></td>
                    <td><strong>${actualWins}</strong></td>
                    <td>${actualLosses}</td>
                    <td>${actualDraws}</td>
                    <td style="color: #007bff;">${finalExpectedWins}</td>
                    <td style="color: #007bff;">${finalExpectedLosses}</td>
                    <td style="color: #007bff;">${finalExpectedDraws}</td>
                    <td><strong>${parseFloat(actualWinRate).toFixed(3)}</strong></td>
                    <td style="color: #007bff;">${expectedWinRate.toFixed(3)}</td>
                    <td class="${luckClass}"><strong>${team.luckIndex ? (team.luckIndex > 0 ? '+' : '') + team.luckIndex.toFixed(3) : '-'}</strong></td>
                    <td class="${luckClass}" style="white-space: nowrap;">${team.luckRating || '-'}</td>
                    <td><strong>${actualRunsScored || '-'}</strong></td>
                    <td><strong>${actualRunsAllowed || '-'}</strong></td>
                    <td><strong>${actualRunDiff >= 0 ? '+' : ''}${actualRunDiff}</strong></td>
                    <td style="color: #007bff;">${expectedRunDiff >= 0 ? '+' : ''}${expectedRunDiff}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // 피타고리안 전체 분석
        function renderPythagoreanFullAnalysis() {
            const tbody = document.getElementById('pythagoreanBody');
            tbody.innerHTML = '';

            if (!dashboardData || !dashboardData.standings) {
                tbody.innerHTML = '<tr><td colspan="16" style="text-align: center; padding: 20px;">데이터를 불러오는 중...</td></tr>';
                return;
            }

            // 통합된 순위 시스템 사용
            const ranking = getRankingSystem();
            const sortedTeams = ranking.teams.map(teamName => 
                dashboardData.standings.find(t => t.team_name === teamName)
            ).filter(Boolean);
            
            sortedTeams.forEach((team, index) => {
                // 통합된 순위 시스템에서 순위 가져오기
                const rank = ranking.teamRanks[team.team_name] || 999;
                
                // 실제 기록 (stats-comprehensive.json 필드명 사용)
                const actualWins = team.wins || 0;
                const actualDraws = team.draws || 0;
                const actualLosses = team.losses || 0;
                const totalGames = actualWins + actualDraws + actualLosses;
                
                // 피타고리안 데이터 (이미 계산된 값 사용)
                const expectedWinRate = team.pythagoreanWinRate || 0;
                const actualWinRate = parseFloat(team.win_rate) || 0;
                
                // 기대 기록 계산 (올바른 방식)
                // 무승부는 실제값 유지, 승패만 피타고리안으로 계산
                const winLossGames = totalGames - actualDraws;
                const finalExpectedWins = Math.round(winLossGames * expectedWinRate);
                const finalExpectedLosses = winLossGames - finalExpectedWins;
                const finalExpectedDraws = actualDraws;
                
                // 득실점 및 득실차 계산
                const actualRunsScored = team.runsScored || team.runs_scored || 0;
                const actualRunsAllowed = team.runsAllowed || team.runs_allowed || 0;
                const actualRunDiff = team.runDiff || team.run_differential || (actualRunsScored - actualRunsAllowed);
                
                // 기대 득실차 계산 (피타고리안 승률 기준)
                const totalWinLossGames = actualWins + actualLosses;
                const expectedRunDiff = totalWinLossGames > 0 ? 
                    Math.round((expectedWinRate - 0.5) * totalWinLossGames * 3) : 0; // 평균 3점차 가정

                const row = document.createElement('tr');
                // 운지수 그라데이션 색상 함수 (차이값 기준)
                function getLuckClass(luckValue) {
                    if (luckValue >= 0.05) return 'positive-very-strong';  // 매우 운이 좋음
                    if (luckValue >= 0.03) return 'positive-strong';       // 운이 좋음
                    if (luckValue >= 0.01) return 'positive-light';        // 약간 운이 좋음
                    if (luckValue >= -0.01 && luckValue <= 0.01) return 'neutral-medium';  // 평균적
                    if (luckValue >= -0.03) return 'negative-light';       // 약간 운이 나쁨
                    if (luckValue >= -0.05) return 'negative-strong';      // 운이 나쁨
                    return 'negative-very-strong';                         // 매우 운이 나쁨
                }
                
                const luckClass = getLuckClass(team.luckIndex || 0);
                
                row.innerHTML = `
                    <td class="rank-${rank <= 3 ? rank : 'other'}" style="font-weight: var(--font-weight-bold); text-align: center;">${rank}</td>
                    <td class="team-name"><strong>${getTeamWithLogo(team.team_name, 'team-logo-small')}</strong></td>
                    <td><strong>${actualWins}</strong></td>
                    <td>${actualLosses}</td>
                    <td>${actualDraws}</td>
                    <td style="color: #007bff;">${finalExpectedWins}</td>
                    <td style="color: #007bff;">${finalExpectedLosses}</td>
                    <td style="color: #007bff;">${finalExpectedDraws}</td>
                    <td><strong>${actualWinRate.toFixed(3)}</strong></td>
                    <td style="color: #007bff;">${expectedWinRate.toFixed(3)}</td>
                    <td class="${luckClass}"><strong>${team.luckIndex ? (team.luckIndex > 0 ? '+' : '') + team.luckIndex.toFixed(3) : '-'}</strong></td>
                    <td class="${luckClass}" style="white-space: nowrap;">${team.luckRating || '-'}</td>
                    <td><strong>${actualRunsScored || '-'}</strong></td>
                    <td><strong>${actualRunsAllowed || '-'}</strong></td>
                    <td><strong>${actualRunDiff >= 0 ? '+' : ''}${actualRunDiff}</strong></td>
                    <td style="color: #007bff;">${expectedRunDiff >= 0 ? '+' : ''}${expectedRunDiff}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // 클러치 상황 전체 분석
        async function renderClutchFullAnalysis() {
            try {
                const response = await fetch(`magic-number/data/analysis-clutch.json?v=${Date.now()}`);
                clutchData = await response.json();
                
                const tbody = document.getElementById('clutchBody');
                tbody.innerHTML = '';

                // 통합된 순위 시스템 사용
                const ranking = getRankingSystem();
                const teams = ranking.teams.filter(teamName => 
                    clutchData.clutchAnalysis[teamName]
                );

                teams.forEach((teamName, index) => {
                    const team = clutchData.clutchAnalysis[teamName];
                    // 통합된 순위 시스템에서 순위 가져오기
                    const rank = ranking.teamRanks[teamName] || 999;
                    
                    const row = document.createElement('tr');
                    
                    
                    const oneRunWinRateValue = parseFloat(team.oneRunWinRate);
                    const normalizedOneRunRate = oneRunWinRateValue > 1 ? oneRunWinRateValue / 100 : oneRunWinRateValue;
                    const oneRunClass = getWinRateClass(normalizedOneRunRate);
                    
                    const clutchIndexValue = parseFloat(team.clutchIndex) / 100; // 클러치 지수는 이미 백분율
                    const clutchClass = getWinRateClass(clutchIndexValue);
                    
                    // 3점차 승률 계산 및 클래스 설정
                    const threeRunWinRateValue = parseFloat(team.threeRunWinRate || '0');
                    const normalizedThreeRunRate = threeRunWinRateValue > 1 ? threeRunWinRateValue / 100 : threeRunWinRateValue;
                    const threeRunClass = getWinRateClass(normalizedThreeRunRate);
                    
                    row.innerHTML = `
                        <td class="rank-${rank <= 3 ? rank : 'other'}" style="font-weight: var(--font-weight-bold); text-align: center;">${rank}</td>
                        <td class="team-name">${getTeamWithLogo(teamName)}</td>
                        <td>${team.oneRunWins}</td>
                        <td>${team.oneRunLosses}</td>
                        <td class="${oneRunClass}"><strong>${normalizedOneRunRate.toFixed(3)}</strong></td>
                        <td>${team.threeRunWins || 0}</td>
                        <td>${team.threeRunLosses || 0}</td>
                        <td class="${threeRunClass}"><strong>${normalizedThreeRunRate.toFixed(3)}</strong></td>
                        <td>${team.blowoutWins}</td>
                        <td>${team.blowoutLosses}</td>
                        <td>${team.shutoutWins}</td>
                        <td>${team.shutoutLosses}</td>
                        <td class="${clutchClass}"><strong>${team.clutchIndex}</strong></td>
                    `;
                    tbody.appendChild(row);
                });
            } catch (error) {
                console.error('클러치 분석 데이터 로드 실패:', error);
                document.getElementById('clutchBody').innerHTML = '<tr><td colspan="13" style="text-align: center; padding: 20px; color: #e74c3c;">클러치 분석 데이터를 로드할 수 없습니다.</td></tr>';
            }
        }

        // 홈/원정 전체 분석
        async function renderHomeAwayFullAnalysis() {
            try {
                const response = await fetch(`magic-number/data/analysis-home-away.json?v=${Date.now()}`);
                const homeAwayData = await response.json();
                
                const tbody = document.getElementById('homeAwayBody');
                tbody.innerHTML = '';

                // 통합된 순위 시스템 사용
                const ranking = getRankingSystem();
                const teams = ranking.teams.filter(teamName => 
                    homeAwayData.homeAwayAnalysis[teamName]
                );

                const stadiumMap = {
                    'KIA': '광주 챔피언스필드',
                    'LG': '서울 잠실야구장',
                    '두산': '서울 잠실야구장',
                    '삼성': '대구 삼성라이온즈파크',
                    'SSG': '인천 SSG랜더스필드',
                    'KT': '수원 KT위즈파크',
                    '한화': '대전 한화생명이글스파크',
                    'NC': '창원 NC파크',
                    '롯데': '부산 사직야구장',
                    '키움': '서울 고척스카이돔'
                };

                teams.forEach((teamName, index) => {
                    const team = homeAwayData.homeAwayAnalysis[teamName];
                    const row = document.createElement('tr');
                    
                    // 통합된 순위 시스템에서 순위 가져오기
                    const rank = ranking.teamRanks[teamName] || 999;
                    
                    const homeAdvantageValue = parseFloat(team.homeAdvantage);
                    const normalizedAdvantage = Math.abs(homeAdvantageValue) > 1 ? homeAdvantageValue / 100 : homeAdvantageValue;
                    
                    // 홈 어드밴티지 0 기준 그라데이션 함수
                    function getHomeAdvantageClass(advantage) {
                        if (advantage >= 0.15) return 'positive-very-strong';  // +0.15 이상 - 가장 진한 녹색
                        if (advantage >= 0.10) return 'positive-strong';       // +0.10~0.15 - 진한 녹색
                        if (advantage >= 0.05) return 'positive-medium';       // +0.05~0.10 - 보통 녹색
                        if (advantage > 0) return 'positive-light';            // 0 초과~0.05 - 연한 녹색
                        if (advantage === 0) return 'neutral-medium';          // 정확히 0 - 중립
                        if (advantage >= -0.05) return 'negative-light';       // -0.05~0 - 연한 빨강
                        if (advantage >= -0.10) return 'negative-medium';      // -0.10~-0.05 - 보통 빨강
                        if (advantage >= -0.15) return 'negative-strong';      // -0.15~-0.10 - 진한 빨강
                        return 'negative-very-strong';                         // -0.15 미만 - 가장 진한 빨강
                    }
                    
                    const homeAdvantageClass = getHomeAdvantageClass(normalizedAdvantage);
                    
                    const homeWinRateValue = parseFloat(team.home.winRate);
                    const normalizedHomeRate = homeWinRateValue > 1 ? homeWinRateValue / 100 : homeWinRateValue;
                    const awayWinRateValue = parseFloat(team.away.winRate);
                    const normalizedAwayRate = awayWinRateValue > 1 ? awayWinRateValue / 100 : awayWinRateValue;
                    
                    const homeWinRateClass = getWinRateClass(normalizedHomeRate);
                    const awayWinRateClass = getWinRateClass(normalizedAwayRate);
                    
                    row.innerHTML = `
                        <td class="rank-${rank <= 3 ? rank : 'other'}" style="font-weight: var(--font-weight-bold); text-align: center;">${rank}</td>
                        <td class="team-name">${getTeamWithLogo(teamName)}</td>
                        <td>${team.home.games}</td>
                        <td>${team.home.wins}</td>
                        <td>${team.home.losses}</td>
                        <td>${team.home.draws || 0}</td>
                        <td class="${homeWinRateClass} baseball-winrate-cell"><strong>${normalizedHomeRate.toFixed(3)}</strong></td>
                        <td>${team.away.games}</td>
                        <td>${team.away.wins}</td>
                        <td>${team.away.losses}</td>
                        <td>${team.away.draws || 0}</td>
                        <td class="${awayWinRateClass} baseball-winrate-cell"><strong>${normalizedAwayRate.toFixed(3)}</strong></td>
                        <td class="${homeAdvantageClass} baseball-winrate-cell"><strong>${normalizedAdvantage.toFixed(4)}</strong></td>
                        <td style="font-size: var(--font-sm);">${stadiumMap[teamName] || '-'}</td>
                    `;
                    tbody.appendChild(row);
                });
            } catch (error) {
                console.error('홈/원정 분석 데이터 로드 실패:', error);
                document.getElementById('homeAwayBody').innerHTML = '<tr><td colspan="14" style="text-align: center; padding: 20px; color: #e74c3c;">홈/원정 분석 데이터를 로드할 수 없습니다.</td></tr>';
            }
        }

        // 상대전적 매트릭스
        async function renderHeadToHeadMatrix() {
            const container = document.getElementById('matrixContent');
            
            // calc-head-to-head.json 데이터 로드
            let recordsData = null;
            try {
                const response = await fetch(`magic-number/data/calc-head-to-head.json?v=${Date.now()}`);
                recordsData = await response.json();
            } catch (error) {
                console.error('❌ calc-head-to-head.json 로드 실패:', error);
            }
            
            // 종합 순위 기준 팀 순서 사용 (KBO 규정 동률 처리 반영)
            const rankedTeams = getRankingSystem().teams;
            
            let html = '<div>';
            
            // 전체 매트릭스만 표시
            html += '<table class="matrix-table"><thead><tr><th>vs</th>';
            rankedTeams.forEach(team => {
                html += `<th><strong>${getTeamWithLogo(team, 'team-logo-small')}</strong></th>`;
            });
            html += '</tr></thead><tbody>';
            
            rankedTeams.forEach(team1 => {
                html += `<tr><th><strong>${getTeamWithLogo(team1, 'team-logo-small')}</strong></th>`;
                rankedTeams.forEach(team2 => {
                    html += renderMatrixCell(team1, team2, recordsData);
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            
            html += '</div>';
            html += '</div>';
            container.innerHTML = html;
        }

        // 팀간 잔여경기수 매트릭스 렌더링
        async function renderRemainingGamesMatrix() {
            const container = document.getElementById('remainingGamesContent');
            
            // calc-head-to-head.json 데이터 로드
            let recordsData = null;
            try {
                const response = await fetch(`magic-number/data/calc-head-to-head.json?v=${Date.now()}`);
                recordsData = await response.json();
            } catch (error) {
                console.error('❌ 잔여경기수용 calc-head-to-head.json 로드 실패:', error);
            }
            
            // 종합 순위 기준 팀 순서 사용 (KBO 규정 동률 처리 반영)
            const rankedTeams = getRankingSystem().teams;
            
            let html = '<div>';
            
            // 잔여경기수 매트릭스
            html += '<table class="matrix-table"><thead><tr><th>vs</th>';
            
            rankedTeams.forEach(team => {
                html += `<th><strong>${getTeamWithLogo(team, 'team-logo-small')}</strong></th>`;
            });
            html += '</tr></thead><tbody>';
            
            // 잔여경기수 계산 및 표시
            rankedTeams.forEach(team1 => {
                html += `<tr><th><strong>${getTeamWithLogo(team1, 'team-logo-small')}</strong></th>`;
                rankedTeams.forEach(team2 => {
                    html += renderRemainingGamesCell(team1, team2, recordsData);
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        // 매트릭스 셀 렌더링 함수 (calc-head-to-head.json 데이터 사용)
        function renderMatrixCell(team1, team2, recordsData) {
            if (team1 === team2) {
                return '<td style="background: #ecf0f1; color: #999; font-weight: var(--font-weight-semibold); font-size: var(--font-xl);">-</td>';
            }
            
            // calc-head-to-head.json에서 데이터 찾기
            if (recordsData && recordsData.totalData && recordsData.totalData[team1] && recordsData.totalData[team1][team2]) {
                const record = recordsData.totalData[team1][team2];
                
                const wins = record.wins || 0;
                const losses = record.losses || 0;
                const draws = record.draws || 0;
                
                const homeWins = record.homeWins || 0;
                const homeLosses = record.homeLosses || 0;
                const homeDraws = record.homeDraws || 0;
                
                const awayWins = record.awayWins || 0;
                const awayLosses = record.awayLosses || 0;
                const awayDraws = record.awayDraws || 0;
                
                // 승률 계산
                const totalGames = wins + losses;
                const winRate = totalGames > 0 ? wins / totalGames : 0;
                
                const homeGames = homeWins + homeLosses;
                const homeWinRate = homeGames > 0 ? homeWins / homeGames : 0;
                
                const awayGames = awayWins + awayLosses;
                const awayWinRate = awayGames > 0 ? awayWins / awayGames : 0;
                
                // 상대전적 우위/열세 판단 (확정된 경우만)
                let starIcon = '';
                let fontSize = 'var(--font-base)';
                
                // 전체 경기수 (보통 16경기)
                const totalGamesPlayed = wins + losses + draws;
                const remainingGames = Math.max(0, 16 - totalGamesPlayed);
                
                // 우위/열세 확정 조건 체크
                if (wins >= 9) {
                    // 9승 이상 = 상대전적 우위 확정
                    starIcon = '⭐ ';
                    fontSize = 'var(--font-sm)';
                } else if (losses >= 9) {
                    // 9패 이상 = 상대전적 열세 확정
                    starIcon = '🔻 ';
                    fontSize = 'var(--font-sm)';
                } else if (remainingGames > 0) {
                    // 남은 경기가 있는 경우: 남은 경기를 모두 이겨도 상대를 넘을 수 없으면 열세 확정
                    const maxPossibleWins = wins + remainingGames;
                    const opponentMinLosses = losses; // 상대방 최소 패수 (현재 내가 진 횟수)
                    
                    if (maxPossibleWins < opponentMinLosses) {
                        // 내가 남은 경기를 모두 이겨도 상대방이 나보다 많이 이김 = 열세 확정
                        starIcon = '🔻 ';
                        fontSize = 'var(--font-sm)';
                    } else if (wins > losses + remainingGames) {
                        // 상대가 남은 경기를 모두 이겨도 내가 더 많이 이김 = 우위 확정
                        starIcon = '⭐ ';
                        fontSize = 'var(--font-sm)';
                    }
                }
                
                // 통합 색상 관리 함수 사용
                const cellStyle = getUnifiedCellStyle(winRate);
                const backgroundColor = cellStyle.backgroundColor;
                const textColor = cellStyle.textColor;

                return `<td style="background: ${backgroundColor}; color: ${textColor}; padding: 4px 0px;">
                    <div style="font-size: var(--font-base); line-height: 1.3; text-align: center;">
                        <div style="font-weight: var(--font-weight-bold); font-size: ${fontSize}; margin-bottom: 4px; color: ${textColor};">${starIcon}${wins}-${losses}-${draws} (${winRate.toFixed(3)})</div>
                        <div style="font-size: var(--font-xs); color: ${textColor}; margin-bottom: 2px;">🏠 ${homeWins}-${homeLosses}-${homeDraws} (${homeWinRate.toFixed(3)})</div>
                        <div style="font-size: var(--font-xs); color: ${textColor};">✈️ ${awayWins}-${awayLosses}-${awayDraws} (${awayWinRate.toFixed(3)})</div>
                    </div>
                </td>`;
            } else {
                return '<td style="color: #999; font-weight: var(--font-weight-medium);">0승 0패<br><span style="font-size: var(--font-2xs);">(0.000)</span></td>';
            }
        }

        // 잔여경기수 셀 렌더링 함수
        function renderRemainingGamesCell(team1, team2, recordsData) {
            if (team1 === team2) {
                return '<td style="background: #ecf0f1; color: #999; font-weight: var(--font-weight-semibold); font-size: var(--font-xl);">-</td>';
            }
            
            // recordsData가 있고 데이터가 있는 경우 (totalData 객체 확인)
            const data = recordsData?.totalData || recordsData;
            
            // 디버깅용 로그 (첫 번째 호출 시만)
            if (team1 === 'LG' && team2 === '한화') {
            }
            
            if (data && data[team1] && data[team1][team2]) {
                const record = data[team1][team2];
                const wins = parseInt(record.wins) || 0;
                const losses = parseInt(record.losses) || 0;
                const draws = parseInt(record.draws) || 0;
                
                const playedGames = wins + losses + draws;
                const totalGamesPerOpponent = 16; // KBO 정규시즌 팀당 16경기
                const remainingGames = Math.max(0, totalGamesPerOpponent - playedGames);
                
                // 색상 설정
                let backgroundColor;
                let textColor = '#333';
                
                if (remainingGames === 0) {
                    backgroundColor = 'rgba(156, 163, 175, 0.6)'; // 회색 - 경기 종료
                    textColor = '#666';
                } else if (remainingGames <= 3) {
                    backgroundColor = 'rgba(249, 115, 22, 0.6)'; // 주황색 - 적은 경기 남음
                } else if (remainingGames <= 6) {
                    backgroundColor = 'rgba(234, 179, 8, 0.6)'; // 노란색 - 보통
                } else {
                    backgroundColor = 'rgba(34, 197, 94, 0.6)'; // 초록색 - 많은 경기 남음
                }
                
                return `<td style="background: ${backgroundColor}; color: ${textColor}; font-weight: var(--font-weight-semibold); font-size: var(--font-md); text-align: center;">${remainingGames}</td>`;
            }
            
            // 데이터가 없는 경우
            return '<td style="background: #f8f9fa; color: #999; text-align: center;">-</td>';
        }
        
        // 월별 성적 전체 분석 (행/열 반전)
        function renderMonthlyFullAnalysis() {
            const thead = document.getElementById('monthlyTableHead');
            const tbody = document.getElementById('monthlyBody');
            thead.innerHTML = '';
            tbody.innerHTML = '';
            
            // 종합 순위 기준 팀 순서 사용 (KBO 규정 동률 처리 반영)
            const rankedTeams = getRankingSystem().teams;
            
            // 헤더 생성: 월 + 각 팀 (로고와 함께) - 성적(승률) 통합
            const headerRow = document.createElement('tr');
            
            headerRow.innerHTML = `
                <th style="min-width: 70px; vertical-align: middle; font-size: var(--font-base); white-space: nowrap; cursor: pointer;" onclick="sortMonthlyByMonth()">월</th>
                ${rankedTeams.map(team => `<th style="min-width: 100px; font-size: var(--font-sm); white-space: nowrap; padding: 6px 2px; cursor: pointer;" onclick="sortMonthlyByTeam('${team}')">${getTeamWithLogo(team, 'team-logo-small')}</th>`).join('')}
            `;
            
            thead.appendChild(headerRow);
            
            // 실제 데이터가 있는 월만 표시
            const allMonths = [3, 4, 5, 6, 7, 8, 9, 10];
            const allMonthNames = ['3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월'];
            
            // 데이터가 있는 월만 필터링
            const months = [];
            const monthNames = [];
            allMonths.forEach((monthNum, index) => {
                // 어떤 팀이든 해당 월에 데이터가 있으면 포함
                const hasData = rankedTeams.some(team => {
                    const monthlyData = dashboardData.monthlyPerformance[team];
                    const monthData = monthlyData?.find(month => month.month === monthNum);
                    return monthData && monthData.wins + monthData.losses > 0;
                });
                
                if (hasData) {
                    months.push(monthNum);
                    monthNames.push(allMonthNames[index]);
                }
            });
            
            // 먼저 팀별 데이터를 미리 계산 (최고월/최저월 판단용)
            const teamStats = {};
            rankedTeams.forEach(team => {
                const monthlyData = dashboardData.monthlyPerformance[team];
                const validMonths = monthlyData.filter(month => month.wins + month.losses > 0);
                
                if (validMonths.length > 0) {
                    const teamRates = validMonths.map(month => ({
                        rate: parseFloat(month.win_rate),
                        month: month.month,
                        record: `${month.wins}-${month.losses}${month.draws ? '-' + month.draws : ''}`,
                        wins: month.wins,
                        losses: month.losses,
                        draws: month.draws || 0
                    }));
                    
                    const bestMonth = teamRates.reduce((best, current) => current.rate > best.rate ? current : best);
                    const worstMonth = teamRates.reduce((worst, current) => current.rate < worst.rate ? current : worst);
                    
                    teamStats[team] = {
                        bestMonth: bestMonth,
                        worstMonth: worstMonth
                    };
                }
            });

            months.forEach((monthNum, index) => {
                const row = document.createElement('tr');
                let html = `<td class="month-label" style="cursor: pointer;" onclick="sortMonthlyByRate(${monthNum})"><strong>${monthNames[index]}</strong></td>`;
                
                let monthRates = []; // 해당 월의 모든 팀 승률
                
                // 각 팀의 해당 월 데이터 - 승패와 승률 분리
                rankedTeams.forEach(team => {
                    const monthlyData = dashboardData.monthlyPerformance[team];
                    const monthData = monthlyData?.find(month => month.month === monthNum);
                    
                    if (monthData && monthData.wins + monthData.losses > 0) {
                        const winRate = parseFloat(monthData.win_rate);
                        monthRates.push(winRate);
                        const winRateClass = getWinRateClass(winRate);
                        
                        const games = monthData.games || (monthData.wins + monthData.losses + (monthData.draws || 0));
                        const record = `${monthData.wins}-${monthData.losses}-${monthData.draws || 0}`;
                        
                        // 최고월/최저월 확인
                        const isBestMonth = teamStats[team] && teamStats[team].bestMonth.month === monthNum;
                        const isWorstMonth = teamStats[team] && teamStats[team].worstMonth.month === monthNum;
                        
                        // 통합 색상 관리 함수 사용
                        let cellStyle = getUnifiedCellStyle(winRate);
                        let backgroundColor = cellStyle.backgroundColor;
                        let textColor = cellStyle.textColor;
                        
                        // 최고월/최저월 특별 처리
                        if (isBestMonth) {
                            backgroundColor = colorScheme.positive.bgStrong; // 최고월 - 연한 초록
                            textColor = colorScheme.positive.color;
                        } else if (isWorstMonth) {
                            backgroundColor = colorScheme.negative.bgStrong;  // 최저월 - 연한 빨강
                            textColor = colorScheme.negative.color;
                        }
                        
                        const cellStyleString = `background: ${backgroundColor}; color: ${textColor}; padding: 8px;`;
                        
                        // 승률에 따른 클래스 결정
                        const monthWinRateClass = getWinRateClass(winRate);
                        
                        html += `
                            <td style="${cellStyleString} white-space: nowrap; font-size: var(--font-sm); padding: 8px; text-align: center; line-height: 1.3;">
                                <div style="font-weight: var(--font-weight-semibold); margin-bottom: 1px;">${record} (${winRate.toFixed(3)})</div>
                                <div style="font-size: var(--font-xs); margin-top: 2px;">${games}경기</div>
                            </td>
                        `;
                    } else {
                        html += '<td class="month-data" style="background: #f8f9fa; color: #999; padding: 6px 2px; white-space: nowrap; font-size: var(--font-xs); text-align: center;">-</td>';
                    }
                });
                
                
                row.innerHTML = html;
                tbody.appendChild(row);
            });
            
            // 평균 승률 계산 추가
            rankedTeams.forEach(team => {
                if (teamStats[team]) {
                    const monthlyData = dashboardData.monthlyPerformance[team];
                    const validMonths = monthlyData.filter(month => month.wins + month.losses > 0);
                    const teamRates = validMonths.map(month => parseFloat(month.win_rate));
                    const teamAverage = (teamRates.reduce((a, b) => a + b, 0) / teamRates.length);
                    teamStats[team].average = teamAverage.toFixed(3);
                    teamStats[team].averageNum = teamAverage; // 비교용 숫자값
                }
            });
            
            // 전체 평균 계산
            let allRates = [];
            rankedTeams.forEach(team => {
                const monthlyData = dashboardData.monthlyPerformance[team];
                monthlyData.forEach(month => {
                    if (month.wins + month.losses > 0) {
                        allRates.push(parseFloat(month.win_rate));
                    }
                });
            });
            const totalAverage = allRates.length > 0 ? 
                (allRates.reduce((a, b) => a + b, 0) / allRates.length).toFixed(3) : '-';

            // 1. 팀별 평균 승률 행
            const avgRow = document.createElement('tr');
            avgRow.className = 'stats-row';
            let avgHtml = `<td class="stats-label" style="background: #6b7280; color: white; border: 1px solid #4b5563; white-space: nowrap; font-size: var(--font-sm); padding: 6px 4px;"><strong>평균</strong></td>`;
            
            rankedTeams.forEach(team => {
                if (teamStats[team]) {
                    const avgClass = teamStats[team].averageNum > 0.55 ? 'positive' : 
                                   teamStats[team].averageNum < 0.45 ? 'negative' : 'neutral';
                    avgHtml += `<td class="${avgClass}" style="background: rgba(107, 114, 128, 0.1); text-align: center; border: 1px solid #d1d5db; white-space: nowrap; font-size: var(--font-sm); padding: 6px 2px;"><strong>${teamStats[team].average}</strong></td>`;
                } else {
                    avgHtml += '<td style="background: rgba(107, 114, 128, 0.1); color: #999; text-align: center; border: 1px solid #d1d5db; white-space: nowrap; font-size: var(--font-sm); padding: 6px 2px;">-</td>';
                }
            });
            avgRow.innerHTML = avgHtml;
            tbody.appendChild(avgRow);

            // 월별 테이블은 커스텀 정렬 함수 사용 (makeTableSortable 호출 제거)
        }

        // 월별 성적 정렬 함수들
        let monthlyMonthSortState = 0; // 0: 기본(3월~8월), 1: 역순(8월~3월)
        let monthlyTeamSortState = {}; // 팀별 정렬 상태
        
        window.sortMonthlyByMonth = function() {
            const tbody = document.querySelector('#monthlyTable tbody');
            if (!tbody) return;
            
            monthlyMonthSortState = (monthlyMonthSortState + 1) % 2;
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 평균 행 제외하고 월 행만 정렬
            const monthRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && !firstCell.textContent.includes('평균');
            });
            
            const avgRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && firstCell.textContent.includes('평균');
            });
            
            if (monthlyMonthSortState === 1) {
                // 첫 번째 클릭: 3월~10월 순서
                const monthOrder = ['3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월'];
                monthRows.sort((a, b) => {
                    const monthA = a.querySelector('td').textContent.trim();
                    const monthB = b.querySelector('td').textContent.trim();
                    return monthOrder.indexOf(monthA) - monthOrder.indexOf(monthB);
                });
            } else {
                // 두 번째 클릭: 10월~3월 순서 (역순)
                const monthOrder = ['10월', '9월', '8월', '7월', '6월', '5월', '4월', '3월'];
                monthRows.sort((a, b) => {
                    const monthA = a.querySelector('td').textContent.trim();
                    const monthB = b.querySelector('td').textContent.trim();
                    return monthOrder.indexOf(monthA) - monthOrder.indexOf(monthB);
                });
            }
            
            // 정렬된 월 행들과 평균 행들을 다시 추가
            tbody.innerHTML = '';
            monthRows.forEach(row => tbody.appendChild(row));
            avgRows.forEach(row => tbody.appendChild(row));
        };
        
        window.sortMonthlyByTeam = function(teamName) {
            const tbody = document.querySelector('#monthlyTable tbody');
            if (!tbody) return;
            
            // 현재 팀 정렬 상태 확인
            const currentState = monthlyTeamSortState[teamName] || 0;
            monthlyTeamSortState = {}; // 다른 팀 정렬 상태 초기화
            
            const nextState = (currentState + 1) % 3;
            monthlyTeamSortState[teamName] = nextState;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 평균 행 제외하고 월 행만 정렬
            const monthRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && !firstCell.textContent.includes('평균');
            });
            
            const avgRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && firstCell.textContent.includes('평균');
            });
            
            if (nextState === 0) {
                // 기본 순서 (3월~10월)
                const monthOrder = ['3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월'];
                monthRows.sort((a, b) => {
                    const monthA = a.querySelector('td').textContent.trim();
                    const monthB = b.querySelector('td').textContent.trim();
                    return monthOrder.indexOf(monthA) - monthOrder.indexOf(monthB);
                });
            } else {
                // 팀 컬럼 찾기 - 더 정확한 방법 사용
                const allHeaders = document.querySelectorAll('#monthlyTable thead th');
                let teamIndex = -1;
                
                // 헤더에서 팀 이름을 포함한 열 찾기
                allHeaders.forEach((header, index) => {
                    const headerText = header.textContent || header.innerText;
                    if (headerText.includes(teamName) || (header.onclick && header.onclick.toString().includes(teamName))) {
                        teamIndex = index;
                    }
                });
                
                
                if (teamIndex !== -1) {
                    monthRows.sort((a, b) => {
                        const cellA = a.cells[teamIndex];
                        const cellB = b.cells[teamIndex];
                        
                        if (!cellA || !cellB) return 0;
                        
                        // 승률 추출 - 월별 테이블 형식: "승-패-무 (승률)" 
                        const textA = cellA.textContent || cellA.innerText || '';
                        const textB = cellB.textContent || cellB.innerText || '';
                        
                        // 괄호 안의 승률 추출 (예: "2-1-0 (0.667)" → 0.667)
                        const winRateA = parseFloat(textA.match(/\(([0-9.]+)\)/)?.[1] || '0');
                        const winRateB = parseFloat(textB.match(/\(([0-9.]+)\)/)?.[1] || '0');
                        
                        
                        if (nextState === 1) {
                            return winRateB - winRateA; // 첫 번째 클릭: 내림차순 (높은 승률부터)
                        } else {
                            return winRateA - winRateB; // 두 번째 클릭: 오름차순 (낮은 승률부터)
                        }
                    });
                }
            }
            
            // 정렬된 행들을 다시 추가
            tbody.innerHTML = '';
            monthRows.forEach(row => tbody.appendChild(row));
            avgRows.forEach(row => tbody.appendChild(row));
        };

        // 시리즈 분석 데이터 로드
        async function loadSeriesAnalysisData() {
            const tbody = document.querySelector('#monthlyTable tbody');
            if (!tbody) return;
            
            // 현재 상태 확인 및 다음 상태로 전환
            const currentState = monthlyRateSortState[monthNum] || 0;
            const nextState = (currentState + 1) % 3; // 0: 내림차순, 1: 오름차순, 2: 원래순서
            
            // 다른 월 상태만 초기화 (현재 월 제외)
            Object.keys(monthlyRateSortState).forEach(key => {
                if (key != monthNum) {
                    delete monthlyRateSortState[key];
                }
            });
            monthlyRateSortState[monthNum] = nextState;
            
            console.log('월별 - 현재 상태:', currentState, '다음 상태:', nextState);
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 평균 행 제외하고 월 행만 정렬
            const monthRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && !firstCell.textContent.includes('평균');
            });
            
            const avgRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && firstCell.textContent.includes('평균');
            });
            
            // 해당 월의 행 찾기
            const targetRowIndex = monthRows.findIndex(row => {
                const firstCell = row.querySelector('td');
                const monthNames = ['3월', '4월', '5월', '6월', '7월', '8월'];
                const monthName = monthNames[monthNum - 3]; // monthNum은 3부터 시작
                return firstCell && firstCell.textContent.trim() === monthName;
            });
            
            if (targetRowIndex === -1) {
                console.log('월별 - 해당 월의 행을 찾을 수 없음! monthNum:', monthNum, 'monthName:', monthNames[monthNum - 3]);
                return;
            }
            
            // 원래 순서 저장 (첫 번째 호출 시에만)
            if (originalMonthlyTeamOrder.length === 0) {
                const thead = document.querySelector('#monthlyTable thead');
                if (thead) {
                    const headerRow = thead.querySelector('tr');
                    if (headerRow) {
                        const teamHeaders = Array.from(headerRow.querySelectorAll('th')).slice(1);
                        originalMonthlyTeamOrder = teamHeaders.map((th, index) => index);
                        console.log('월별 - 원래 팀 순서 저장됨:', originalMonthlyTeamOrder);
                    }
                }
            }
            
            let teamRates = [];
            
            if (nextState === 2) {
                // 원래 순서로 복원
                console.log('월별 - 원래 순서로 복원 중:', originalMonthlyTeamOrder);
                teamRates = originalMonthlyTeamOrder.map((originalIndex, currentIndex) => ({
                    rate: 0, // 원래 순서에서는 승률 불필요
                    originalIndex: originalIndex
                }));
            } else {
                // 해당 월의 팀별 승률 데이터 수집
                const targetRow = monthRows[targetRowIndex];
                const cells = Array.from(targetRow.querySelectorAll('td')).slice(1); // 첫 번째 월 라벨 제외
                
                cells.forEach((cell, index) => {
                    const text = cell.textContent || cell.innerText || '';
                    const rateMatch = text.match(/\(([0-9.]+)\)/); // (승률) 추출
                    if (rateMatch) {
                        teamRates.push({
                            rate: parseFloat(rateMatch[1]),
                            index: index + 1, // +1은 첫 번째 월 라벨 컬럼 때문
                            originalIndex: index
                        });
                    } else {
                        // 데이터가 없는 경우 -1로 처리 (맨 뒤로)
                        teamRates.push({
                            rate: -1,
                            index: index + 1,
                            originalIndex: index
                        });
                    }
                });
                
                // 승률 순으로 정렬
                teamRates.sort((a, b) => {
                    if (a.rate === -1 && b.rate === -1) return 0;
                    if (a.rate === -1) return 1;
                    if (b.rate === -1) return -1;
                    
                    if (nextState === 0) {
                        return b.rate - a.rate; // 내림차순 (높은 승률 먼저)
                    } else {
                        return a.rate - b.rate; // 오름차순 (낮은 승률 먼저)
                    }
                });
            }
            
            // 더 안정적인 DOM 조작 방식으로 전체 테이블 재구성
            console.log('월별 DOM 재구성 시작, teamRates:', teamRates);
            
            // 헤더 재배열
            const thead = document.querySelector('#monthlyTable thead');
            if (thead) {
                const headerRow = thead.querySelector('tr');
                if (headerRow) {
                    const headerCells = Array.from(headerRow.querySelectorAll('th'));
                    const monthHeader = headerCells[0].outerHTML; // 월 헤더
                    const teamHeaders = headerCells.slice(1);
                    
                    let newHeaderHtml = '<tr>' + monthHeader;
                    teamRates.forEach(item => {
                        newHeaderHtml += teamHeaders[item.originalIndex].outerHTML;
                    });
                    newHeaderHtml += '</tr>';
                    
                    thead.innerHTML = newHeaderHtml;
                }
            }
            
            // 바디 재배열 (월 행과 평균 행 모두)
            let newBodyHtml = '';
            
            // 월 행들 먼저 처리
            monthRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                const monthLabel = cells[0].outerHTML;
                const dataCells = cells.slice(1);
                
                let newRowHtml = '<tr>' + monthLabel;
                teamRates.forEach(item => {
                    newRowHtml += dataCells[item.originalIndex].outerHTML;
                });
                newRowHtml += '</tr>';
                
                newBodyHtml += newRowHtml;
            });
            
            // 평균 행들 처리
            avgRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                const avgLabel = cells[0].outerHTML;
                const dataCells = cells.slice(1);
                
                let newRowHtml = '<tr>' + avgLabel;
                teamRates.forEach(item => {
                    newRowHtml += dataCells[item.originalIndex].outerHTML;
                });
                newRowHtml += '</tr>';
                
                newBodyHtml += newRowHtml;
            });
            
            tbody.innerHTML = newBodyHtml;
            
            // 클릭 이벤트 재바인딩 - 월별 (더 안정적인 방식)
            tbody.querySelectorAll('td.month-label').forEach(cell => {
                // onclick 속성에서 monthNum 추출
                const onclickAttr = cell.getAttribute('onclick');
                if (onclickAttr) {
                    const match = onclickAttr.match(/sortMonthlyByRate\((\d+)\)/);
                    if (match) {
                        const monthNum = parseInt(match[1]);
                        // 새로운 클릭 이벤트 추가
                        cell.addEventListener('click', (e) => {
                            e.preventDefault();
                            sortMonthlyByRate(monthNum);
                        });
                    }
                }
            });
        };

        /**
         * 요일별 성적 분석 테이블 렌더링 (행/열 반전 구조)
         * 
         * 테이블 구조:
         * - 상단 헤더: 팀명들 (순위순)
         * - 좌측 헤더: 요일들 (월~일) + 평일성적 + 주말성적
         * - 데이터 셀: "승-패-무 (승률)" + "경기수" 형태
         * 
         * 색상 구분:
         * - 헤더: 평일(#34495e), 주말(#dc2626)
         * - 데이터: 승률에 따른 동적 색상
         */
        function renderWeekdayFullAnalysis() {
            const thead = document.getElementById('weekdayTableHead');
            const tbody = document.getElementById('weekdayBody');
            thead.innerHTML = '';
            tbody.innerHTML = '';
            
            // 종합 순위 기준 팀 순서 사용 (KBO 규정 동률 처리 반영)
            const rankedTeams = getRankingSystem().teams;
            
            // 테이블 헤더 생성 (팀명들 - 정렬 기능 포함)
            let headerHtml = '<tr><th class="day-label sortable" style="cursor: pointer;" onclick="sortWeekdayByDay()">요일</th>';
            rankedTeams.forEach(team => {
                headerHtml += `<th style="cursor: pointer;" onclick="sortWeekdayByTeam('${team}')">${getTeamWithLogo(team, 'team-logo-small')}</th>`;
            });
            headerHtml += '</tr>';
            thead.innerHTML = headerHtml;
            
            const days = [
                { key: '월', name: '월요일' },
                { key: '화', name: '화요일' },
                { key: '수', name: '수요일' },
                { key: '목', name: '목요일' },
                { key: '금', name: '금요일' },
                { key: '토', name: '토요일' },
                { key: '일', name: '일요일' }
            ];
            
            let bodyHtml = '';
            
            // 각 요일별로 행 생성 (성적과 승률을 한 셀에 표기)
            days.forEach(day => {
                // 평일(월~금)과 주말(토~일) 구분
                const dayClass = ['토', '일'].includes(day.key) ? 'day-label weekend' : 'day-label weekday';
                let dayRow = `<tr><td class="${dayClass}" style="cursor: pointer;" onclick="sortWeekdayByRate('${day.key}')">${day.name}</td>`;
                
                rankedTeams.forEach(team => {
                    const weekdayData = dashboardData.weekdayPerformance[team];
                    if (weekdayData && weekdayData[day.key]) {
                        const wins = weekdayData[day.key].wins;
                        const losses = weekdayData[day.key].losses;
                        const draws = weekdayData[day.key].draws || 0;
                        const winRateValue = parseFloat(weekdayData[day.key].win_rate);
                        const normalizedWinRate = winRateValue > 1 ? winRateValue / 100 : winRateValue;
                        const winRate = normalizedWinRate.toFixed(3);
                        
                        const cellStyle = getUnifiedCellStyle(normalizedWinRate);
                        
                        const totalGames = wins + losses + draws;
                        const cellStyleString = `background: ${cellStyle.backgroundColor}; color: ${cellStyle.textColor}; padding: 5px 1px;`;
                        
                        dayRow += `
                            <td style="${cellStyleString} white-space: nowrap; font-size: var(--font-sm); text-align: center; line-height: 1.2;">
                                <div style="font-weight: var(--font-weight-semibold); margin-bottom: 1px; font-size: var(--font-sm);">${wins}-${losses}-${draws} (${winRate})</div>
                                <div style="font-size: var(--font-xs); margin-top: 1px;">${totalGames}경기</div>
                            </td>
                        `;
                    } else {
                        dayRow += '<td style="background: #f8f9fa; color: #999; padding: 6px 2px; white-space: nowrap; font-size: var(--font-xs); text-align: center;">-</td>';
                    }
                });
                dayRow += '</tr>';
                
                bodyHtml += dayRow;
            });
            
            // 평일승률/주말승률 행 추가 (성적과 승률을 한 셀에 표기) - 순서 변경, 연한 파란색 헤더, 상단 구분선
            let weekdayRow = '<tr class="stats-row"><td class="stats-label weekday-stats" style="border-top: 2px solid #34495e;">평일 성적</td>';
            let weekendRow = '<tr class="stats-row"><td class="stats-label weekend-stats">주말 성적</td>';
            
            rankedTeams.forEach(team => {
                const weekdayData = dashboardData.weekdayPerformance[team];
                
                // 주말 데이터 (토, 일)
                let weekendWins = 0, weekendLosses = 0, weekendDraws = 0;
                ['토', '일'].forEach(day => {
                    if (weekdayData && weekdayData[day]) {
                        weekendWins += weekdayData[day].wins;
                        weekendLosses += weekdayData[day].losses;
                        weekendDraws += weekdayData[day].draws || 0;
                    }
                });
                const weekendWinRate = (weekendWins + weekendLosses > 0) ? (weekendWins / (weekendWins + weekendLosses)) : 0;
                const weekendCellStyle = getUnifiedCellStyle(weekendWinRate);
                
                const weekendTotalGames = weekendWins + weekendLosses + weekendDraws;
                
                const weekendStyleString = `background: ${weekendCellStyle.backgroundColor}; color: ${weekendCellStyle.textColor}; padding: 5px 1px;`;
                
                weekendRow += `
                    <td style="${weekendStyleString} white-space: nowrap; font-size: var(--font-sm); text-align: center; line-height: 1.2;">
                        <div style="font-weight: var(--font-weight-semibold); margin-bottom: 1px; font-size: var(--font-sm);">${weekendWins}-${weekendLosses}-${weekendDraws} (${weekendWinRate.toFixed(3)})</div>
                        <div style="font-size: var(--font-xs); margin-top: 1px;">${weekendTotalGames}경기</div>
                    </td>
                `;
                
                // 평일 데이터 (월~금)
                let weekdayWins = 0, weekdayLosses = 0, weekdayDraws = 0;
                ['월', '화', '수', '목', '금'].forEach(day => {
                    if (weekdayData && weekdayData[day]) {
                        weekdayWins += weekdayData[day].wins;
                        weekdayLosses += weekdayData[day].losses;
                        weekdayDraws += weekdayData[day].draws || 0;
                    }
                });
                const weekdayWinRate = (weekdayWins + weekdayLosses > 0) ? (weekdayWins / (weekdayWins + weekdayLosses)) : 0;
                const weekdayCellStyle = getUnifiedCellStyle(weekdayWinRate);
                
                const weekdayTotalGames = weekdayWins + weekdayLosses + weekdayDraws;
                
                const weekdayStyleString = `background: ${weekdayCellStyle.backgroundColor}; color: ${weekdayCellStyle.textColor}; padding: 5px 1px; border-top: 2px solid #34495e;`;
                
                weekdayRow += `
                    <td style="${weekdayStyleString} white-space: nowrap; font-size: var(--font-sm); text-align: center; line-height: 1.2;">
                        <div style="font-weight: var(--font-weight-semibold); margin-bottom: 1px; font-size: var(--font-sm);">${weekdayWins}-${weekdayLosses}-${weekdayDraws} (${weekdayWinRate.toFixed(3)})</div>
                        <div style="font-size: var(--font-xs); margin-top: 1px;">${weekdayTotalGames}경기</div>
                    </td>
                `;
            });
            
            weekdayRow += '</tr>';
            weekendRow += '</tr>';
            
            bodyHtml += weekdayRow + weekendRow;
            
            tbody.innerHTML = bodyHtml;
            
            // 요일별 테이블은 커스텀 정렬 함수 사용 (makeTableSortable 호출 제거)
        }

        // 요일별 성적 정렬 함수들
        let weekdayDaySortState = 0; // 0: 기본(월~일), 1: 역순(일~월)
        let weekdayTeamSortState = {}; // 팀별 정렬 상태

        window.sortWeekdayByDay = function() {
            const tbody = document.querySelector('#weekdayTable tbody');
            if (!tbody) return;
            
            weekdayDaySortState = (weekdayDaySortState + 1) % 2;
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 평일성적, 주말성적 행 제외하고 요일 행만 정렬
            const dayRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && !firstCell.textContent.includes('성적');
            });
            
            const summaryRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && firstCell.textContent.includes('성적');
            });
            
            if (weekdayDaySortState === 1) {
                // 첫 번째 클릭: 월요일부터 일요일 순서
                const dayOrder = ['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'];
                dayRows.sort((a, b) => {
                    const dayA = a.querySelector('td').textContent.trim();
                    const dayB = b.querySelector('td').textContent.trim();
                    return dayOrder.indexOf(dayA) - dayOrder.indexOf(dayB);
                });
            } else {
                // 두 번째 클릭: 일요일부터 월요일 순서 (역순)
                const dayOrder = ['일요일', '토요일', '금요일', '목요일', '수요일', '화요일', '월요일'];
                dayRows.sort((a, b) => {
                    const dayA = a.querySelector('td').textContent.trim();
                    const dayB = b.querySelector('td').textContent.trim();
                    return dayOrder.indexOf(dayA) - dayOrder.indexOf(dayB);
                });
            }
            
            // 정렬된 요일 행들과 요약 행들을 다시 추가
            tbody.innerHTML = '';
            dayRows.forEach(row => tbody.appendChild(row));
            summaryRows.forEach(row => tbody.appendChild(row));
        };

        window.sortWeekdayByTeam = function(teamName) {
            const tbody = document.querySelector('#weekdayTable tbody');
            if (!tbody) return;
            
            // 현재 팀 정렬 상태 확인
            const currentState = weekdayTeamSortState[teamName] || 0;
            weekdayTeamSortState = {}; // 다른 팀 정렬 상태 초기화
            
            const nextState = (currentState + 1) % 3;
            weekdayTeamSortState[teamName] = nextState;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 평일성적, 주말성적 행 제외하고 요일 행만 정렬
            const dayRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && !firstCell.textContent.includes('성적');
            });
            
            const summaryRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && firstCell.textContent.includes('성적');
            });
            
            if (nextState === 0) {
                // 기본 순서 (월~일)
                const dayOrder = ['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'];
                dayRows.sort((a, b) => {
                    const dayA = a.querySelector('td').textContent.trim();
                    const dayB = b.querySelector('td').textContent.trim();
                    return dayOrder.indexOf(dayA) - dayOrder.indexOf(dayB);
                });
            } else {
                // 팀 컬럼 찾기
                const teamHeaders = document.querySelectorAll('#weekdayTable th');
                let teamIndex = -1;
                
                teamHeaders.forEach((header, index) => {
                    if (header.onclick && header.onclick.toString().includes(teamName)) {
                        teamIndex = index;
                    }
                });
                
                if (teamIndex !== -1) {
                    dayRows.sort((a, b) => {
                        const cellA = a.cells[teamIndex];
                        const cellB = b.cells[teamIndex];
                        
                        if (!cellA || !cellB) return 0;
                        
                        // 승률 추출 - 요일별 테이블 형식: "승-패-무 (승률)" 
                        const textA = cellA.textContent || cellA.innerText || '';
                        const textB = cellB.textContent || cellB.innerText || '';
                        
                        // 괄호 안의 승률 추출 (예: "2-1-0 (0.667)" → 0.667)
                        const winRateA = parseFloat(textA.match(/\(([0-9.]+)\)/)?.[1] || '0');
                        const winRateB = parseFloat(textB.match(/\(([0-9.]+)\)/)?.[1] || '0');
                        
                        
                        if (nextState === 1) {
                            return winRateB - winRateA; // 첫 번째 클릭: 내림차순 (높은 승률부터)
                        } else {
                            return winRateA - winRateB; // 두 번째 클릭: 오름차순 (낮은 승률부터)
                        }
                    });
                }
            }
            
            // 정렬된 행들을 다시 추가
            tbody.innerHTML = '';
            dayRows.forEach(row => tbody.appendChild(row));
            summaryRows.forEach(row => tbody.appendChild(row));
        };
        
        // 요일별 승률 순 정렬 함수 (3단계: 내림차순 → 오름차순 → 원래순서)
        let weekdayRateSortState = {}; // 요일별 정렬 상태
        let originalWeekdayTeamOrder = []; // 원래 팀 순서 저장
        
        window.sortWeekdayByRate = function(dayKey) {
            const tbody = document.querySelector('#weekdayTable tbody');
            if (!tbody) return;
            
            // 현재 상태 확인 및 다음 상태로 전환
            const currentState = weekdayRateSortState[dayKey] || 0;
            const nextState = (currentState + 1) % 3; // 0: 내림차순, 1: 오름차순, 2: 원래순서
            
            // 다른 요일 상태만 초기화 (현재 요일 제외)
            Object.keys(weekdayRateSortState).forEach(key => {
                if (key !== dayKey) {
                    delete weekdayRateSortState[key];
                }
            });
            weekdayRateSortState[dayKey] = nextState;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 평일성적, 주말성적 행 제외하고 요일 행만 정렬
            const dayRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && !firstCell.textContent.includes('성적');
            });
            
            const summaryRows = rows.filter(row => {
                const firstCell = row.querySelector('td');
                return firstCell && firstCell.textContent.includes('성적');
            });
            
            // 원래 순서 저장 (첫 번째 호출 시에만)
            if (originalWeekdayTeamOrder.length === 0) {
                const thead = document.querySelector('#weekdayTable thead');
                if (thead) {
                    const headerRow = thead.querySelector('tr');
                    if (headerRow) {
                        const teamHeaders = Array.from(headerRow.querySelectorAll('th')).slice(1);
                        originalWeekdayTeamOrder = teamHeaders.map((th, index) => ({
                            index: index,
                            teamName: th.textContent.trim()
                        }));
                    }
                }
            }
            
            // 해당 요일의 행 찾기
            const dayNames = ['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'];
            const dayKeys = ['월', '화', '수', '목', '금', '토', '일'];
            const dayIndex = dayKeys.indexOf(dayKey);
            const dayName = dayNames[dayIndex];
            
            const targetRowIndex = dayRows.findIndex(row => {
                const firstCell = row.querySelector('td');
                return firstCell && firstCell.textContent.trim() === dayName;
            });
            
            if (targetRowIndex === -1) return;
            
            let teamRates = [];
            
            if (nextState === 2) {
                // 원래 순서로 복원
                teamRates = originalWeekdayTeamOrder.map((originalIndex, currentIndex) => ({
                    rate: 0, // 원래 순서에서는 승률 불필요
                    originalIndex: originalIndex
                }));
            } else {
                // 해당 요일의 팀별 승률 데이터 수집
                const targetRow = dayRows[targetRowIndex];
                const cells = Array.from(targetRow.querySelectorAll('td')).slice(1); // 첫 번째 요일 라벨 제외
                
                cells.forEach((cell, index) => {
                    const text = cell.textContent || cell.innerText || '';
                    const rateMatch = text.match(/\(([0-9.]+)\)/); // (승률) 추출
                    if (rateMatch) {
                        teamRates.push({
                            rate: parseFloat(rateMatch[1]),
                            index: index + 1, // +1은 첫 번째 요일 라벨 컬럼 때문
                            originalIndex: index
                        });
                    } else {
                        // 데이터가 없는 경우 -1로 처리 (맨 뒤로)
                        teamRates.push({
                            rate: -1,
                            index: index + 1,
                            originalIndex: index
                        });
                    }
                });
                
                // 승률 순으로 정렬
                teamRates.sort((a, b) => {
                    if (a.rate === -1 && b.rate === -1) return 0;
                    if (a.rate === -1) return 1;
                    if (b.rate === -1) return -1;
                    
                    if (nextState === 0) {
                        return b.rate - a.rate; // 내림차순 (높은 승률 먼저)
                    } else {
                        return a.rate - b.rate; // 오름차순 (낮은 승률 먼저)
                    }
                });
            }
            
            // 더 안정적인 DOM 조작 방식으로 전체 테이블 재구성
            console.log('요일별 DOM 재구성 시작, teamRates:', teamRates);
            
            // 헤더 재배열
            const thead = document.querySelector('#weekdayTable thead');
            if (thead) {
                const headerRow = thead.querySelector('tr');
                if (headerRow) {
                    const headerCells = Array.from(headerRow.querySelectorAll('th'));
                    const dayHeader = headerCells[0].outerHTML; // 요일 헤더
                    const teamHeaders = headerCells.slice(1);
                    
                    let newHeaderHtml = '<tr>' + dayHeader;
                    teamRates.forEach(item => {
                        newHeaderHtml += teamHeaders[item.originalIndex].outerHTML;
                    });
                    newHeaderHtml += '</tr>';
                    
                    thead.innerHTML = newHeaderHtml;
                }
            }
            
            // 바디 재배열 (요일 행과 성적 요약 행 모두)
            let newBodyHtml = '';
            
            // 요일 행들 먼저 처리
            dayRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                const dayLabel = cells[0].outerHTML;
                const dataCells = cells.slice(1);
                
                let newRowHtml = '<tr>' + dayLabel;
                teamRates.forEach(item => {
                    newRowHtml += dataCells[item.originalIndex].outerHTML;
                });
                newRowHtml += '</tr>';
                
                newBodyHtml += newRowHtml;
            });
            
            // 평일성적/주말성적 행들 처리
            summaryRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                const summaryLabel = cells[0].outerHTML;
                const dataCells = cells.slice(1);
                
                let newRowHtml = '<tr>' + summaryLabel;
                teamRates.forEach(item => {
                    newRowHtml += dataCells[item.originalIndex].outerHTML;
                });
                newRowHtml += '</tr>';
                
                newBodyHtml += newRowHtml;
            });
            
            tbody.innerHTML = newBodyHtml;
            
            // 클릭 이벤트 재바인딩 - 요일별 (더 안정적인 방식)
            tbody.querySelectorAll('td.day-label').forEach(cell => {
                // onclick 속성에서 dayKey 추출
                const onclickAttr = cell.getAttribute('onclick');
                if (onclickAttr) {
                    const match = onclickAttr.match(/sortWeekdayByRate\('([^']+)'\)/);
                    if (match) {
                        const dayKey = match[1];
                        // 새로운 클릭 이벤트 추가
                        cell.addEventListener('click', (e) => {
                            e.preventDefault();
                            sortWeekdayByRate(dayKey);
                        });
                    }
                }
            });
        };

        // 경기장별 성적 표 분석
        function renderStadiumFullAnalysis() {
            const thead = document.getElementById('stadiumTableHead');
            const tbody = document.getElementById('stadiumTableBody');
            
            if (!thead || !tbody) {
                console.error('❌ stadiumTableHead 또는 stadiumTableBody 요소를 찾을 수 없습니다');
                return;
            }
            
            if (!dashboardData || !dashboardData.standings) {
                console.error('❌ dashboardData.standings가 없습니다');
                return;
            }
            
            // 종합 순위 기준 팀 순서 사용 (KBO 규정 동률 처리 반영)
            const rankedTeams = getRankingSystem().teams;
            
            // 헤더 생성 (순위 순으로 팀명과 로고)
            let headerHtml = '<tr><th style="min-width: 135px; padding: 6px 2px; white-space: nowrap;">경기장</th>';
            rankedTeams.forEach(team => {
                headerHtml += `<th style="min-width: 85px; padding: 6px 2px; font-size: var(--font-sm); white-space: nowrap;"><strong>${getTeamWithLogo(team, 'team-logo-small')}</strong></th>`;
            });
            headerHtml += '</tr>';
            thead.innerHTML = headerHtml;
            
            // 모든 경기장 수집
            const stadiums = new Set();
            rankedTeams.forEach(team => {
                const stadiumData = dashboardData.stadiumRecords[team];
                if (stadiumData) {
                    stadiumData.forEach(record => stadiums.add(record.stadium));
                }
            });
            
            const stadiumList = Array.from(stadiums).sort();
            let html = '';
            
            stadiumList.forEach(stadium => {
                // 경기장 이름 단순화
                let stadiumName = stadium;
                if (stadium.includes('서울')) {
                    stadiumName = stadium.includes('잠실') ? '서울 잠실야구장' : '서울 고척스카이돔';
                } else {
                    const parts = stadium.split(' ');
                    stadiumName = parts[0] + ' ' + parts[1];
                }
                
                // 홈팀 확인
                const homeTeam = 
                    stadium.includes('광주') ? 'KIA' :
                    stadium.includes('잠실') ? 'LG/두산' :
                    stadium.includes('대구') ? '삼성' :
                    stadium.includes('인천') ? 'SSG' :
                    stadium.includes('수원') ? 'KT' :
                    stadium.includes('창원') ? 'NC' :
                    stadium.includes('부산') ? '롯데' :
                    stadium.includes('대전') ? '한화' :
                    stadium.includes('고척') ? '키움' : '';
                
                html += `<tr>
                    <td style="padding: 6px 2px; min-width: 135px; max-width: 135px; overflow: hidden; text-overflow: ellipsis; cursor: pointer;" onclick="sortStadiumByRate('${stadium}')">
                        <div style="font-weight: var(--font-weight-semibold); font-size: var(--font-xs); margin: 0; padding: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${stadiumName}</div>
                        <div style="font-size: var(--font-2xs); color: #666; margin: 0; padding: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">🏠 ${homeTeam}</div>
                    </td>
                `;
                
                // 각 팀별 해당 경기장 성적 (순위순)
                rankedTeams.forEach(team => {
                    const stadiumData = dashboardData.stadiumRecords[team];
                    const teamRecord = stadiumData ? stadiumData.find(r => r.stadium === stadium) : null;
                    
                    if (teamRecord) {
                        const winRateValue = parseFloat(teamRecord.win_rate);
                        const normalizedWinRate = winRateValue > 1 ? winRateValue / 100 : winRateValue;
                        const winRate = normalizedWinRate.toFixed(3);
                        const totalGames = teamRecord.wins + teamRecord.losses + (teamRecord.draws || 0);
                        
                        // 홈팀인지 확인
                        const isHome = 
                            (team === 'KIA' && stadium.includes('광주')) ||
                            ((team === 'LG' || team === '두산') && stadium.includes('잠실')) ||
                            (team === '삼성' && stadium.includes('대구')) ||
                            (team === 'SSG' && stadium.includes('인천')) ||
                            (team === 'KT' && stadium.includes('수원')) ||
                            (team === 'NC' && stadium.includes('창원')) ||
                            (team === '롯데' && stadium.includes('부산')) ||
                            (team === '한화' && stadium.includes('대전')) ||
                            (team === '키움' && stadium.includes('고척'));
                        
                        // 홈경기는 성적에 따른 배경색 + 파란색 폰트
                        let backgroundColor = colorScheme.default.bg;
                        let textColor = colorScheme.default.color;
                        let recordColor = colorScheme.default.color;
                        
                        // 성적에 따른 배경색 먼저 결정
                        if (normalizedWinRate === 0.5) {
                            // 정확히 50% 승률인 경우만 - 노란색 배경
                            backgroundColor = colorScheme.neutral.bgMedium;
                            recordColor = colorScheme.neutral.color;
                        } else if (normalizedWinRate > 0.6) {
                            backgroundColor = colorScheme.positive.bgStrong;
                            recordColor = colorScheme.positive.color;
                        } else if (normalizedWinRate > 0.5) {
                            backgroundColor = colorScheme.positive.bgMedium;
                            recordColor = colorScheme.positive.color;
                        } else if (normalizedWinRate < 0.4) {
                            backgroundColor = colorScheme.negative.bgStrong;
                            recordColor = colorScheme.negative.color;
                        } else if (normalizedWinRate < 0.5) {
                            backgroundColor = colorScheme.negative.bgMedium;
                            recordColor = colorScheme.negative.color;
                        }
                        
                        // 홈팀이면 폰트만 파란색으로 변경
                        if (isHome) {
                            recordColor = '#1d4ed8'; // 파란색 텍스트
                        }
                        
                        html += `<td style="background: ${backgroundColor}; color: ${textColor}; padding: 1px; white-space: nowrap; min-width: 85px;">
                            <div style="font-size: var(--font-sm); line-height: 1.2; text-align: center;">
                                <div style="font-weight: var(--font-weight-semibold); margin-bottom: 1px; color: ${recordColor}; white-space: nowrap;">${teamRecord.wins}-${teamRecord.losses}-${teamRecord.draws || 0} (${winRate})</div>
                                <div style="font-size: var(--font-xs); color: ${textColor}; margin-top: 1px; white-space: nowrap;">${isHome ? '🏠 ' : ''}${totalGames}경기</div>
                            </div>
                        </td>`;
                    } else {
                        html += `<td style="background: #f8f9fa; color: #999; padding: 1px; white-space: nowrap; min-width: 85px;">
                            <div style="font-size: var(--font-sm); line-height: 1.2; text-align: center;">
                                <div style="font-weight: var(--font-weight-semibold); white-space: nowrap;">-</div>
                                <div style="font-size: var(--font-xs); white-space: nowrap;">&nbsp;</div>
                            </div>
                        </td>`;
                    }
                });
                
                html += '</tr>';
            });
            
            tbody.innerHTML = html;
        }
        
        // 경기장별 승률 순 정렬 함수 (3단계: 내림차순 → 오름차순 → 원래순서)
        let stadiumRateSortState = {}; // 경기장별 정렬 상태
        let originalStadiumTeamOrder = []; // 원래 팀 순서 저장
        
        window.sortStadiumByRate = function(stadiumName) {
            console.log('sortStadiumByRate 호출됨:', stadiumName);
            const tbody = document.querySelector('#stadiumTable tbody');
            if (!tbody) {
                console.log('stadiumTable tbody를 찾을 수 없음');
                return;
            }
            
            // 현재 상태 확인 및 다음 상태로 전환
            const currentState = stadiumRateSortState[stadiumName] || 0;
            const nextState = (currentState + 1) % 3; // 0: 내림차순, 1: 오름차순, 2: 원래순서
            
            // 다른 경기장 상태만 초기화 (현재 경기장 제외)
            Object.keys(stadiumRateSortState).forEach(key => {
                if (key !== stadiumName) {
                    delete stadiumRateSortState[key];
                }
            });
            stadiumRateSortState[stadiumName] = nextState;
            
            console.log('현재 상태:', currentState, '다음 상태:', nextState);
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 원래 순서 저장 (첫 번째 호출 시에만)
            if (originalStadiumTeamOrder.length === 0) {
                const thead = document.querySelector('#stadiumTable thead');
                if (thead) {
                    const headerRow = thead.querySelector('tr');
                    if (headerRow) {
                        const teamHeaders = Array.from(headerRow.querySelectorAll('th')).slice(1);
                        originalStadiumTeamOrder = teamHeaders.map((th, index) => ({
                            index: index,
                            teamName: th.textContent.trim()
                        }));
                        console.log('원래 팀 순서 저장됨:', originalStadiumTeamOrder);
                    }
                }
            }
            
            // 해당 경기장의 행 찾기 (더 정확한 매칭)
            const targetRowIndex = rows.findIndex(row => {
                const firstCell = row.querySelector('td');
                if (!firstCell) return false;
                const stadiumNameDiv = firstCell.querySelector('div');
                if (!stadiumNameDiv) return false;
                
                const displayedName = stadiumNameDiv.textContent.trim();
                
                // 경기장 이름 매칭 로직 개선
                if (stadiumName.includes('광주') && displayedName.includes('광주')) return true;
                if (stadiumName.includes('잠실') && displayedName.includes('잠실')) return true;
                if (stadiumName.includes('대구') && displayedName.includes('대구')) return true;
                if (stadiumName.includes('인천') && displayedName.includes('인천')) return true;
                if (stadiumName.includes('수원') && displayedName.includes('수원')) return true;
                if (stadiumName.includes('창원') && displayedName.includes('창원')) return true;
                if (stadiumName.includes('부산') && displayedName.includes('부산')) return true;
                if (stadiumName.includes('대전') && displayedName.includes('대전')) return true;
                if (stadiumName.includes('고척') && displayedName.includes('고척')) return true;
                
                return false;
            });
            
            if (targetRowIndex === -1) {
                console.log('경기장을 찾을 수 없음:', stadiumName);
                console.log('사용 가능한 경기장들:', rows.map(row => {
                    const firstCell = row.querySelector('td');
                    if (firstCell) {
                        const div = firstCell.querySelector('div');
                        return div ? div.textContent.trim() : '';
                    }
                    return '';
                }));
                return;
            }
            
            console.log('경기장 행 찾음:', targetRowIndex);
            let teamRates = [];
            
            if (nextState === 2) {
                // 원래 순서로 복원
                console.log('원래 순서로 복원 중:', originalStadiumTeamOrder);
                teamRates = originalStadiumTeamOrder.map((originalIndex, currentIndex) => ({
                    rate: 0, // 원래 순서에서는 승률 불필요
                    originalIndex: originalIndex
                }));
            } else {
                // 해당 경기장의 팀별 승률 데이터 수집
                const targetRow = rows[targetRowIndex];
                const cells = Array.from(targetRow.querySelectorAll('td')).slice(1); // 첫 번째 경기장 라벨 제외
                
                cells.forEach((cell, index) => {
                    const text = cell.textContent || cell.innerText || '';
                    const rateMatch = text.match(/\(([0-9.]+)\)/); // (승률) 추출
                    
                    // 데이터가 있고 "-"가 아닌 경우
                    if (rateMatch && rateMatch[1] && !text.trim().startsWith('-') && text.trim() !== '-') {
                        teamRates.push({
                            rate: parseFloat(rateMatch[1]),
                            index: index + 1, // +1은 첫 번째 경기장 라벨 컬럼 때문
                            originalIndex: index
                        });
                    } else {
                        // 데이터가 없는 경우 -1로 처리 (맨 뒤로)
                        teamRates.push({
                            rate: -1,
                            index: index + 1,
                            originalIndex: index
                        });
                    }
                });
                
                // 승률 순으로 정렬
                teamRates.sort((a, b) => {
                    if (a.rate === -1 && b.rate === -1) return 0;
                    if (a.rate === -1) return 1;
                    if (b.rate === -1) return -1;
                    
                    if (nextState === 0) {
                        return b.rate - a.rate; // 내림차순 (높은 승률 먼저)
                    } else {
                        return a.rate - b.rate; // 오름차순 (낮은 승률 먼저)
                    }
                });
            }
            
            // 더 안정적인 DOM 조작 방식으로 전체 테이블 재구성
            console.log('DOM 재구성 시작, teamRates:', teamRates);
            
            // 헤더 재배열
            const thead = document.querySelector('#stadiumTable thead');
            if (thead) {
                const headerRow = thead.querySelector('tr');
                if (headerRow) {
                    const headerCells = Array.from(headerRow.querySelectorAll('th'));
                    const stadiumHeader = headerCells[0].outerHTML; // 경기장 헤더
                    const teamHeaders = headerCells.slice(1);
                    
                    let newHeaderHtml = '<tr>' + stadiumHeader;
                    teamRates.forEach(item => {
                        newHeaderHtml += teamHeaders[item.originalIndex].outerHTML;
                    });
                    newHeaderHtml += '</tr>';
                    
                    thead.innerHTML = newHeaderHtml;
                }
            }
            
            // 바디 재배열
            let newBodyHtml = '';
            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                const stadiumLabel = cells[0].outerHTML; // 경기장 라벨
                const dataCells = cells.slice(1);
                
                let newRowHtml = '<tr>' + stadiumLabel;
                teamRates.forEach(item => {
                    newRowHtml += dataCells[item.originalIndex].outerHTML;
                });
                newRowHtml += '</tr>';
                
                newBodyHtml += newRowHtml;
            });
            
            tbody.innerHTML = newBodyHtml;
            
            // 클릭 이벤트 재바인딩 - 경기장별 (더 안정적인 방식)
            tbody.querySelectorAll('td[onclick*="sortStadiumByRate"]').forEach(cell => {
                // onclick 속성에서 stadiumName 추출
                const onclickAttr = cell.getAttribute('onclick');
                if (onclickAttr) {
                    const match = onclickAttr.match(/sortStadiumByRate\('([^']+)'\)/);
                    if (match) {
                        const stadiumName = match[1];
                        // 새로운 클릭 이벤트 추가
                        cell.addEventListener('click', (e) => {
                            e.preventDefault();
                            sortStadiumByRate(stadiumName);
                        });
                    }
                }
            });
        };

        // 테이블 정렬 기능
        function makeTableSortable(tableId) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            // 커스텀 정렬이 있는 테이블들은 일반 정렬 적용 안 함
            const customSortTables = ['weekdayTable', 'monthlyTable', 'stadiumTable'];
            if (customSortTables.includes(tableId)) {
                return;
            }
            
            const headers = table.querySelectorAll('th');
            headers.forEach((header, index) => {
                // 기존 이벤트 리스너 제거 (중복 방지)
                const existingHandler = header._sortHandler;
                if (existingHandler) {
                    header.removeEventListener('click', existingHandler);
                }
                
                // no-sort 클래스가 있는 헤더는 일반 정렬에서 제외
                if (!header.classList.contains('no-sort')) {
                    header.classList.add('sortable');
                    const handler = () => sortTable(table, index, header);
                    header._sortHandler = handler;  // 참조 저장
                    header.addEventListener('click', handler);
                }
            });
        }
        
        function sortTable(table, columnIndex, header) {
            const tbody = table.querySelector('tbody');
            const allRows = Array.from(tbody.querySelectorAll('tr'));
            
            // 일반 데이터 행과 통계 행(월평균 등) 분리
            const dataRows = allRows.filter(row => !row.classList.contains('stats-row'));
            const statsRows = allRows.filter(row => row.classList.contains('stats-row'));
            
            // 현재 정렬 상태 확인
            const currentSort = header.classList.contains('sort-asc') ? 'asc' : 
                               header.classList.contains('sort-desc') ? 'desc' : 'none';
            
            // 모든 헤더의 정렬 클래스 제거
            table.querySelectorAll('th').forEach(h => {
                h.classList.remove('sort-asc', 'sort-desc');
            });
            
            // 다음 정렬 방향 결정
            const nextSort = currentSort === 'none' ? 'desc' : 
                            currentSort === 'desc' ? 'asc' : 'desc';
            
            // 일반 데이터 행만 정렬
            dataRows.sort((a, b) => {
                const aCell = a.cells[columnIndex];
                const bCell = b.cells[columnIndex];
                
                // 텍스트 추출 (HTML 태그 제거) - null 체크 추가
                let aValue = (aCell && (aCell.textContent || aCell.innerText)) || '';
                let bValue = (bCell && (bCell.textContent || bCell.innerText)) || '';
                
                // 연승/연패 관련 컬럼 특별 처리 (우선순위 높음)
                const columnAttr = header.getAttribute('data-column');
                const isStreakColumn = columnAttr === 'maxWins' || columnAttr === 'maxLosses' || 
                                     columnAttr?.startsWith('wins') || columnAttr?.startsWith('losses') ||
                                     header.classList.contains('max-header') ||
                                     header.classList.contains('streak-count-header');
                
                if (isStreakColumn) {
                    // 셀에서 데이터 속성 우선 확인
                    let aNum, bNum;
                    
                    if (columnAttr === 'maxWins') {
                        aNum = parseInt(aCell?.getAttribute('data-maxwins')) || 0;
                        bNum = parseInt(bCell?.getAttribute('data-maxwins')) || 0;
                    } else if (columnAttr === 'maxLosses') {
                        aNum = parseInt(aCell?.getAttribute('data-maxlosses')) || 0;
                        bNum = parseInt(bCell?.getAttribute('data-maxlosses')) || 0;
                    } else {
                        // 다른 연승/연패 컬럼들은 기존 방식 사용
                        const cleanA = (aValue || '').toString().trim();
                        const cleanB = (bValue || '').toString().trim();
                        aNum = cleanA === '-' || cleanA === '' ? 0 : parseInt(cleanA);
                        bNum = cleanB === '-' || cleanB === '' ? 0 : parseInt(cleanB);
                    }
                    
                    // 강제로 숫자 정렬 적용
                    return nextSort === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // 숫자인지 확인 (승률, 득점 등)
                const aNum = parseFloat(aValue.replace(/[^\d.-]/g, ''));
                const bNum = parseFloat(bValue.replace(/[^\d.-]/g, ''));
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return nextSort === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // 승-패 기록 정렬 (승수 기준)
                if (aValue.includes('-') && bValue.includes('-')) {
                    const aWins = parseInt(aValue.split('-')[0]);
                    const bWins = parseInt(bValue.split('-')[0]);
                    if (!isNaN(aWins) && !isNaN(bWins)) {
                        return nextSort === 'asc' ? aWins - bWins : bWins - aWins;
                    }
                }
                
                // 문자열 정렬
                return nextSort === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
            });
            
            // tbody 초기화 후 데이터 행들 먼저 추가
            tbody.innerHTML = '';
            dataRows.forEach(row => tbody.appendChild(row));
            
            // 통계 행들을 맨 마지막에 추가 (고정 위치)
            statsRows.forEach(row => tbody.appendChild(row));
            
            // 종합순위 테이블인 경우 순위 컬럼 색상 업데이트
            if (table.id === 'fullStandingsTable') {
                updateRankColors(tbody, columnIndex);
            }
            
            // 헤더에 정렬 상태 표시
            header.classList.add(nextSort === 'asc' ? 'sort-asc' : 'sort-desc');
        }
        
        // 순위 컬럼 색상 및 번호 업데이트 함수 (팀의 실제 순위 유지)
        function updateRankColors(tbody, sortedColumnIndex) {
            const dataRows = Array.from(tbody.querySelectorAll('tr')).filter(row => !row.classList.contains('stats-row'));
            
            dataRows.forEach((row, index) => {
                const rankCell = row.cells[0]; // 첫 번째 셀이 순위 컬럼
                if (rankCell) {
                    // 기존 순위 클래스 제거
                    rankCell.classList.remove('rank-1', 'rank-2', 'rank-3');
                    
                    // 팀명으로 실제 순위 찾기
                    const teamNameCell = row.cells[1];
                    if (teamNameCell && dashboardData && dashboardData.standings) {
                        const teamNameText = teamNameCell.textContent || teamNameCell.innerText;
                        // 팀명에서 로고 제거하고 순수 팀명만 추출
                        const teamName = teamNameText.replace(/^\s*\d+\s*/, '').trim();
                        
                        // dashboardData에서 해당 팀의 실제 순위 찾기
                        const teamData = dashboardData.standings.find(t => 
                            teamName.includes(t.team_name) || t.team_name.includes(teamName)
                        );
                        
                        if (teamData) {
                            const actualRank = teamData.displayRank || teamData.rank || (index + 1);
                            rankCell.innerHTML = `<strong>${actualRank}</strong>`;
                            
                            // 실제 순위에 따른 클래스 적용
                            if (actualRank <= 3) {
                                rankCell.classList.add(`rank-${actualRank}`);
                            }
                        } else {
                            // 팀을 찾지 못한 경우 순서대로 
                            const fallbackRank = index + 1;
                            rankCell.innerHTML = `<strong>${fallbackRank}</strong>`;
                            if (fallbackRank <= 3) {
                                rankCell.classList.add(`rank-${fallbackRank}`);
                            }
                        }
                    }
                }
            });
        }
        
        // 모든 테이블에 정렬 기능 적용
        function initializeTableSorting() {
            const tableIds = [
                'fullStandingsTable',
                'pythagoreanTable', 
                'clutchTable',
                'homeAwayTable',
                'monthlyTable',
                'weekdayTable',
                'stadiumTable'
            ];
            
            tableIds.forEach(id => makeTableSortable(id));
        }

        // 시리즈 분석 데이터 로드
        async function loadSeriesAnalysisData() {
            try {
                const response = await fetch(`magic-number/data/analysis-series.json?v=${Date.now()}`);
                const seriesData = await response.json();
                renderSeriesAnalysis(seriesData);
            } catch (error) {
                console.error('시리즈 분석 데이터 로드 실패:', error);
                document.getElementById('seriesAnalysisContent').innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #e74c3c;">
                        <p>시리즈 분석 데이터를 로드할 수 없습니다.</p>
                        <small>시리즈 분석 스크립트를 먼저 실행해주세요.</small>
                    </div>
                `;
            }
        }

        // 시리즈 분석 렌더링 (KBO 규정에 따른 순위로 정렬)
        function renderSeriesAnalysis(seriesData) {
            const container = document.getElementById('seriesAnalysisContent');
            
            let html = `
                <div class="series-analysis-container">
                    <!-- 위닝/루징 시리즈 통계 -->
                    ${renderSeriesStatsTable(seriesData.teamStats)}
                </div>

                <style>
                .series-analysis-container {
                    margin: 0;
                }
                
                .series-analysis-container .table-container {
                    overflow-x: auto;
                    max-width: 100%;
                }


                .series-stats-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-top: 0;
                    font-size: var(--font-sm);
                }

                .series-stats-table th {
                    padding: 8px 6px;
                    text-align: center;
                    border: 1px solid #d1d5db;
                    background: #34495e;
                    color: white;
                    font-weight: var(--font-weight-semibold);
                    font-size: var(--font-base);
                    font-family: var(--font-family-base);
                    white-space: nowrap;
                }
                .series-stats-table th.sortable {
                    cursor: pointer;
                    user-select: none;
                    transition: all 0.2s ease;
                }
                .series-stats-table th.sortable:hover {
                    background: #2c3e50;
                    transform: translateY(-1px);
                }

                .series-stats-table td {
                    padding: 8px 6px;
                    border: 1px solid #d1d5db;
                    white-space: nowrap;
                    vertical-align: middle;
                }

                .series-stats-table tbody tr:nth-child(even) {
                    background-color: #f9f9f9;
                }

                .series-stats-table tbody tr:hover {
                    background-color: #f0f8ff;
                }


                @media (max-width: 768px) {
                    .series-stats-table {
                        font-size: var(--font-base);
                    }
                    
                    .series-stats-table th,
                    .series-stats-table td {
                        padding: 6px 4px;
                    }
                    
                    /* 순위와 팀명 스티키 설정 */
                    #seriesStatsTable thead th:first-child,
                    #seriesStatsTable tbody td:first-child {
                        position: sticky !important;
                        left: 0 !important;
                        z-index: 10 !important;
                        background: #ffffff !important;
                    }
                    
                    #seriesStatsTable thead th:nth-child(2),
                    #seriesStatsTable tbody td:nth-child(2) {
                        position: sticky !important;
                        left: 28px !important;
                        z-index: 10 !important;
                        background: #ffffff !important;
                    }
                    
                    #seriesStatsTable thead th:first-child,
                    #seriesStatsTable thead th:nth-child(2) {
                        background: #34495e !important;
                        z-index: 11 !important;
                    }
                    
                    #seriesStatsTable tbody td:first-child,
                    #seriesStatsTable tbody td:nth-child(2) {
                        border-right: 2px solid #d1d5db !important;
                    }
                    
                    /* 짝수 행에서도 스티키 컬럼 배경색 유지 */
                    #seriesStatsTable tbody tr:nth-child(even) td:first-child,
                    #seriesStatsTable tbody tr:nth-child(even) td:nth-child(2) {
                        background: #f9f9f9 !important;
                    }
                    
                    /* 시리즈 분석 테이블만 특별 처리 - 상속받되 셀 폭만 강화 */
                    #seriesStatsTable {
                        table-layout: fixed !important;
                        max-width: 400px !important;
                    }
                    
                    /* 셀 폭만 강화 적용 - 다른 스타일은 상위 상속 */
                    #seriesStatsTable th:nth-child(1), #seriesStatsTable td:nth-child(1) { 
                        width: 30px !important; 
                        min-width: 30px !important; 
                        max-width: 30px !important; 
                    }
                    #seriesStatsTable th:nth-child(2), #seriesStatsTable td:nth-child(2) { 
                        width: 70px !important; 
                        min-width: 70px !important; 
                        max-width: 70px !important; 
                    }
                    #seriesStatsTable th:nth-child(3), #seriesStatsTable td:nth-child(3) { 
                        width: 50px !important; 
                        min-width: 50px !important; 
                        max-width: 50px !important; 
                    }
                    #seriesStatsTable th:nth-child(4), #seriesStatsTable td:nth-child(4) { 
                        width: 30px !important; 
                        min-width: 30px !important; 
                        max-width: 30px !important; 
                    }
                    #seriesStatsTable th:nth-child(5), #seriesStatsTable td:nth-child(5) { 
                        width: 30px !important; 
                        min-width: 30px !important; 
                        max-width: 30px !important; 
                    }
                    #seriesStatsTable th:nth-child(6), #seriesStatsTable td:nth-child(6) { 
                        width: 20px !important; 
                        min-width: 20px !important; 
                        max-width: 20px !important; 
                    }
                    #seriesStatsTable th:nth-child(7), #seriesStatsTable td:nth-child(7) { 
                        width: 70px !important; 
                        min-width: 70px !important; 
                        max-width: 70px !important; 
                    }
                    #seriesStatsTable th:nth-child(8), #seriesStatsTable td:nth-child(8) { 
                        width: 50px !important; 
                        min-width: 50px !important; 
                        max-width: 50px !important; 
                    }
                    #seriesStatsTable th:nth-child(9), #seriesStatsTable td:nth-child(9) { 
                        width: 50px !important; 
                        min-width: 50px !important; 
                        max-width: 50px !important; 
                    }
                    #seriesStatsTable th:nth-child(10), #seriesStatsTable td:nth-child(10) { 
                        width: 75px !important; 
                        min-width: 75px !important; 
                        max-width: 75px !important; 
                    }
                    
                    /* 스티키 컬럼 스타일 비활성화 */
                    #seriesStatsTable th:first-child,
                    #seriesStatsTable td:first-child,
                    #seriesStatsTable th:nth-child(2),
                    #seriesStatsTable td:nth-child(2) {
                        position: static !important;
                        left: auto !important;
                    }
                }
                
                /* 연승/연패 기록 분석 테이블 스타일 */
                .streak-records-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-top: 0;
                    font-size: var(--font-base);
                }
                
                .streak-records-table th,
                .streak-records-table td {
                    padding: 8px 6px;
                    text-align: center;
                    border: 1px solid #d1d5db;
                    white-space: nowrap;
                }
                
                .streak-records-table th {
                    background: #34495e;
                    color: white;
                    font-weight: var(--font-weight-semibold);
                    font-size: var(--font-base);
                    font-family: var(--font-family-base);
                    cursor: pointer;
                    transition: background 0.2s ease;
                    user-select: none;
                    position: relative;
                }
                
                .streak-records-table th:hover {
                    background: #2c3e50;
                }
                
                .streak-records-table th.sortable::after {
                    content: '';
                }
                
                .streak-records-table th.sort-asc::after {
                    content: '';
                }
                
                .streak-records-table th.sort-desc::after {
                    content: '';
                }
                
                /* 연승/연패 테이블 헤더 스타일 */
                .streak-records-table .rank-header {
                    width: 40px;
                    min-width: 40px;
                    max-width: 40px;
                }
                
                .streak-records-table .team-header {
                    width: 70px;
                    min-width: 70px;
                    max-width: 70px;
                }
                
                .streak-records-table .section-header {
                    font-size: var(--font-lg) !important;
                    background: #2c3e50 !important;
                    color: white !important;
                    border-bottom: 2px solid #34495e !important;
                    padding: 12px 8px !important;
                }
                
                .streak-records-table .wins-section {
                    background: #2c3e50 !important;
                }
                
                .streak-records-table .losses-section {
                    background: #2c3e50 !important;
                }
                
                .streak-records-table .max-header {
                    width: 35px;
                    min-width: 35px;
                    max-width: 35px;
                    font-size: var(--font-xs) !important;
                    line-height: 1.1;
                }
                
                .streak-records-table .streak-count-header {
                    width: 35px;
                    min-width: 35px;
                    max-width: 35px;
                    font-size: 11px !important;
                }
                
                /* 더 구체적인 선택자로 강제 적용 */
                table.streak-records-table thead tr.sub-header th.streak-count-header {
                    font-size: 11px !important;
                }
                
                .streak-records-table thead th.streak-count-header.wins-count,
                .streak-records-table thead th.streak-count-header.losses-count {
                    font-size: 11px !important;
                }
                
                /* 최고 우선순위로 강제 적용 */
                #streakRecordsTable thead th[class*="streak-count-header"] {
                    font-size: 11px !important;
                    font-family: var(--font-family-base) !important;
                }
                
                /* 연승/연패 테이블 셀 스타일 */
                .streak-records-table .rank-cell {
                    width: 40px;
                    min-width: 40px;
                    max-width: 40px;
                    font-weight: var(--font-weight-bold);
                    text-align: center;
                    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
                    color: #495057;
                }
                
                .streak-records-table .team-cell {
                    width: 70px;
                    min-width: 70px;
                    max-width: 70px;
                    font-weight: var(--font-weight-semibold);
                    text-align: center;
                }
                
                .streak-records-table .streak-count-cell {
                    width: 35px;
                    min-width: 35px;
                    max-width: 35px;
                    font-size: var(--font-sm);
                }
                
                .streak-records-table .streak-count-cell.has-data {
                    font-weight: var(--font-weight-semibold);
                    color: #495057;
                }
                
                .streak-records-table .streak-count-cell.no-data {
                    color: #6c757d;
                    opacity: 0.7;
                }
                
                .streak-records-table .max-streak-cell {
                    width: 35px;
                    min-width: 35px;
                    max-width: 35px;
                    font-weight: var(--font-weight-bold);
                    font-size: var(--font-sm);
                }
                
                .streak-records-table .max-wins-cell {
                    background: rgba(76, 175, 80, 0.1);
                    color: #2e7d32;
                }
                
                .streak-records-table .max-losses-cell {
                    background: rgba(244, 67, 54, 0.1);
                    color: #c62828;
                }
                
                /* 연승/연패 테이블 행 스타일 */
                .streak-records-table tbody tr:nth-child(even) {
                    background-color: #f9f9f9;
                }
                
                .streak-records-table tbody tr:hover {
                    background-color: #f0f8ff;
                }
                
                /* 순위별 특별 표시 */
                .streak-records-table .rank-1 { 
                    background: linear-gradient(135deg, #ffd700, #ffed4e) !important; 
                    color: #8b5a00 !important; 
                    font-weight: var(--font-weight-bold) !important;
                }
                .streak-records-table .rank-2 { 
                    background: linear-gradient(135deg, #e8e8e8, #c0c0c0) !important; 
                    color: #4a4a4a !important; 
                    font-weight: var(--font-weight-bold) !important;
                }
                .streak-records-table .rank-3 { 
                    background: linear-gradient(135deg, #cd7f32, #b8860b) !important; 
                    color: #ffffff !important; 
                    font-weight: var(--font-weight-bold) !important;
                }
                
                @media (max-width: 768px) {
                    .streak-records-table {
                        font-size: var(--font-sm);
                    }
                    
                    .streak-records-table th,
                    .streak-records-table td {
                        padding: 6px 4px;
                    }
                    
                    .streak-records-table .section-header {
                        font-size: var(--font-base) !important;
                        padding: 10px 6px !important;
                    }
                    
                    .streak-records-table .streak-count-header {
                        font-size: 9px !important;
                        width: 30px;
                        min-width: 30px;
                        max-width: 30px;
                    }
                    
                    /* 모바일에서 더 구체적인 선택자로 강제 적용 */
                    table.streak-records-table thead tr.sub-header th.streak-count-header,
                    .streak-records-table thead th.streak-count-header.wins-count,
                    .streak-records-table thead th.streak-count-header.losses-count {
                        font-size: 9px !important;
                    }
                    
                    /* 모바일 최고 우선순위 */
                    #streakRecordsTable thead th[class*="streak-count-header"] {
                        font-size: 9px !important;
                    }
                    
                    .streak-records-table .streak-count-cell {
                        width: 30px;
                        min-width: 30px;
                        max-width: 30px;
                        font-size: var(--font-xs);
                    }
                    
                    .streak-records-table .max-header {
                        width: 28px;
                        min-width: 28px;
                        max-width: 28px;
                        font-size: 10px !important;
                    }
                    
                    .streak-records-table .max-streak-cell {
                        width: 28px;
                        min-width: 28px;
                        max-width: 28px;
                        font-size: 10px;
                    }
                }
                
                </style>
            `;

            container.innerHTML = html;
            
            // 시리즈 분석 테이블 정렬 기능 초기화 및 모바일 셀 폭 적용
            setTimeout(() => {
                const table = document.getElementById('seriesStatsTable');
                
                // 모바일에서 셀 폭 강제 적용
                if (table && window.innerWidth <= 768) {
                    
                    // 테이블 기본 스타일
                    table.style.tableLayout = 'fixed';
                    table.style.maxWidth = '600px';
                    table.style.width = '600px';
                    table.style.minWidth = '600px';
                    
                    // 각 컬럼별 폭 정의
                    const widths = [28, 60, 35, 28, 28, 20, 55, 35, 35, 75];
                    
                    // 헤더 셀 폭 적용
                    const headerCells = table.querySelectorAll('thead th');
                    headerCells.forEach((cell, index) => {
                        if (widths[index]) {
                            cell.style.width = widths[index] + 'px';
                            cell.style.minWidth = widths[index] + 'px';
                            cell.style.maxWidth = widths[index] + 'px';
                            cell.style.padding = '6px 2px';
                            cell.style.textAlign = 'center';
                            
                            // 순위와 팀명 컬럼 스티키 설정
                            if (index === 0) {  // 순위
                                cell.style.position = 'sticky';
                                cell.style.left = '0';
                                cell.style.zIndex = '11';
                                cell.style.background = '#34495e';
                            } else if (index === 1) {  // 팀명
                                cell.style.position = 'sticky';
                                cell.style.left = '28px';
                                cell.style.zIndex = '11';
                                cell.style.background = '#34495e';
                            }
                            
                        }
                    });
                    
                    // 데이터 셀 폭 적용
                    const dataRows = table.querySelectorAll('tbody tr');
                    dataRows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        cells.forEach((cell, index) => {
                            if (widths[index]) {
                                cell.style.width = widths[index] + 'px';
                                cell.style.minWidth = widths[index] + 'px';
                                cell.style.maxWidth = widths[index] + 'px';
                                cell.style.padding = '6px 2px';
                                cell.style.textAlign = 'center';
                                cell.style.overflow = 'hidden';
                                cell.style.textOverflow = 'ellipsis';
                                
                                // 순위와 팀명 컬럼 스티키 설정
                                if (index === 0) {  // 순위
                                    cell.style.position = 'sticky';
                                    cell.style.left = '0';
                                    cell.style.zIndex = '10';
                                    cell.style.background = '#ffffff';
                                    cell.style.borderRight = '2px solid #d1d5db';
                                } else if (index === 1) {  // 팀명
                                    cell.style.position = 'sticky';
                                    cell.style.left = '28px';
                                    cell.style.zIndex = '10';
                                    cell.style.background = '#ffffff';
                                    cell.style.borderRight = '2px solid #d1d5db';
                                }
                            }
                        });
                    });
                    
                } else if (table) {
                    // 데스크톱에서는 max-width 제거하고 자연스럽게
                    table.style.removeProperty('max-width');
                    table.style.width = '100%';
                    table.style.tableLayout = 'auto';
                }
                
                makeTableSortable('seriesStatsTable');
                
                // 기본적으로 순위 컬럼으로 정렬 (오름차순)
                const seriesTable = document.getElementById('seriesStatsTable');
                if (seriesTable) {
                    const rankHeader = seriesTable.querySelector('th[data-column="rank"]');
                    if (rankHeader) {
                        // 순위 컬럼으로 강제 정렬
                        rankHeader.click();
                        // 내림차순이면 다시 클릭해서 오름차순으로
                        if (rankHeader.classList.contains('sort-desc')) {
                            rankHeader.click();
                        }
                    }
                }
            }, 100);
        }

        // 시리즈 통계 테이블 렌더링 (종합 순위와 동일한 방식)
        function renderSeriesStatsTable(teamStats) {
            if (!dashboardData?.standings) return '';
            
            const teamsWithRanks = [];
            
            // 종합 순위 기준으로 순회
            const teams = getRankingSystem().teams;
            teams.forEach((teamName, index) => {
                // 시리즈 데이터가 있는 팀만 포함
                if (!teamStats[teamName]) return;
                
                // dashboardData에서 팀 정보 찾기
                const team = dashboardData.standings.find(t => t.team_name === teamName);
                if (!team) return;
                
                // KBO 규정 동률 처리가 적용된 순위 사용 (배열 순서 기준)
                const teamRanks = getRankingSystem().teamRanks;
                const displayRank = teamRanks[teamName] || (index + 1);
                
                teamsWithRanks.push({
                    name: team.team_name,
                    rank: displayRank
                });
            });
            
            // 순위별로 정렬하여 표시 순서 확정
            teamsWithRanks.sort((a, b) => a.rank - b.rank);

            let html = `

                <div class="table-container">
                    <table class="series-stats-table sortable-table" id="seriesStatsTable" style="table-layout: fixed !important; max-width: 400px !important;">
                        <thead>
                            <tr>
                                <th class="sortable" data-column="rank" style="width: 30px !important; min-width: 30px !important; max-width: 30px !important;">순위</th>
                                <th class="sortable" data-column="team" style="width: 70px !important; min-width: 70px !important; max-width: 70px !important;">팀명</th>
                                <th class="sortable" data-column="totalSeries" style="width: 50px !important; min-width: 50px !important; max-width: 50px !important;">시리즈</th>
                                <th class="sortable" data-column="seriesWins" style="width: 30px !important; min-width: 30px !important; max-width: 30px !important;">위닝</th>
                                <th class="sortable" data-column="seriesLosses" style="width: 30px !important; min-width: 30px !important; max-width: 30px !important;">루징</th>
                                <th class="sortable" data-column="seriesDraws" style="width: 20px !important; min-width: 20px !important; max-width: 20px !important;">무</th>
                                <th class="sortable" data-column="seriesWinRate" style="width: 70px !important; min-width: 70px !important; max-width: 70px !important;">시리즈 승률</th>
                                <th class="sortable" data-column="sweepWins" style="width: 50px !important; min-width: 50px !important; max-width: 50px !important;">스윕승</th>
                                <th class="sortable" data-column="sweepLosses" style="width: 50px !important; min-width: 50px !important; max-width: 50px !important;">스윕패</th>
                                <th class="sortable" data-column="currentStreak" style="width: 75px !important; min-width: 75px !important; max-width: 75px !important;">연속기록</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            teamsWithRanks.forEach((teamData, index) => {
                const teamName = teamData.name;
                const rank = teamData.rank;
                const stats = teamStats[teamName];
                
                let streakText = '없음';
                let streakClass = 'neutral';
                if (stats.currentStreak.count > 0) {
                    if (stats.currentStreak.type === 'WIN') {
                        streakText = `${stats.currentStreak.count}연속 위닝시리즈`;
                        streakClass = 'positive';
                    } else if (stats.currentStreak.type === 'LOSS') {
                        streakText = `${stats.currentStreak.count}연속 루징시리즈`;
                        streakClass = 'negative';
                    } else {
                        streakText = `${stats.currentStreak.count}연속 드로우시리즈`;
                        streakClass = 'neutral';
                    }
                }

                html += `
                    <tr data-rank="${rank}" 
                        data-team="${teamName}" 
                        data-totalseries="${stats.totalSeries}"
                        data-serieswins="${stats.winningSeries}"
                        data-serieslosses="${stats.losingSeries}"
                        data-seriesdraws="${stats.splitSeries}"
                        data-serieswinrate="${parseFloat(stats.seriesWinRate) / 100}"
                        data-sweepwins="${stats.sweepWins}"
                        data-sweeplosses="${stats.sweepLosses}"
                        data-currentstreak="${stats.currentStreak.count}">
                        <td style="text-align: center;"><strong>${rank || (index + 1)}</strong></td>
                        <td>${getTeamWithLogo(teamName)}</td>
                        <td style="text-align: center;"><strong>${stats.totalSeries}</strong></td>
                        <td style="color: #4CAF50; font-weight: var(--font-weight-bold); text-align: center;">${stats.winningSeries}</td>
                        <td style="color: #F44336; font-weight: var(--font-weight-bold); text-align: center;">${stats.losingSeries}</td>
                        <td style="text-align: center;">${stats.splitSeries}</td>
                        <td style="text-align: center;"><strong>${(parseFloat(stats.seriesWinRate) / 100).toFixed(3)}</strong></td>
                        <td style="color: #4CAF50; font-weight: var(--font-weight-bold); text-align: center;">${stats.sweepWins}</td>
                        <td style="color: #F44336; font-weight: var(--font-weight-bold); text-align: center;">${stats.sweepLosses}</td>
                        <td class="${streakClass}" style="font-weight: var(--font-weight-bold); text-align: center;">${streakText}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
                
                <!-- 설명 섹션 -->
                <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                    <div style="font-size: var(--font-base); font-weight: var(--font-weight-medium); margin-bottom: 8px; color: #495057;">⚔️ 시리즈 성적 설명</div>
                    <div style="font-size: var(--font-sm); color: #4b5563; line-height: 1.5;">
                        <div style="margin-bottom: 6px;"><strong>시리즈:</strong> 같은 상대팀과 연속으로 치르는 경기 묶음 (보통 2-4경기)</div>
                        <div style="margin-bottom: 6px;"><strong>위닝/루징 시리즈:</strong> 시리즈에서 승리/패배한 경우</div>
                        <div style="margin-bottom: 6px;"><strong>스윕승/스윕패:</strong> 시리즈에서 모든 경기를 완전히 승리/패배한 경우 (위닝/루징 시리즈에 포함)</div>
                        <div style="margin-bottom: 6px;"><strong>시리즈 승률:</strong> 위닝시리즈 수 ÷ (위닝 + 루징 + 무) × 100</div>
                        <div><strong>연속기록:</strong> 완료된 이전 시리즈에서의 위닝/루징 연속 횟수 (진행 중인 시리즈 제외, 단 2승/2패 확정시는 표시)</div>
                    </div>
                </div>
                
                <style>
                .positive { color: #4CAF50; }
                .negative { color: #F44336; }
                .neutral { color: #666; }
                </style>
            `;

            return html;
        }

        let seasonProgressInitialized = false;
        
        function updateSeasonProgress() {
            if (!dashboardData?.standings || seasonProgressInitialized) return;
            seasonProgressInitialized = true;

            const teams = dashboardData.standings;
            const totalGames = teams.reduce((sum, team) => sum + parseInt(team.games_played), 0) / 2;
            const overallProgress = Math.min((totalGames / 720) * 100, 100);

            // 팀 설정
            const teamData = {
                'LG': { name: 'LG 트윈스', color: '#C30452', logo: 'lg' },
                'KIA': { name: 'KIA 타이거즈', color: '#EA0029', logo: 'kia' },
                'SSG': { name: 'SSG 랜더스', color: '#CE0E2D', logo: 'ssg' },
                '삼성': { name: '삼성 라이온즈', color: '#1E22AA', logo: 'samsung' },
                '두산': { name: '두산 베어스', color: '#131230', logo: 'doosan' },
                'KT': { name: 'KT 위즈', color: '#000000', logo: 'kt' },
                'NC': { name: 'NC 다이노스', color: '#315288', logo: 'nc' },
                '롯데': { name: '롯데 자이언츠', color: '#041E42', logo: 'lotte' },
                '한화': { name: '한화 이글스', color: '#FF6600', logo: 'hanwha' },
                '키움': { name: '키움 히어로즈', color: '#570D28', logo: 'kiwoom' }
            };

            // 팀별 진행률 HTML 생성
            const teamProgressHTML = teams.map(team => {
                const played = parseInt(team.games_played);
                const progress = Math.min((played / 144) * 100, 100);
                const data = teamData[team.team_name] || { name: team.team_name, color: '#6366f1', logo: team.team_name.toLowerCase() };

                return `
                    <div class="team-progress-card">
                        <div class="team-progress-header">
                            <div class="team-info">
                                <img src="magic-number/images/teams/${data.logo}.png" alt="${data.name}" 
                                     class="team-logo-progress" 
                                     onerror="this.style.display='none';">
                                <span class="team-name">${team.team_name}</span>
                            </div>
                            <span class="progress-percentage" style="color: ${data.color};">${progress.toFixed(1)}%</span>
                        </div>
                        <div class="team-progress-bar">
                            <div class="team-progress-fill" 
                                 style="background: linear-gradient(90deg, ${data.color}, ${data.color}bb); width: 0%;">
                            </div>
                        </div>
                        <div class="progress-stats">
                            <div class="stat-item">
                                <span class="stat-number">${played}</span>
                                <span class="stat-label">완료</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number">${144 - played}</span>
                                <span class="stat-label">남음</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // DOM 업데이트
            const container = document.getElementById('team-progress-container');
            container.innerHTML = teamProgressHTML;

            // 브라우저가 DOM 업데이트를 완료할 때까지 대기
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const overallBar = document.getElementById('overall-progress-bar');
                    const overallText = document.getElementById('overall-progress-text');
                    const gamesInfo = document.getElementById('games-info');
                    const fillElements = container.querySelectorAll('.team-progress-fill');

                    // 모든 스타일 변경을 한 번에 적용
                    overallBar.style.width = `${overallProgress}%`;
                    overallText.textContent = `${overallProgress.toFixed(2)}%`;
                    gamesInfo.textContent = `${totalGames}/${720} 경기 완료`;

                    // 팀별 진행률도 한 번에 적용
                    teams.forEach((team, i) => {
                        const progress = Math.min((parseInt(team.games_played) / 144) * 100, 100);
                        if (fillElements[i]) {
                            fillElements[i].style.width = `${progress}%`;
                        }
                    });
                });
            });
        }

        // 페이지 세션 리셋 함수 - 빠른 초기화로 성능 개선
        function resetPageSession() {
            try {
                // 1. 핵심 전역 변수만 빠르게 초기화
                window.currentKBOData = null;
                window.dashboardData = null;
                window.weeklyAnalysisData = null;
                
                // 2. sessionStorage만 초기화 (빠른 처리)
                sessionStorage.clear();
                
                
                console.log('✅ 빠른 세션 리셋 완료');
                
            } catch (error) {
                console.warn('⚠️ 세션 리셋 오류:', error);
            }
        }

        // 전체 사이트 순위 표시 새로고침
        function refreshAllRankingDisplays() {
            try {
                // 메인 순위표 새로고침
                if (typeof renderFullStandings === 'function') {
                    renderFullStandings();
                }
                
                // 피타고리안 테이블 새로고침
                if (typeof renderPythagoreanTable === 'function') {
                    renderPythagoreanTable();
                }
                
                // 클러치 지수 테이블 새로고침
                if (typeof renderClutchIndexTable === 'function') {
                    renderClutchIndexTable();
                }
                
                // 홈/원정 테이블 새로고침
                if (typeof renderHomeAwayTable === 'function') {
                    renderHomeAwayTable();
                }
            } catch (error) {
                console.error('순위 표시 새로고침 실패:', error);
            }
        }

        // 페이지 로드 시 데이터 로드 및 정렬 기능 초기화
        window.addEventListener('DOMContentLoaded', () => {
            // 브라우저 캐시 강제 삭제
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => {
                        caches.delete(name);
                    });
                });
            }
            
            // Service Worker 캐시도 삭제
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    registrations.forEach(registration => {
                        registration.update();
                    });
                });
            }
            
            // JavaScript 실행 시간 로그
            console.log(`🚀 KBO Dashboard 시작: ${new Date().toLocaleString()}`);
            
            // 세션 리셋: 페이지 로드 시 JavaScript 상태 초기화
            resetPageSession();
            
            // 대시보드 데이터 로드
            loadDashboardData().then(async () => {
                // 대시보드 로드 완료 후 정렬 기능 즉시 초기화 (최적화)
                requestAnimationFrame(async () => {
                    // 종합 순위 기준으로 강제 정렬
                    if (dashboardData && dashboardData.standings) {
                        await sortStandingsByWinRateAndHeadToHead();
                    }
                    
                    initializeTableSorting();
                    updateSeasonProgress(); // 시즌 진행률 업데이트 (한 번만)
                    
                    // 모든 테이블 다시 렌더링하여 일관된 순위 적용
                    setTimeout(() => {
                        refreshAllRankingDisplays();
                    }, 500);
                });
            }).catch(error => {
                console.error('대시보드 데이터 로드 실패:', error);
            });
            
            // 주차별/게임별/팀별 데이터 로드 (병렬)
            loadWeeklyAnalysisData().catch(error => {
                console.error('주차별 데이터 로드 실패:', error);
            });
            
            
            // 네비게이션 활성 상태 관리
            initializeNavigation();
        });

        // 네비게이션 초기화 및 스크롤 감지
        function initializeNavigation() {
            // 페이지 로드 시 URL 해시 제거 (3초 후)
            if (window.location.hash) {
                setTimeout(() => {
                    history.replaceState(null, null, window.location.pathname + window.location.search);
                }, 3000);
            }
            
            const navItems = document.querySelectorAll('.nav-item');
            const sections = document.querySelectorAll('.card[id]');
            
            // 스크롤 이벤트 리스너
            let isScrolling = false;
            window.addEventListener('scroll', () => {
                if (!isScrolling) {
                    window.requestAnimationFrame(() => {
                        updateActiveNavItem();
                        isScrolling = false;
                    });
                    isScrolling = true;
                }
            });
            
            // 초기 활성 상태 설정
            updateActiveNavItem();
            
            // 네비게이션 클릭 이벤트
            navItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    // 매직넘버 링크는 외부 링크이므로 예외 처리
                    if (item.classList.contains('magic-number-nav')) {
                        // 외부 링크는 그대로 진행
                        return;
                    }

                    // 매직넘버 방식 개선: 브라우저 기본 스크롤 + 네비 높이만 고려
                    e.preventDefault();
                    const targetId = item.getAttribute('href').substring(1);
                    const targetSection = document.getElementById(targetId);

                    if (targetSection) {
                        // 네비게이션 높이만 고려한 최소한의 오프셋
                        const nav = document.querySelector('.navigation');
                        const navHeight = nav ? nav.offsetHeight : 80;

                        // 섹션 위치에서 네비 높이만 빼기 (간단한 계산)
                        const targetPosition = targetSection.offsetTop - navHeight;

                        window.scrollTo({
                            top: Math.max(0, targetPosition),
                            behavior: 'smooth'
                        });
                    }
                });
            });
        }
        
        // 현재 보이는 섹션에 따라 네비게이션 활성 상태 업데이트
        function updateActiveNavItem() {
            const navItems = document.querySelectorAll('.nav-item');
            const sections = document.querySelectorAll('.card[id]');
            const scrollPosition = window.scrollY + window.innerHeight / 3;
            
            let activeSection = null;
            
            // 현재 스크롤 위치에서 가장 가까운 섹션 찾기
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionBottom = sectionTop + section.offsetHeight;
                
                if (scrollPosition >= sectionTop && scrollPosition <= sectionBottom) {
                    activeSection = section.id;
                }
            });
            
            // 페이지 상단에 있을 때는 첫 번째 섹션을 활성화
            if (window.scrollY < 100) {
                activeSection = 'season-progress';
            }
            
            // 네비게이션 아이템 활성 상태 업데이트
            let activeNavItem = null;
            navItems.forEach(item => {
                const targetId = item.getAttribute('href').substring(1);
                if (targetId === activeSection) {
                    item.classList.add('active');
                    activeNavItem = item;
                } else {
                    item.classList.remove('active');
                }
            });
            
            // 모바일에서 활성화된 네비게이션 아이템이 화면에 보이도록 스크롤
            if (activeNavItem && window.innerWidth <= 768) {
                const navMenu = document.querySelector('.nav-menu');
                if (navMenu) {
                    // 네비게이션 메뉴의 스크롤 위치 계산
                    const navMenuRect = navMenu.getBoundingClientRect();
                    const activeItemRect = activeNavItem.getBoundingClientRect();
                    
                    // 활성 아이템이 보이는 영역에 없다면 스크롤
                    if (activeItemRect.left < navMenuRect.left || activeItemRect.right > navMenuRect.right) {
                        activeNavItem.scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'center'
                        });
                    }
                }
            }
        }
    </script>


    </div>

    <!-- 푸터 섹션 -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h2 style="white-space: nowrap;">🤖 KBO 2025 종합 분석 대시보드</h2>
                <p>한국프로야구의 모든 데이터를 한눈에 분석하고 비교할 수 있는 종합 대시보드입니다.</p>
            </div>
            
            <div class="footer-section">
                <h3>KBO 팀 정보</h3>
                <div class="team-links">
                    <a href="https://www.hanwhaeagles.co.kr" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/hanwha.png" alt="한화 이글스" class="team-logo" loading="lazy" loading="lazy">
                        <span>한화 이글스</span>
                    </a>
                    <a href="https://www.lgtwins.com" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/lg.png" alt="LG 트윈스" class="team-logo" loading="lazy" loading="lazy">
                        <span>LG 트윈스</span>
                    </a>
                    <a href="https://www.giantsclub.com" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/lotte.png" alt="롯데 자이언츠" class="team-logo" loading="lazy">
                        <span>롯데 자이언츠</span>
                    </a>
                    <a href="https://www.ssglanders.com" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/ssg.png" alt="SSG 랜더스" class="team-logo" loading="lazy">
                        <span>SSG 랜더스</span>
                    </a>
                    <a href="https://www.ktwiz.co.kr" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/kt.png" alt="KT 위즈" class="team-logo" loading="lazy">
                        <span>KT 위즈</span>
                    </a>
                    <a href="https://tigers.co.kr" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/kia.png" alt="KIA 타이거즈" class="team-logo" loading="lazy">
                        <span>KIA 타이거즈</span>
                    </a>
                    <a href="https://www.samsunglions.com" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/samsung.png" alt="삼성 라이온즈" class="team-logo" loading="lazy">
                        <span>삼성 라이온즈</span>
                    </a>
                    <a href="https://www.ncdinos.com" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/nc.png" alt="NC 다이노스" class="team-logo" loading="lazy">
                        <span>NC 다이노스</span>
                    </a>
                    <a href="https://www.doosanbears.com" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/doosan.png" alt="두산 베어스" class="team-logo" loading="lazy">
                        <span>두산 베어스</span>
                    </a>
                    <a href="https://www.heroesbaseball.co.kr" target="_blank" rel="noopener" class="team-link-item">
                        <img src="magic-number/images/teams/kiwoom.png" alt="키움 히어로즈" class="team-logo" loading="lazy">
                        <span>키움 히어로즈</span>
                    </a>
                </div>
            </div>
            
            <div class="footer-section">
                <h3>KBO 공식 정보</h3>
                <ul class="footer-links">
                    <li><a href="https://www.koreabaseball.com" target="_blank" rel="noopener">KBO 공식 홈페이지</a></li>
                    <li><a href="https://www.koreabaseball.com/Schedule/Schedule.aspx" target="_blank" rel="noopener">경기 일정</a></li>
                    <li><a href="https://www.koreabaseball.com/Record/TeamRank/TeamRankDaily.aspx" target="_blank" rel="noopener">팀 순위</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h3>데이터 정보</h3>
                <p class="data-info">최종 업데이트: 2025년 8월 15일</p>
                <p class="data-source">데이터 출처: KBO 공식 기록</p>
            </div>
        </div>
        
        <div class="footer-bottom">
            <p>&copy; 2025 KBO 분석 대시보드. 모든 데이터는 KBO 공식 기록을 기반으로 합니다.</p>
        </div>
    </footer>

    <style>
        .footer {
            background: linear-gradient(135deg, #1a237e 0%, #3949ab 100%);
            color: #ffffff;
            margin-top: 50px;
            padding: 40px 20px 20px 20px;
            width: 100%;
            font-family: 'Noto Sans KR', sans-serif;
            box-sizing: border-box;
            box-shadow: 0 -4px 8px rgba(0,0,0,0.12);
        }

        .footer-content {
            max-width: 1300px;
            margin: 0 auto;
            padding: 0;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
        }

        @media (max-width: 1024px) {
            .footer-content {
                grid-template-columns: repeat(2, 1fr);
                gap: 25px;
            }
        }

        @media (max-width: 640px) {
            .footer-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        .footer-section h3 {
            color: #ffd700;
            font-size: var(--font-xl);
            margin-bottom: 15px;
            font-weight: var(--font-weight-semibold);
        }

        .footer-section h4 {
            color: #ffab91;
            font-size: var(--font-lg);
            margin-bottom: 12px;
            font-weight: var(--font-weight-medium);
        }

        .footer-section p {
            font-size: var(--font-sm);
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 10px;
        }

        .team-links {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            justify-content: flex-start;
        }

        .team-link-item {
            display: flex;
            align-items: center;
            gap: 4px;
            color: rgba(255, 255, 255, 0.7);
            font-size: var(--font-xs);
            font-weight: 400;
            text-decoration: none;
            transition: color 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .team-link-item:hover {
            color: #ffd700;
        }

        .team-logo {
            width: 14px;
            height: 14px;
            object-fit: contain;
            flex-shrink: 0;
        }

        .analysis-features {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }

        .feature-tag {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: var(--font-xs);
            font-weight: var(--font-weight-semibold);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .feature-tag:hover {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .footer-links {
            list-style: none;
            padding: 0;
        }

        .footer-links li {
            margin-bottom: 8px;
        }

        .footer-links a {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-size: var(--font-sm);
            transition: color 0.3s ease;
        }

        .footer-links a:hover {
            color: #ffd700;
        }

        .data-info, .data-source {
            font-size: var(--font-xs);
            color: rgba(255, 255, 255, 0.6);
        }

        .footer-bottom {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 30px;
            padding-top: 20px;
            text-align: center;
        }

        .footer-bottom p {
            font-size: var(--font-xs);
            color: rgba(255, 255, 255, 0.6);
            margin: 0;
        }

        @media (max-width: 768px) {
            .footer-content {
                grid-template-columns: 1fr;
                gap: 25px;
            }
            
            .team-links {
                justify-content: center;
            }
        }
    </style>
    <!-- 플로팅 공유 버튼 -->
    <div class="floating-share" id="floatingShare">
        <div class="share-toggle" id="shareToggle">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
            </svg>
        </div>
        <div class="share-options" id="shareOptions">
            <button class="share-btn" data-type="copy">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                </svg>
                <span>URL 복사</span>
            </button>
            <button class="share-btn" data-type="threads">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12.186 24h-.007c-3.581-.024-6.334-1.205-8.184-3.509C2.35 18.44 1.5 15.586 1.5 12.5 1.5 9.414 2.35 6.56 3.995 4.509 5.845 2.205 8.598 1.024 12.179 1h.014c3.581.024 6.334 1.205 8.184 3.509C21.65 6.56 22.5 9.414 22.5 12.5s-.85 5.94-2.495 7.991c-1.85 2.304-4.603 3.485-8.184 3.509z"/>
                </svg>
                <span>Threads</span>
            </button>
            <button class="share-btn" data-type="twitter">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                </svg>
                <span>X (Twitter)</span>
            </button>
            <button class="share-btn" data-type="facebook">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                </svg>
                <span>Facebook</span>
            </button>
        </div>
    </div>
    
    <!-- 탑으로 가기 버튼 -->
    <button class="scroll-to-top" id="scrollToTop">↑</button>

    <script>
        // 탑으로 가기 버튼 기능 - magic-number 방식 적용
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTopButton = document.getElementById('scrollToTop');
            
            // 스크롤 이벤트 리스너
            window.addEventListener('scroll', function() {
                if (window.pageYOffset > 300) {
                    scrollToTopButton.classList.add('show');
                } else {
                    scrollToTopButton.classList.remove('show');
                }
            });
            
            // 버튼 클릭 이벤트
            scrollToTopButton.addEventListener('click', function() {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        });

        // 플로팅 공유 버튼 기능
        document.addEventListener('DOMContentLoaded', function() {
            const shareToggle = document.getElementById('shareToggle');
            const shareOptions = document.getElementById('shareOptions');
            const shareButtons = document.querySelectorAll('.share-btn');

            // 공유 옵션 토글
            shareToggle.addEventListener('click', function() {
                shareOptions.classList.toggle('show');
            });

            // 외부 클릭 시 공유 옵션 닫기
            document.addEventListener('click', function(e) {
                if (!shareToggle.contains(e.target) && !shareOptions.contains(e.target)) {
                    shareOptions.classList.remove('show');
                }
            });

            // 각 공유 버튼 이벤트
            shareButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const type = this.getAttribute('data-type');
                    const url = window.location.href;
                    const title = 'KBO 2025 실시간 순위표 | 20개 분석지표 완벽 제공';
                    const text = 'KBO 2025 실시간 순위표와 20개 분석지표! 매직넘버, 일별통계, 피타고리안, 클러치 지수 등 모든 야구 데이터를 한눈에 확인하세요.';

                    switch(type) {
                        case 'copy':
                            copyToClipboard(url);
                            break;
                        case 'threads':
                            window.open(`https://threads.net/intent/post?text=${encodeURIComponent(text + ' ' + url)}`, '_blank');
                            break;
                        case 'twitter':
                            window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`, '_blank');
                            break;
                        case 'facebook':
                            window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}&quote=${encodeURIComponent(text)}`, '_blank');
                            break;
                    }
                    
                    // 공유 후 옵션 닫기
                    shareOptions.classList.remove('show');
                });
            });

            // URL 복사 기능
            function copyToClipboard(text) {
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        showCopySuccess();
                    }).catch(() => {
                        fallbackCopyTextToClipboard(text);
                    });
                } else {
                    fallbackCopyTextToClipboard(text);
                }
            }

            // 구형 브라우저 대응 복사 기능
            function fallbackCopyTextToClipboard(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    showCopySuccess();
                } catch (err) {
                    console.error('복사 실패:', err);
                }
                
                document.body.removeChild(textArea);
            }

            // 복사 성공 메시지
            function showCopySuccess() {
                const originalText = shareButtons[0].querySelector('span').textContent;
                shareButtons[0].querySelector('span').textContent = '복사됨!';
                shareButtons[0].style.color = '#4caf50';
                
                setTimeout(() => {
                    shareButtons[0].querySelector('span').textContent = originalText;
                    shareButtons[0].style.color = '';
                }, 2000);
            }
        });

        // 네비게이션 스크롤 및 활성화 관리
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('.card[id]');
            const navItems = document.querySelectorAll('.nav-item'); // navItems 정의 추가

            // 활성화된 네비게이션 아이템 업데이트 함수
            function updateActiveNavItem(activeItem) {
                navItems.forEach(item => item.classList.remove('active'));
                activeItem.classList.add('active');
                
                // 활성화된 아이템이 네비게이션 영역에 보이도록 스크롤
                scrollNavToActiveItem(activeItem);
            }
            
            // 네비게이션을 활성화된 아이템이 중앙에 오도록 스크롤
            function scrollNavToActiveItem(activeItem) {
                const navContainer = document.querySelector('.nav-menu');
                if (navContainer && activeItem) {
                    // 항상 아이템을 중앙에 위치시키도록 스크롤
                    const scrollLeft = activeItem.offsetLeft - 
                                     (navContainer.clientWidth / 2) + 
                                     (activeItem.clientWidth / 2);
                    
                    navContainer.scrollTo({
                        left: Math.max(0, scrollLeft), // 음수 값 방지
                        behavior: 'smooth'
                    });
                }
            }
            
            // 가장 가까운 섹션 찾기
            function findClosestSection(targetId) {
                const sectionMapping = {
                    'gamerecords': 'teamdetail',
                    'weekday': 'monthly', 
                    'weekly': 'monthly'
                };
                
                const fallbackId = sectionMapping[targetId];
                return fallbackId ? document.getElementById(fallbackId) : sections[0];
            }
            
            // 스크롤 시 활성화된 섹션 감지
            const observer = new IntersectionObserver(
                (entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const activeNavItem = document.querySelector(`a[href="#${entry.target.id}"]`);
                            if (activeNavItem) {
                                updateActiveNavItem(activeNavItem);
                            }
                        }
                    });
                },
                { rootMargin: '-50% 0px -50% 0px' }
            );
            
            sections.forEach(section => {
                observer.observe(section);
            });
        });
    </script>

    <!-- Chart.js 지연 로딩으로 성능 최적화 -->
    <script>
        // Chart.js 지연 로딩 함수
        let chartJsLoaded = false;
        let chartJsLoadPromise = null;
        
        function loadChartJs() {
            if (chartJsLoaded) return Promise.resolve();
            if (chartJsLoadPromise) return chartJsLoadPromise;
            
            chartJsLoadPromise = new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.js';
                script.onload = () => {
                    chartJsLoaded = true;
                    console.log('Chart.js loaded lazily');
                    resolve();
                };
                script.onerror = () => reject(new Error('Chart.js loading failed'));
                // 성능 최적화: async 속성 추가
                script.async = true;
                document.head.appendChild(script);
            });
            
            return chartJsLoadPromise;
        }
        
        // 전역으로 노출
        window.loadChartJs = loadChartJs;
        
        // Web Vitals 모니터링 (성능 측정)
        function measureWebVitals() {
            // Largest Contentful Paint (LCP)
            new PerformanceObserver((entryList) => {
                const entries = entryList.getEntries();
                const lastEntry = entries[entries.length - 1];
                console.log('LCP:', lastEntry.startTime);
                
                // Google Analytics로 전송 (선택사항)
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'web_vitals', {
                        name: 'LCP',
                        value: Math.round(lastEntry.startTime),
                        event_category: 'Web Vitals'
                    });
                }
            }).observe({type: 'largest-contentful-paint', buffered: true});
            
            // First Input Delay (FID)
            new PerformanceObserver((entryList) => {
                entryList.getEntries().forEach((entry) => {
                    console.log('FID:', entry.processingStart - entry.startTime);
                    
                    if (typeof gtag !== 'undefined') {
                        gtag('event', 'web_vitals', {
                            name: 'FID',
                            value: Math.round(entry.processingStart - entry.startTime),
                            event_category: 'Web Vitals'
                        });
                    }
                });
            }).observe({type: 'first-input', buffered: true});
            
            // Cumulative Layout Shift (CLS)
            let cumulativeLayoutShift = 0;
            new PerformanceObserver((entryList) => {
                entryList.getEntries().forEach((entry) => {
                    if (!entry.hadRecentInput) {
                        cumulativeLayoutShift += entry.value;
                    }
                });
                
                // 페이지 숨김/종료 시 최종 CLS 값 전송 (visibilitychange 사용 - beforeunload 대체)
                function sendCLSData() {
                    console.log('CLS:', cumulativeLayoutShift);

                    if (typeof gtag !== 'undefined') {
                        gtag('event', 'web_vitals', {
                            name: 'CLS',
                            value: Math.round(cumulativeLayoutShift * 1000) / 1000,
                            event_category: 'Web Vitals'
                        });
                    }
                }

                // 페이지 숨김 시 (더 안정적인 방법)
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden') {
                        sendCLSData();
                    }
                });

                // 페이지 완전 종료 시 백업용
                window.addEventListener('pagehide', sendCLSData);
            }).observe({type: 'layout-shift', buffered: true});
        }
        
        // Web Vitals 측정 시작
        if (typeof PerformanceObserver !== 'undefined') {
            measureWebVitals();
        }
    </script>
    
    <!-- 일별 종합지표 분석 스크립트 -->
    <!-- daily-stats-module.js는 미완성이므로 제거 -->
    <script>
        // 전역 팀 로고 이미지 저장소
        window.teamLogoImages = {};
        
        // 팀 로고 이미지 로드 함수
        window.loadTeamLogos = function() {
            const teams = getRankingSystem().teams;
            const teamFileMap = {
                'LG': 'magic-number/images/teams/lg.png',
                'KIA': 'magic-number/images/teams/kia.png', 
                '삼성': 'magic-number/images/teams/samsung.png',
                '두산': 'magic-number/images/teams/doosan.png',
                'SSG': 'magic-number/images/teams/ssg.png',
                'NC': 'magic-number/images/teams/nc.png',
                '롯데': 'magic-number/images/teams/lotte.png',
                '한화': 'magic-number/images/teams/hanwha.png',
                'KT': 'magic-number/images/teams/kt.png',
                '키움': 'magic-number/images/teams/kiwoom.png'
            };
            
            const promises = teams.map(team => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        // 적당한 크기의 캔버스로 이미지 리사이즈
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 30;
                        canvas.height = 30;
                        ctx.drawImage(img, 0, 0, 30, 30);
                        window.teamLogoImages[team] = canvas;
                        console.log(`팀 로고 로드 성공: ${team} (${teamFileMap[team]})`);
                        resolve();
                    };
                    img.onerror = (err) => {
                        console.error(`팀 로고 로드 실패: ${team} (${teamFileMap[team]})`, err);
                        resolve();
                    };
                    img.src = teamLogos[team] || `magic-number/images/teams/${team.toLowerCase()}.png`;
                });
            });
            return Promise.all(promises);
        };
        
        // 완전한 일별 통계 시스템 - 실제 데이터 사용
        class CompleteDailyStats {
            constructor() {
                this.seasonData = [];
                // 동적으로 날짜 설정 - 초기화 후 loadSeasonData에서 실제 설정됨
                this.currentDate = null;
                this.startDate = '2025-03-22';
                this.endDate = null;
                this.teamStats = {};
                this.animationRunning = false;
                this.teamLogoImages = {};
                // 차트 인스턴스 변수들
                this.gameGapChart = null;
                this.winGapChart = null;
                this.winCountChart = null;
                this.winRateChart = null;
                this.rankChart = null;
                // 팀 가시성 관리
                this.teamVisibility = {};
                this.winCountChartVisibleTeams = new Set();
                this.winRateChartVisibleTeams = new Set();
                this.rankChartVisibleTeams = new Set();
                // 애니메이션 관련 변수들
                this.isAnimating = false;
                this.animationInterval = null;
                this.animationDate = null;
                this.animationSpeed = 3; // 기본 속도 (1=매우느림, 5=매우빠름)
                // 시즌 전체 최대 게임차 (미리 계산)
                this.maxSeasonGamesBehind = 0;
                
                // 2025년 공휴일 목록
                this.holidays = new Set([
                    '2025-01-01', // 신정
                    '2025-01-28', // 설날 연휴
                    '2025-01-29', // 설날
                    '2025-01-30', // 설날 연휴
                    '2025-03-01', // 삼일절
                    '2025-05-05', // 어린이날
                    '2025-05-06', // 대체공휴일 (어린이날)
                    '2025-05-13', // 부처님오신날
                    '2025-06-06', // 현충일
                    '2025-08-15', // 광복절
                    '2025-10-05', // 추석 연휴
                    '2025-10-06', // 추석
                    '2025-10-07', // 추석 연휴
                    '2025-10-03', // 개천절
                    '2025-10-09', // 한글날
                    '2025-12-25'  // 크리스마스
                ]);
                
                this.teamColors = {
                    'LG': '#C30452', '삼성': '#074CA1', 'KT': '#000000', '두산': '#131230',
                    'KIA': '#EA0029', 'SSG': '#CE0E2D', '롯데': '#002955', 'NC': '#315288',
                    '한화': '#FF6600', '키움': '#820024'
                };
                
                this.teamLogos = {
                    'LG': 'magic-number/images/teams/lg.png', '삼성': 'magic-number/images/teams/samsung.png', 'KT': 'magic-number/images/teams/kt.png',
                    '두산': 'magic-number/images/teams/doosan.png', 'KIA': 'magic-number/images/teams/kia.png', 'SSG': 'magic-number/images/teams/ssg.png',
                    '롯데': 'magic-number/images/teams/lotte.png', 'NC': 'magic-number/images/teams/nc.png', '한화': 'magic-number/images/teams/hanwha.png',
                    '키움': 'magic-number/images/teams/kiwoom.png'
                };
                
                this.initPromise = this.init();
            }
            
            async init() {
                try {
                    await this.loadSeasonData();
                    await this.loadTeamLogoImages();
                    this.processAllData();
                    this.updateDisplay(this.currentDate);
                    this.initCharts();
                } catch (error) {
                    console.error('일별 통계 초기화 실패:', error);
                    this.showError('데이터 로드 실패');
                }
            }
            
            async loadTeamLogoImages() {
                // dashboardData 로드 확인 후 getRankingSystem 호출
                let teams;
                if (!window.dashboardData || !window.dashboardData.standings) {
                    console.log('⚠️ dashboardData 아직 로드되지 않음, 기본 팀 목록 사용');
                    teams = ['LG', '한화', 'SSG', '삼성', 'KT', '두산', 'KIA', '롯데', 'NC', '키움'];
                } else {
                    teams = getRankingSystem().teams;
                }
                const promises = teams.map(team => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            // 적당한 크기의 캔버스로 이미지 리사이즈
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = 30;
                            canvas.height = 30;
                            ctx.drawImage(img, 0, 0, 30, 30);
                            this.teamLogoImages[team] = canvas;
                            resolve();
                        };
                        img.onerror = () => {
                            console.warn(`팀 로고 로드 실패: ${team}`);
                            resolve();
                        };
                        img.src = this.teamLogos[team];
                    });
                });
                
                await Promise.all(promises);
            }
            
            async loadSeasonData() {
                try {
                    const response = await fetch(`magic-number/data/2025-season-data-clean.txt?v=${Date.now()}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const text = await response.text();
                    this.parseSeasonData(text);
                    
                } catch (error) {
                    console.warn('실제 데이터 로드 실패, 샘플 데이터 사용:', error);
                    this.loadSampleData();
                }
            }
            
            loadSampleData() {
                const sampleData = `2025-03-22
한화 4:3 KT(H)
롯데 2:12 LG(H)
NC 2:9 KIA(H)
두산 5:6 SSG(H)
키움 5:13 삼성(H)

2025-03-23
한화 4:5 KT(H)
롯데 2:10 LG(H)
NC 5:4 KIA(H)
두산 2:5 SSG(H)
키움 7:11 삼성(H)

2025-08-19
LG 7:3 한화(H)
삼성 8:2 NC(H)
KIA 6:4 롯데(H)
SSG 5:3 두산(H)
KT 9:1 키움(H)`;
                
                this.parseSeasonData(sampleData);
            }
            
            parseSeasonData(text) {
                const lines = text.split('\n');
                const dateGamesMap = new Map(); // 날짜별 경기를 모아둘 Map
                let currentDate = null;

                for (const line of lines) {
                    const trimmedLine = line.trim();

                    // 날짜 라인 체크 (YYYY-MM-DD (요일) 형식 또는 기존 YYYY-MM-DD 형식)
                    if (/^\d{4}-\d{2}-\d{2}(\s*\([월화수목금토일]\))?$/.test(trimmedLine)) {
                        currentDate = trimmedLine.replace(/\s*\([월화수목금토일]\)/, ''); // 요일 정보 제거
                        // Map에 날짜가 없으면 빈 배열로 초기화
                        if (!dateGamesMap.has(currentDate)) {
                            dateGamesMap.set(currentDate, []);
                        }
                    } else if (trimmedLine && currentDate) {
                        // 새로운 형식 파싱: "시간 상태 구장 홈팀 어웨이팀 점수 방송사 구분"
                        const newFormatParts = trimmedLine.split(/\s+/);
                        if (newFormatParts.length >= 8) {
                            const [time, state, stadium, homeTeam, awayTeam, scoreOrStatus, broadcast, ...categoryParts] = newFormatParts;
                            const category = categoryParts.join(' ');


                            // 완료된 경기이면서 페넌트레이스 경기만 처리
                            if (state === '종료' && category.includes('페넌트레이스')) {
                                // 점수 파싱 (away:home 형식)
                                const scoreMatch = scoreOrStatus.match(/^(\d+):(\d+)$/);
                                if (scoreMatch) {
                                    const [, awayScore, homeScore] = scoreMatch;
                                    const gameData = {
                                        date: currentDate,
                                        team1: awayTeam, // 원정팀
                                        score1: parseInt(awayScore),
                                        team2: homeTeam, // 홈팀
                                        score2: parseInt(homeScore),
                                        isHome: true, // 홈/원정 구분됨
                                        time: time,
                                        stadium: stadium,
                                        broadcast: broadcast,
                                        category: category,
                                        state: state
                                    };

                                    // 중복 경기 체크
                                    const existingGames = dateGamesMap.get(currentDate);
                                    const isDuplicate = existingGames.some(game =>
                                        (game.team1 === gameData.team1 && game.team2 === gameData.team2 &&
                                         game.score1 === gameData.score1 && game.score2 === gameData.score2) ||
                                        (game.team1 === gameData.team2 && game.team2 === gameData.team1 &&
                                         game.score1 === gameData.score2 && game.score2 === gameData.score1)
                                    );

                                    if (!isDuplicate) {
                                        dateGamesMap.get(currentDate).push(gameData);
                                    }
                                }
                            }

                            // 취소/연기된 경기도 기록 (사용자가 보고 싶어함)
                            if ((state === '경기취소' || state.includes('취소') || state.includes('연기')) && category.includes('페넌트레이스')) {
                                const gameData = {
                                    date: currentDate,
                                    team1: awayTeam, // 원정팀
                                    score1: null,
                                    team2: homeTeam, // 홈팀
                                    score2: null,
                                    isHome: true,
                                    time: time,
                                    stadium: stadium,
                                    broadcast: broadcast || '',
                                    category: category,
                                    state: state,
                                    isCancelled: true
                                };

                                // 중복 체크 (취소 경기도)
                                const existingGames = dateGamesMap.get(currentDate);
                                const isDuplicate = existingGames.some(game =>
                                    game.team1 === gameData.team1 && game.team2 === gameData.team2 &&
                                    game.isCancelled === true
                                );

                                if (!isDuplicate) {
                                    dateGamesMap.get(currentDate).push(gameData);
                                }
                            }

                        } else {
                            // 기존 형식 파싱 (팀1 점수:점수 팀2(H) 또는 팀1 점수:점수 팀2) - 백업용
                            const gameMatch = trimmedLine.match(/^(.+?)\s+(\d+):(\d+)\s+(.+?)(?:\(H\))?$/);
                            if (gameMatch) {
                                const [, team1, score1, score2, team2] = gameMatch;
                                const gameData = {
                                    date: currentDate,
                                    team1: team1.trim(),
                                    score1: parseInt(score1),
                                    team2: team2.replace('(H)', '').trim(),
                                    score2: parseInt(score2),
                                    isHome: trimmedLine.includes('(H)'),
                                    state: '종료',
                                    category: '페넌트레이스' // 기존 형식은 모두 페넌트레이스로 간주
                                };

                                // 중복 경기 체크
                                const existingGames = dateGamesMap.get(currentDate);
                                const isDuplicate = existingGames.some(game =>
                                    (game.team1 === gameData.team1 && game.team2 === gameData.team2 &&
                                     game.score1 === gameData.score1 && game.score2 === gameData.score2) ||
                                    (game.team1 === gameData.team2 && game.team2 === gameData.team1 &&
                                     game.score1 === gameData.score2 && game.score2 === gameData.score1)
                                );

                                if (!isDuplicate) {
                                    dateGamesMap.get(currentDate).push(gameData);
                                }
                            }
                        }
                    }
                }

                // Map을 seasonData 배열로 변환 (날짜 순으로 정렬)
                const sortedDates = Array.from(dateGamesMap.keys()).sort();
                for (const date of sortedDates) {
                    const games = dateGamesMap.get(date);
                    if (games.length > 0) {
                        this.seasonData.push({ date: date, games: games });
                    }
                }

                // 동적으로 최신 경기 날짜 설정
                this.setLatestGameDate();

            }
            
            // 경기 결과가 있는 가장 최신 날짜를 동적으로 설정
            setLatestGameDate() {
                if (this.seasonData.length === 0) {
                    this.currentDate = this.startDate;
                    this.endDate = this.startDate;
                    return;
                }
                
                // 경기가 있는 날짜들만 필터링하여 가장 최신 날짜 찾기
                const datesWithGames = this.seasonData
                    .filter(dayData => dayData.games && dayData.games.length > 0)
                    .map(dayData => dayData.date)
                    .sort();
                
                if (datesWithGames.length > 0) {
                    this.endDate = datesWithGames[datesWithGames.length - 1];
                    this.currentDate = this.endDate;
                    
                    // HTML input 요소도 동적으로 업데이트
                    this.updateDateInputs();
                } else {
                    this.currentDate = this.startDate;
                    this.endDate = this.startDate;
                }
            }
            
            // HTML 날짜 입력 요소들을 동적으로 업데이트
            updateDateInputs() {
                const dateInput = document.getElementById('daily-stats-date-input');
                if (dateInput && this.endDate) {
                    dateInput.max = this.endDate;
                    dateInput.value = this.endDate;
                }
            }
            
            // 시즌 전체에서 최대 게임차 미리 계산
            calculateMaxSeasonGamesBehind() {
                let maxGamesBehind = 0;
                
                // 모든 날짜에 대해 게임차 계산
                this.seasonData.forEach(dayData => {
                    if (dayData.games.length > 0) { // 경기가 있는 날만
                        const standings = this.calculateStandings(dayData.date);
                        const dayMaxGamesBehind = Math.max(...standings.map(team => team.gamesBehind));
                        maxGamesBehind = Math.max(maxGamesBehind, dayMaxGamesBehind);
                    }
                });
                
                // 실제 계산된 최대 게임차 사용
                this.maxSeasonGamesBehind = maxGamesBehind;
            }
            
            processAllData() {
                const teams = getRankingSystem().teams;
                teams.forEach(team => {
                    this.teamStats[team] = {
                        games: 0, wins: 0, losses: 0, draws: 0,
                        runsFor: 0, runsAgainst: 0, dailyWinRate: []
                    };
                });
                
                // 시즌 전체 최대 게임차 미리 계산
                this.calculateMaxSeasonGamesBehind();
                
                // 날짜별 누적 계산
                for (const dayData of this.seasonData) {
                    dayData.games.forEach(game => {
                        const { team1, team2, score1, score2 } = game;
                        
                        if (this.teamStats[team1]) {
                            this.teamStats[team1].games++;
                            this.teamStats[team1].runsFor += score1;
                            this.teamStats[team1].runsAgainst += score2;
                            if (score1 > score2) this.teamStats[team1].wins++;
                            else if (score1 < score2) this.teamStats[team1].losses++;
                            else this.teamStats[team1].draws++;
                        }
                        
                        if (this.teamStats[team2]) {
                            this.teamStats[team2].games++;
                            this.teamStats[team2].runsFor += score2;
                            this.teamStats[team2].runsAgainst += score1;
                            if (score2 > score1) this.teamStats[team2].wins++;
                            else if (score2 < score1) this.teamStats[team2].losses++;
                            else this.teamStats[team2].draws++;
                        }
                    });
                }
            }
            
            calculateStandings(targetDate) {
                // 모든 날짜에 대해 일관된 계산 방식 사용 (dashboardData 의존성 제거)

                // 메인 시스템과 동일한 순위 로직 사용
                const teams = getRankingSystem().teams;
                const tempStats = {};
                
                teams.forEach(team => {
                    tempStats[team] = {
                        team_name: team,
                        team: team,
                        games: 0, 
                        wins: 0, 
                        losses: 0, 
                        draws: 0, 
                        winRate: 0, 
                        gamesBehind: 0
                    };
                });
                
                // 해당 날짜까지의 누적 데이터 계산
                for (const dayData of this.seasonData) {
                    if (dayData.date > targetDate) break;

                    dayData.games.forEach(game => {
                        // 취소된 경기는 순위 계산에서 제외
                        if (game.isCancelled) return;

                        const { team1, team2, score1, score2 } = game;

                        if (tempStats[team1]) {
                            tempStats[team1].games++;
                            if (score1 > score2) tempStats[team1].wins++;
                            else if (score1 < score2) tempStats[team1].losses++;
                            else tempStats[team1].draws++;
                        }

                        if (tempStats[team2]) {
                            tempStats[team2].games++;
                            if (score2 > score1) tempStats[team2].wins++;
                            else if (score2 < score1) tempStats[team2].losses++;
                            else tempStats[team2].draws++;
                        }
                    });
                }
                
                const standings = Object.values(tempStats);
                
                // 승률 계산 (4자리 소수점 정밀도로 메인 시스템과 동일하게)
                standings.forEach(team => {
                    const decidedGames = team.wins + team.losses;
                    const rawWinRate = decidedGames > 0 ? team.wins / decidedGames : 0;
                    team.winRate = Math.round(rawWinRate * 10000) / 10000;
                });
                
                // 메인 시스템과 동일한 정렬 로직 사용
                standings.sort((a, b) => {
                    // 1차: 승률 비교 (4자리 정밀도)
                    if (a.winRate !== b.winRate) {
                        return b.winRate - a.winRate;
                    }
                    
                    // 승률이 같을 때는 공동순위로 처리 (팀명 순서만 유지)
                    return a.team_name.localeCompare(b.team_name);
                });
                
                // 게임차 계산
                if (standings.length > 0) {
                    const leader = standings[0];
                    standings.forEach(team => {
                        const winDiff = leader.wins - team.wins;
                        const lossDiff = team.losses - leader.losses;
                        team.gamesBehind = (winDiff + lossDiff) / 2;
                    });
                }
                
                // 메인 시스템과 동일한 순위 할당 로직
                let currentRank = 1;
                for (let i = 0; i < standings.length; i++) {
                    if (i === 0) {
                        standings[i].rank = 1;
                        standings[i].displayRank = 1;
                    } else {
                        const currentTeam = standings[i];
                        const previousTeam = standings[i - 1];
                        
                        // 승률이 같으면 공동 순위 (KBO 규정)
                        if (currentTeam.winRate === previousTeam.winRate) {
                            currentTeam.rank = previousTeam.rank;
                            currentTeam.displayRank = previousTeam.displayRank;
                        } else {
                            // 승률이 다르면 새로운 순위
                            currentRank = i + 1;
                            currentTeam.rank = currentRank;
                            currentTeam.displayRank = currentRank;
                        }
                    }
                }
                
                return standings;
            }
            
            // 현재 시즌 데이터에서 최신 날짜 반환
            getCurrentMaxDate() {
                if (!this.seasonData || this.seasonData.length === 0) return null;
                return this.seasonData[this.seasonData.length - 1].date;
            }
            
            updateDisplay(date) {
                this.currentDate = date;
                
                // 날짜 표시 업데이트
                const dateObj = new Date(date + 'T00:00:00');
                const dateStr = dateObj.toLocaleDateString('ko-KR', {
                    year: 'numeric', month: 'long', day: 'numeric'
                });
                const dayStr = dateObj.toLocaleDateString('ko-KR', {
                    weekday: 'short'
                });
                
                const currentDateElement = document.getElementById('daily-stats-current-date');
                const dateInputElement = document.getElementById('daily-stats-date-input');
                
                if (currentDateElement) {
                    currentDateElement.textContent = `${dateStr} (${dayStr})`;
                    
                    // 요일별 색상 설정 (0=일요일, 6=토요일)
                    const dayOfWeek = dateObj.getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6; // 일요일 또는 토요일
                    const isHoliday = this.holidays.has(date); // 공휴일 확인
                    
                    if (isWeekend || isHoliday) {
                        // 주말/공휴일: 빨간색
                        currentDateElement.style.color = '#dc2626';
                        currentDateElement.style.background = 'linear-gradient(135deg, #fef2f2 0%, #fecaca 100%)';
                        currentDateElement.style.borderColor = '#f87171';
                    } else {
                        // 평일: 파란색
                        currentDateElement.style.color = '#2563eb';
                        currentDateElement.style.background = 'linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%)';
                        currentDateElement.style.borderColor = '#cbd5e1';
                    }
                }
                if (dateInputElement) dateInputElement.value = date;
                
                // 해당 날짜 데이터 찾기
                const dayData = this.seasonData.find(d => d.date === date);
                
                // 순위표 업데이트
                this.updateStandings(date);
                
                // 경기 결과 업데이트
                this.updateGames(dayData);
                
                // 게임차 차트 업데이트
                if (this.gameGapChart || document.getElementById('daily-stats-game-gap-chart')) {
                    this.updateGameGapChart(date);
                }
                
                // 승차 차트 업데이트
                if (this.winGapChart || document.getElementById('daily-stats-win-gap-chart')) {
                    this.updateWinGapChart(date);
                }
                
                // 승수 차트 업데이트 (최적화된 메서드 사용)
                if (this.winCountChart) {
                    this.updateWinCountChartForDateChange(date);
                }
                
                // 승률 추이 차트 업데이트 (최적화된 메서드 사용)
                if (this.winRateChart) {
                    this.updateWinRateChartForDateChange(date);
                }
                
                // 순위 변동 차트 업데이트 (최적화된 메서드 사용)
                if (this.rankChart) {
                    this.updateRankChartForDateChange(date);
                }
                
                // 버튼 상태 업데이트
                this.updateButtonStates();
            }
            
            updateStandings(date) {
                const standings = this.calculateStandings(date);
                const container = document.getElementById('daily-stats-standings-container');
                
                if (!container) return;
                
                
                if (standings.every(team => team.games === 0)) {
                    container.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">아직 경기가 시작되지 않았습니다.</div>';
                    return;
                }
                
                let html = `<table style="width: 100%; border-collapse: collapse;">
                    <thead><tr style="background: #f3f4f6;">
                        <th style="padding: 6px 4px; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 11px;">순위</th>
                        <th style="padding: 6px 4px; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 11px;">팀</th>
                        <th style="padding: 6px 4px; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 11px;">경기</th>
                        <th style="padding: 6px 4px; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 11px;">승</th>
                        <th style="padding: 6px 4px; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 11px;">패</th>
                        <th style="padding: 6px 4px; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 11px;">무</th>
                        <th style="padding: 6px 4px; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 11px;">승률</th>
                        <th style="padding: 6px 4px; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 11px;">게임차</th>
                    </tr></thead><tbody>`;
                
                standings.forEach((team, index) => {
                    const rank = team.displayRank || team.rank || (index + 1); // 동률 처리된 순위 사용
                    const rowStyle = rank === 1 ? 'background: linear-gradient(90deg, #ffd700 0%, #ffed4e 100%); font-weight: bold;' : '';
                    const winRateStr = team.winRate.toFixed(3);
                    const gbStr = team.gamesBehind === 0 ? '-' : team.gamesBehind.toFixed(1);
                    
                    html += `<tr style="${rowStyle}">
                        <td style="padding: 6px 4px; border-bottom: 1px solid #e5e7eb; font-size: 14px;">${rank}</td>
                        <td style="padding: 6px 4px; border-bottom: 1px solid #e5e7eb; font-size: 14px; color: ${this.teamColors[team.team]}; font-weight: 600;">
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <img src="${this.teamLogos[team.team]}" alt="${team.team}" style="width: 20px; height: 20px; object-fit: contain;" onerror="this.style.display='none'">
                                <span>${team.team}</span>
                            </div>
                        </td>
                        <td style="padding: 6px 4px; border-bottom: 1px solid #e5e7eb; font-size: 14px;">${team.games}</td>
                        <td style="padding: 6px 4px; border-bottom: 1px solid #e5e7eb; font-size: 14px;">${team.wins}</td>
                        <td style="padding: 6px 4px; border-bottom: 1px solid #e5e7eb; font-size: 14px;">${team.losses}</td>
                        <td style="padding: 6px 4px; border-bottom: 1px solid #e5e7eb; font-size: 14px;">${team.draws || 0}</td>
                        <td style="padding: 6px 4px; border-bottom: 1px solid #e5e7eb; font-size: 14px; font-weight: 600;">${winRateStr}</td>
                        <td style="padding: 6px 4px; border-bottom: 1px solid #e5e7eb; font-size: 14px;">${gbStr}</td>
                    </tr>`;
                });
                
                html += '</tbody></table>';
                container.innerHTML = html;
            }
            
            updateGames(dayData) {
                const container = document.getElementById('daily-stats-games-container');
                if (!container) return;
                
                if (!dayData || dayData.games.length === 0) {
                    const date = new Date(this.currentDate + 'T00:00:00');
                    const dayOfWeek = date.getDay();
                    const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
                    const reason = dayOfWeek === 1 ? '정규 휴식일입니다' : '경기가 없습니다';
                    
                    container.innerHTML = `<div style="text-align: center; color: #6b7280; padding: 20px;">
                        <div style="font-size: 16px; margin-bottom: 8px;">📅 ${dayNames[dayOfWeek]}요일</div>
                        <div>${reason}</div>
                    </div>`;
                    return;
                }
                
                let html = '';
                dayData.games.forEach(game => {
                    let contentHTML = '';
                    let borderColor = '#667eea';
                    let backgroundColor = 'white';

                    if (game.isCancelled) {
                        // 상대전적 계산 (해당 날짜까지의 누적 기록)
                        const headToHead = this.calculateHeadToHead(game.team1, game.team2, this.currentDate);
                        const h2hText = headToHead ? `${headToHead.team1Wins}-${headToHead.team2Wins}-${headToHead.draws}` : '';

                        // 취소된 경기 표시
                        contentHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; flex: 1;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <img src="${this.teamLogos[game.team1]}" alt="${game.team1}" style="width: 18px; height: 18px; object-fit: contain;" onerror="this.style.display='none'">
                                    <span style="color: #6b7280; font-weight: 600;">${game.team1}</span>
                                </div>
                                ${h2hText ? `<div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">${h2hText}</div>` : ''}
                            </div>
                            <div style="font-size: 14px; font-weight: bold; text-align: center; min-width: 100px; color: #dc2626;">
                                ❌ 취소
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; flex: 1;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="color: #6b7280; font-weight: 600;">${game.team2}</span>
                                    <img src="${this.teamLogos[game.team2]}" alt="${game.team2}" style="width: 18px; height: 18px; object-fit: contain;" onerror="this.style.display='none'">
                                    ${game.isHome ? '<span style="font-size: 12px; color: #666; margin-left: 4px;">(홈)</span>' : ''}
                                </div>
                                ${h2hText ? `<div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">${headToHead.team2Wins}-${headToHead.team1Wins}-${headToHead.draws}</div>` : ''}
                            </div>`;
                        borderColor = '#dc2626';
                        backgroundColor = '#fef2f2';
                    } else {
                        // 정상 경기 표시
                        const winner = game.score1 > game.score2 ? game.team1 :
                                      game.score2 > game.score1 ? game.team2 : null;

                        const team1Style = winner === game.team1 ? 'color: #10b981;' : winner === game.team2 ? 'color: #ef4444;' : '';
                        const team2Style = winner === game.team2 ? 'color: #10b981;' : winner === game.team1 ? 'color: #ef4444;' : '';

                        // 상대전적 계산 (해당 날짜까지의 누적 기록)
                        const headToHead = this.calculateHeadToHead(game.team1, game.team2, this.currentDate);
                        const h2hText = headToHead ? `${headToHead.team1Wins}-${headToHead.team2Wins}-${headToHead.draws}` : '';

                        contentHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; flex: 1;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <img src="${this.teamLogos[game.team1]}" alt="${game.team1}" style="width: 18px; height: 18px; object-fit: contain;" onerror="this.style.display='none'">
                                    <span style="${team1Style} color: ${this.teamColors[game.team1]}; font-weight: 600;">${game.team1}</span>
                                </div>
                                ${h2hText ? `<div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">${h2hText}</div>` : ''}
                            </div>
                            <div style="font-size: 16px; font-weight: bold; text-align: center; min-width: 70px;">
                                <span style="${winner === game.team1 ? 'color: #10b981; font-weight: 800;' : winner === null ? 'color: #f59e0b; font-weight: 700;' : 'color: #6b7280;'}">${game.score1}</span>
                                <span style="color: #6b7280;"> : </span>
                                <span style="${winner === game.team2 ? 'color: #10b981; font-weight: 800;' : winner === null ? 'color: #f59e0b; font-weight: 700;' : 'color: #6b7280;'}">${game.score2}</span>
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; flex: 1;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="${team2Style} color: ${this.teamColors[game.team2]}; font-weight: 600;">${game.team2}</span>
                                    <img src="${this.teamLogos[game.team2]}" alt="${game.team2}" style="width: 18px; height: 18px; object-fit: contain;" onerror="this.style.display='none'">
                                    ${game.isHome ? '<span style="font-size: 12px; color: #666; margin-left: 4px;">(홈)</span>' : ''}
                                </div>
                                ${h2hText ? `<div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">${headToHead.team2Wins}-${headToHead.team1Wins}-${headToHead.draws}</div>` : ''}
                            </div>`;
                    }

                    // 추가 정보 표시 (시간, 구장, 방송사)
                    let extraInfo = '';
                    if (game.time || game.stadium || game.broadcast) {
                        extraInfo = `<div style="font-size: 11px; color: #6b7280; margin-top: 4px; text-align: center; line-height: 1.2;">`;
                        if (game.time) extraInfo += `⏰ ${game.time} `;
                        if (game.stadium) extraInfo += `🏟️ ${game.stadium} `;
                        if (game.broadcast) extraInfo += `📺 ${game.broadcast}`;
                        extraInfo += `</div>`;
                    }

                    html += `<div style="padding: 8px 10px; margin-bottom: 8px; background: ${backgroundColor}; border-radius: 6px; border-left: 3px solid ${borderColor}; border: 1px solid #e5e7eb;">
                        <div style="font-size: 14px; font-weight: bold; color: #333; display: flex; align-items: center; line-height: 1.3;">
                            ${contentHTML}
                        </div>
                        ${extraInfo}
                    </div>`;
                });
                
                container.innerHTML = html;
            }

            // 두 팀 간 상대전적 계산 함수 (해당 날짜까지의 누적 기록)
            calculateHeadToHead(team1, team2, upToDate = null) {
                if (!gameRecordsData) return null;

                const team1Record = gameRecordsData[team1];
                const team2Record = gameRecordsData[team2];

                if (!team1Record || !team2Record) return null;

                // 날짜 필터링 함수
                const isBeforeOrOnDate = (gameDate, targetDate) => {
                    if (!targetDate) return true; // 날짜 제한이 없으면 모든 경기 포함
                    return new Date(gameDate) <= new Date(targetDate);
                };

                // team1의 관점에서 team2와의 경기 기록 (날짜 필터 적용)
                const team1Games = team1Record.games.filter(game =>
                    game.opponent === team2 &&
                    !game.isCancelled &&
                    game.result &&
                    game.result !== '' &&
                    isBeforeOrOnDate(game.date, upToDate)
                );

                // team2의 관점에서 team1과의 경기 기록 (날짜 필터 적용)
                const team2Games = team2Record.games.filter(game =>
                    game.opponent === team1 &&
                    !game.isCancelled &&
                    game.result &&
                    game.result !== '' &&
                    isBeforeOrOnDate(game.date, upToDate)
                );

                // 모든 경기 합치기
                const allGames = [...team1Games, ...team2Games];

                // 중복 제거 (같은 날짜의 경기)
                const uniqueGames = [];
                const seenDates = new Set();

                for (const game of allGames) {
                    const dateKey = `${game.date}`;
                    if (!seenDates.has(dateKey)) {
                        seenDates.add(dateKey);
                        uniqueGames.push(game);
                    }
                }

                let team1Wins = 0;
                let team2Wins = 0;
                let draws = 0;

                uniqueGames.forEach(game => {
                    // 현재 게임이 어느 팀 관점인지 확인
                    const isTeam1Game = team1Games.includes(game);

                    if (isTeam1Game) {
                        // team1 관점의 게임
                        if (game.result === 'W') team1Wins++;
                        else if (game.result === 'L') team2Wins++;
                        else if (game.result === 'D' || game.result === 'T') draws++;
                    } else {
                        // team2 관점의 게임
                        if (game.result === 'W') team2Wins++;
                        else if (game.result === 'L') team1Wins++;
                        else if (game.result === 'D' || game.result === 'T') draws++;
                    }
                });

                return {
                    team1Wins,
                    team2Wins,
                    draws,
                    totalGames: team1Wins + team2Wins + draws
                };
            }

            updateButtonStates() {
                const prevBtn = document.getElementById('daily-stats-prev-btn');
                const nextBtn = document.getElementById('daily-stats-next-btn');
                
                if (!prevBtn || !nextBtn) return;
                
                const currentDateObj = new Date(this.currentDate + 'T00:00:00');
                const startDateObj = new Date(this.startDate + 'T00:00:00');
                const endDateObj = new Date(this.endDate + 'T00:00:00');
                
                prevBtn.disabled = currentDateObj <= startDateObj;
                nextBtn.disabled = currentDateObj >= endDateObj;
                
                prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
                nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
            }
            
            async initCharts() {
                // Chart.js 지연 로딩
                await window.loadChartJs();
                
                setTimeout(() => {
                    if (typeof Chart !== 'undefined') {
                        this.initGameGapChart();
                        this.initWinGapChart();
                        this.initWinCountChart();
                        this.initWinRateChart();
                        this.initRankChart();
                    }
                }, 500);
            }
            
            initGameGapChart() {
                const ctx = document.getElementById('daily-stats-game-gap-chart');
                if (!ctx) return;
                
                // 현재 날짜의 순위표를 기반으로 게임차 차트 생성
                this.updateGameGapChart(this.currentDate);
            }
            
            updateGameGapChart(date) {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-game-gap-chart');
                if (!ctx) return;
                
                const standings = this.calculateStandings(date);
                
                // 시즌 전체 최대 게임차 사용 (X축 고정)
                const roundedMax = this.maxSeasonGamesBehind;
                
                // 산점도 데이터 생성 (로고 겹침 방지를 위한 스마트 배치)
                const scatterData = standings.map((team, index) => ({
                    x: team.gamesBehind,
                    y: 0, // 임시값, 아래에서 재배치
                    team: team.team,
                    rank: team.rank,
                    wins: team.wins,
                    losses: team.losses
                })).sort((a, b) => a.x - b.x); // 게임차 순으로 정렬
                
                // Y축 스마트 배치 (같은 게임차의 팀들이 겹치지 않게)
                const gamesBehindGroups = {};
                scatterData.forEach(team => {
                    const key = team.x.toFixed(1); // 게임차를 키로 사용
                    if (!gamesBehindGroups[key]) gamesBehindGroups[key] = [];
                    gamesBehindGroups[key].push(team);
                });
                
                // 각 그룹 내에서 Y축 위치 분산 배치
                Object.values(gamesBehindGroups).forEach(group => {
                    const count = group.length;
                    if (count === 1) {
                        group[0].y = 0; // 혼자면 중앙
                    } else {
                        // 여러 팀이 같은 게임차일 때 위아래로 분산
                        const spacing = 12; // 중간 간격으로 조정
                        const startY = -(count - 1) * spacing / 2;
                        group.forEach((team, idx) => {
                            team.y = startY + idx * spacing;
                        });
                    }
                });
                
                // 기존 차트가 있으면 데이터만 부드럽게 업데이트
                if (this.gameGapChart) {
                    // 기존 데이터를 새 데이터로 업데이트
                    this.gameGapChart.data.datasets[0].data = scatterData;
                    
                    // 포인트 스타일 업데이트 (팀 로고)
                    this.gameGapChart.data.datasets[0].pointStyle = scatterData.map(point => this.teamLogoImages[point.team] || 'circle');
                    
                    // x축 범위 업데이트
                    this.gameGapChart.options.scales.x.max = roundedMax;
                    
                    // 부드러운 애니메이션으로 업데이트
                    this.gameGapChart.update('active');
                    
                    // 게임차 정보 테이블 업데이트
                    this.updateGameGapInfo(standings);
                    return;
                }
                
                // 새 차트 생성
                this.gameGapChart = new Chart(ctx.getContext('2d'), {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: '팀별 게임차',
                            data: scatterData,
                            backgroundColor: scatterData.map(point => 'transparent'),
                            borderColor: scatterData.map(point => 'transparent'),
                            pointStyle: scatterData.map(point => this.teamLogoImages[point.team] || 'circle'),
                            pointRadius: 20,
                            pointHoverRadius: 23
                        }]
                    },
                    plugins: [{
                        id: 'rankLabels',
                        afterDatasetsDraw: (chart) => {
                            const ctx = chart.ctx;
                            const meta = chart.getDatasetMeta(0);
                            
                            chart.data.datasets[0].data.forEach((point, index) => {
                                const element = meta.data[index];
                                if (element && element.x !== undefined && element.y !== undefined) {
                                    ctx.save();
                                    
                                    // 순위 텍스트 그리기
                                    ctx.font = 'bold 14px Arial';
                                    ctx.fillStyle = '#1e40af';  // 파란색
                                    ctx.strokeStyle = 'white';
                                    ctx.lineWidth = 3;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    
                                    const text = `${point.rank}위`;
                                    const xPos = element.x;  // 로고 중앙 정렬
                                    const yPos = element.y + 30;  // 로고 아래로 이동
                                    
                                    // 흰색 외곽선
                                    ctx.strokeText(text, xPos, yPos);
                                    // 파란색 텍스트
                                    ctx.fillText(text, xPos, yPos);
                                    
                                    ctx.restore();
                                }
                            });
                        }
                    }],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        clip: false,  // 차트 영역 밖의 요소도 표시
                        layout: {
                            padding: {
                                left: 10,
                                right: 30,  // 오른쪽 패딩 줄임 (60 -> 30)
                                top: 10,
                                bottom: 10
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const point = context.raw;
                                        const gapText = point.x === 0 ? '선두' : `${point.x.toFixed(1)}차`;
                                        return `${point.rank}위 ${point.team}: ${gapText} (${point.wins}승${point.losses}패)`;
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 800,
                            easing: 'easeInOutQuart'
                        },
                        scales: {
                            x: {
                                title: { display: true, text: '게임차' },
                                beginAtZero: true,
                                max: roundedMax,
                                ticks: {
                                    stepSize: 0.5, // 0.5게임 단위로 표기
                                    callback: (value) => value === 0 ? '선두' : `${value.toFixed(1)}차`
                                }
                            },
                            y: {
                                display: false,
                                min: -20, // Y축 범위 원복
                                max: 20
                            }
                        },
                        animation: {
                            duration: 800,
                            easing: 'easeInOutQuart'
                        }
                    }
                });
                
                // 게임차 정보 테이블 업데이트
                this.updateGameGapInfo(standings);
            }
            
            updateGameGapInfo(standings) {
                const container = document.getElementById('daily-stats-game-gap-list');
                if (!container) return;
                
                let html = '';
                standings.forEach((team, index) => {
                    const rank = team.displayRank || team.rank || (index + 1); // 동률 처리된 순위 사용
                    const gap = team.gamesBehind;
                    const gapText = gap === 0 ? '선두' : `${gap.toFixed(1)}차`;
                    
                    // 순위별 색상
                    let rankColor = '#6b7280'; // 기본 회색
                    if (rank === 1) rankColor = '#fbbf24'; // 금색
                    else if (rank === 2) rankColor = '#9ca3af'; // 은색
                    else if (rank === 3) rankColor = '#d97706'; // 동색
                    else if (rank <= 5) rankColor = '#10b981'; // 플레이오프 (초록)
                    
                    html += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; background: white; border-radius: 4px; border-left: 3px solid ${rankColor};">
                            <span style="font-weight: 600; color: ${rankColor};">${rank}위</span>
                            <div style="display: flex; align-items: center; gap: 4px;">
                                <img src="${this.teamLogos[team.team]}" alt="${team.team}" style="width: 16px; height: 16px; object-fit: contain;" onerror="this.style.display='none'">
                                <span style="color: ${this.teamColors[team.team]}; font-weight: 600;">${team.team}</span>
                            </div>
                            <span style="color: #6b7280; font-size: 12px;">${gapText}</span>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            }
            
            initWinGapChart() {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-win-gap-chart');
                if (!ctx) return;
                
                // 팀 표시 상태 초기화 (모든 팀 표시)
                const teams = getRankingSystem().teams;
                teams.forEach(team => {
                    if (!this.teamVisibility.hasOwnProperty(team)) {
                        this.teamVisibility[team] = true;
                    }
                });
                
                // 차트가 이미 있다면 유지, 없다면 새로 생성 (다른 차트들과 동일한 방식)
                this.updateWinGapChart(this.currentDate);
            }
            
            initWinCountChart() {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-win-count-chart');
                if (!ctx) return;
                
                // 팀 표시 상태 초기화 (모든 팀 표시)
                this.winCountChartVisibleTeams = new Set(getRankingSystem().teams);
                
                // 차트가 이미 있다면 유지, 없다면 새로 생성 (다른 차트들과 동일한 방식)
                this.updateWinCountChart(this.currentDate);
            }
            
            initWinRateChart() {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-win-rate-chart');
                if (!ctx) return;
                
                // 팀 표시 상태 초기화 (모든 팀 표시)
                this.winRateChartVisibleTeams = new Set(getRankingSystem().teams);
                
                // 차트 생성은 updateWinRateChart에서 처리
                this.updateWinRateChart(this.currentDate);
            }
            
            initRankChart() {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-rank-chart');
                if (!ctx) return;
                
                // 팀 표시 상태 초기화 (모든 팀 표시)
                this.rankChartVisibleTeams = new Set(getRankingSystem().teams);
                
                // 차트 생성은 updateRankChart에서 처리
                this.updateRankChart(this.currentDate);
            }
            
            updateWinGapChart(selectedDate) {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-win-gap-chart');
                if (!ctx) return;
                
                // 선택된 날짜의 인덱스 찾기
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 해당 날짜까지의 데이터 가져오기
                const dataUpToDate = this.seasonData.slice(0, selectedIndex + 1);
                
                // 라벨 생성 (날짜)
                const labels = dataUpToDate.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 각 팀별 승차 계산
                const teamWinGaps = {};
                const teams = getRankingSystem().teams;
                
                teams.forEach(team => {
                    teamWinGaps[team] = [];
                });
                
                // 각 날짜별로 승차 계산
                dataUpToDate.forEach(dayData => {
                    const standings = this.calculateStandings(dayData.date);
                    const firstPlaceWins = Math.max(...standings.map(team => team.wins));
                    
                    standings.forEach(teamData => {
                        const winGap = teamData.gamesBehind || 0; // 공식 게임차 사용
                        teamWinGaps[teamData.team].push(winGap);
                    });
                });
                
                // 데이터셋 생성
                const datasets = [];
                teams.forEach(team => {
                    if (this.teamVisibility[team]) {
                        const teamColor = this.teamColors[team] || '#666';
                        const data = teamWinGaps[team];
                        const logoImage = this.teamLogoImages[team];
                        
                        // 포인트 스타일 배열 - 마지막 포인트만 로고, 나머지는 원형
                        const pointStyles = data.map((_, index) => 
                            index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                        );
                        
                        // 포인트 크기 배열 - 마지막 포인트만 크게, 중간은 작게 (일관된 크기)
                        const pointRadii = data.map((_, index) => 
                            index === data.length - 1 && logoImage ? 10 : 1.5  // 중간 포인트를 더 작게
                        );
                        
                        datasets.push({
                            label: team,
                            data: data,
                            borderColor: teamColor,
                            backgroundColor: teamColor + '20',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.2,
                            pointStyle: pointStyles,
                            pointRadius: pointRadii,
                            pointHoverRadius: data.map((_, index) => 
                                index === data.length - 1 && logoImage ? 12 : 3  // 호버 시에도 작게
                            ),
                            pointBackgroundColor: teamColor,
                            pointBorderColor: teamColor
                        });
                    }
                });
                
                // 차트가 없으면 생성, 있으면 데이터 업데이트
                if (!this.winGapChart) {
                    const ctx = document.getElementById('daily-stats-win-gap-chart');
                    if (!ctx) return;
                    
                    this.winGapChart = new Chart(ctx.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            clip: false,
                            layout: {
                                padding: {
                                    left: 15,
                                    right: 20,
                                    top: 15,
                                    bottom: 15
                                }
                            },
                            scales: {
                                y: {
                                    reverse: true,
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: '게임차'
                                    },
                                    ticks: {
                                        stepSize: 1,
                                        callback: function(value) {
                                            return value === 0 ? '동률' : `${value}게임차`;
                                        }
                                    }
                                },
                                x: {
                                    title: {
                                        display: false
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 45,
                                        font: {
                                            size: 11
                                        },
                                        maxTicksLimit: 120
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(tooltipItems) {
                                            return `${tooltipItems[0].label} 기준`;
                                        },
                                        label: function(context) {
                                            const value = context.parsed.y;
                                            return `${context.dataset.label}: ${value === 0 ? '동률' : value + '게임차'}`;
                                        }
                                    }
                                }
                            },
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            animation: false,  // 모든 애니메이션 완전히 비활성화
                            transitions: {
                                active: {
                                    animation: {
                                        duration: 0
                                    }
                                }
                            }
                        }
                    });
                } else {
                    // 기존 차트 데이터 업데이트 (애니메이션과 함께)
                    this.winGapChart.data.labels = labels;
                    this.winGapChart.data.datasets = datasets;
                    this.winGapChart.update({
                        duration: 600,
                        easing: 'easeInOutQuart'
                    });
                }
                
                // 레전드 업데이트
                this.updateWinGapLegend(teams);
            }
            
            updateWinGapLegend(teams) {
                const legendContainer = document.getElementById('daily-stats-win-gap-legend');
                if (!legendContainer) return;
                
                // 레전드 컨테이너 스타일 설정 (박스 없이 카드 내부에 배치)
                legendContainer.innerHTML = '';
                legendContainer.style.cssText = `
                    display: flex;
                    flex-wrap: wrap;
                    gap: 6px;
                    justify-content: center;
                    padding: 0;
                    background: transparent;
                    flex-shrink: 0;
                    max-height: 60px;
                    overflow-y: auto;
                    margin-top: 8px;
                `;
                
                // 전체 선택/해제 버튼 추가
                const allSelectedCount = teams.filter(team => this.teamVisibility[team]).length;
                const allSelected = allSelectedCount === teams.length;
                
                let legendHtml = '';
                
                // 전체 선택/해제 버튼
                legendHtml += `
                    <div onclick="completeDailyStats.toggleAllWinGapTeams()" 
                         style="display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid ${allSelected ? '#ef4444' : '#3b82f6'}; cursor: pointer; transition: all 0.2s;">
                        <span style="font-size: 12px; font-weight: 500; color: ${allSelected ? '#ef4444' : '#3b82f6'};">${allSelected ? '전체 해제' : '전체 선택'} (${allSelectedCount}/${teams.length})</span>
                    </div>
                `;
                
                legendHtml += teams.map(team => {
                    const color = this.teamColors[team] || '#666';
                    const logo = this.teamLogos[team] || '';
                    const isVisible = this.teamVisibility[team];
                    const opacity = isVisible ? '1' : '0.3';
                    
                    return `
                        <div onclick="completeDailyStats.toggleWinGapTeamVisibility('${team}')" 
                             style="display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid #e5e7eb; cursor: pointer; opacity: ${opacity}; transition: opacity 0.2s;">
                            <div style="width: 12px; height: 3px; background: ${color}; border-radius: 2px;"></div>
                            <img src="${logo}" alt="${team}" style="width: 16px; height: 16px; object-fit: contain;" onerror="this.style.display='none'">
                            <span style="font-size: 12px; font-weight: 500; color: #374151;">${team}</span>
                        </div>
                    `;
                }).join('');
                
                legendContainer.innerHTML = legendHtml;
            }
            
            toggleWinGapTeamVisibility(team) {
                this.teamVisibility[team] = !this.teamVisibility[team];
                this.updateWinGapChart(this.currentDate);
            }
            
            toggleAllWinGapTeams() {
                const allTeams = getRankingSystem().teams;
                const allVisible = allTeams.every(team => this.teamVisibility[team]);
                
                if (allVisible) {
                    // 전체 해제: 모든 팀 숨김
                    allTeams.forEach(team => {
                        this.teamVisibility[team] = false;
                    });
                } else {
                    // 전체 선택: 모든 팀 표시
                    allTeams.forEach(team => {
                        this.teamVisibility[team] = true;
                    });
                }
                this.updateWinGapChart(this.currentDate);
            }
            
            toggleWinCountTeamVisibility(team) {
                if (this.winCountChartVisibleTeams.has(team)) {
                    this.winCountChartVisibleTeams.delete(team);
                } else {
                    this.winCountChartVisibleTeams.add(team);
                }
                this.updateWinCountChart(this.currentDate);
            }
            
            toggleAllWinCountTeams() {
                const allTeams = getRankingSystem().teams;
                const allVisible = allTeams.every(team => this.winCountChartVisibleTeams.has(team));
                
                if (allVisible) {
                    // 전체 해제: 모든 팀 숨김
                    this.winCountChartVisibleTeams.clear();
                } else {
                    // 전체 선택: 모든 팀 표시
                    allTeams.forEach(team => {
                        this.winCountChartVisibleTeams.add(team);
                    });
                }
                this.updateWinCountChart(this.currentDate);
            }
            
            updateWinCountChart(selectedDate) {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-win-count-chart');
                if (!ctx) return;
                
                // 선택된 날짜의 인덱스 찾기
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 해당 날짜까지의 데이터 가져오기
                const dataUpToDate = this.seasonData.slice(0, selectedIndex + 1);
                
                // 라벨 생성 (날짜)
                const labels = dataUpToDate.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 각 팀별 승수 계산
                const teamWinCounts = {};
                const teams = getRankingSystem().teams;
                
                teams.forEach(team => {
                    teamWinCounts[team] = [];
                });
                
                // 각 날짜별로 승수 계산
                dataUpToDate.forEach(dayData => {
                    const standings = this.calculateStandings(dayData.date);
                    
                    standings.forEach(teamData => {
                        teamWinCounts[teamData.team].push(teamData.wins);
                    });
                });
                
                // 데이터셋 생성
                const datasets = [];
                teams.forEach(team => {
                    if (this.winCountChartVisibleTeams.has(team)) {
                        const teamColor = this.teamColors[team] || '#666';
                        const data = teamWinCounts[team];
                        const logoImage = this.teamLogoImages[team];
                        
                        // 포인트 스타일 배열 - 마지막 포인트만 로고, 나머지는 원형
                        const pointStyles = data.map((_, index) => 
                            index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                        );
                        
                        // 포인트 크기 배열 - 마지막 포인트만 크게, 중간은 작게
                        const pointRadii = data.map((_, index) => 
                            index === data.length - 1 && logoImage ? 10 : 1.5
                        );
                        
                        datasets.push({
                            label: team,
                            data: data,
                            borderColor: teamColor,
                            backgroundColor: teamColor + '20',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.2,
                            pointStyle: pointStyles,
                            pointRadius: pointRadii,
                            pointHoverRadius: data.map((_, index) => 
                                index === data.length - 1 && logoImage ? 12 : 3
                            ),
                            pointBackgroundColor: teamColor,
                            pointBorderColor: teamColor
                        });
                    }
                });
                
                // 차트가 없으면 생성, 있으면 데이터 업데이트
                if (!this.winCountChart) {
                    const ctx = document.getElementById('daily-stats-win-count-chart');
                    if (!ctx) return;
                    
                    this.winCountChart = new Chart(ctx.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            clip: false,
                            layout: {
                                padding: {
                                    left: 15,
                                    right: 20,
                                    top: 15,
                                    bottom: 15
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: '승수'
                                    },
                                    ticks: {
                                        stepSize: 5,
                                        callback: function(value) {
                                            return `${value}승`;
                                        }
                                    }
                                },
                                x: {
                                    title: {
                                        display: false
                                    }
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            return `${context.dataset.label}: ${context.parsed.y}승`;
                                        }
                                    }
                                }
                            },
                            animation: false,  // 초기 애니메이션 비활성화
                            interaction: {
                                mode: 'nearest',
                                axis: 'x',
                                intersect: false
                            }
                        }
                    });
                    
                    // 레전드 업데이트
                    this.updateWinCountLegend(teams);
                } else {
                    // 기존 차트 데이터 업데이트 (애니메이션과 함께)
                    this.winCountChart.data.labels = labels;
                    this.winCountChart.data.datasets = datasets;
                    this.winCountChart.update({
                        duration: 600,
                        easing: 'easeInOutQuart'
                    });
                }
            }
            
            updateWinCountLegend(teams) {
                const legendContainer = document.getElementById('daily-stats-win-count-legend');
                if (!legendContainer) return;
                
                // 레전드 컨테이너 스타일 설정 (박스 없이 카드 내부에 배치)
                legendContainer.innerHTML = '';
                legendContainer.style.cssText = `
                    display: flex;
                    flex-wrap: wrap;
                    gap: 6px;
                    justify-content: center;
                    padding: 0;
                    background: transparent;
                    flex-shrink: 0;
                    max-height: 60px;
                    overflow-y: auto;
                    margin-top: 8px;
                `;
                
                // 전체 선택/해제 버튼 추가
                const allSelectedCount = teams.filter(team => this.winCountChartVisibleTeams.has(team)).length;
                const allSelected = allSelectedCount === teams.length;
                
                let legendHtml = '';
                
                // 전체 선택/해제 버튼
                legendHtml += `
                    <div onclick="completeDailyStats.toggleAllWinCountTeams()" 
                         style="display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid ${allSelected ? '#ef4444' : '#3b82f6'}; cursor: pointer; transition: all 0.2s;">
                        <span style="font-size: 12px; font-weight: 500; color: ${allSelected ? '#ef4444' : '#3b82f6'};">${allSelected ? '전체 해제' : '전체 선택'} (${allSelectedCount}/${teams.length})</span>
                    </div>
                `;
                
                legendHtml += teams.map(team => {
                    const color = this.teamColors[team] || '#666';
                    const logo = this.teamLogos[team] || '';
                    const isVisible = this.winCountChartVisibleTeams.has(team);
                    const opacity = isVisible ? '1' : '0.3';
                    
                    return `
                        <div onclick="completeDailyStats.toggleWinCountTeamVisibility('${team}')" 
                             style="display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid #e5e7eb; cursor: pointer; opacity: ${opacity}; transition: opacity 0.2s;">
                            <div style="width: 12px; height: 3px; background: ${color}; border-radius: 2px;"></div>
                            <img src="${logo}" alt="${team}" style="width: 16px; height: 16px; object-fit: contain;" onerror="this.style.display='none'">
                            <span style="font-size: 12px; font-weight: 500; color: #374151;">${team}</span>
                        </div>
                    `;
                }).join('');
                
                legendContainer.innerHTML = legendHtml;
            }
            
            updateWinRateChart(selectedDate) {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-win-rate-chart');
                if (!ctx) return;
                
                // 선택된 날짜의 인덱스 찾기
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 시즌 시작(3월 22일)부터 선택된 날짜까지의 모든 데이터 사용
                const chartData = this.seasonData.slice(0, selectedIndex + 1);
                
                const dates = chartData.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 모든 팀 목록 가져오기
                const allTeams = getRankingSystem().teams;
                
                const datasets = allTeams.filter(team => this.winRateChartVisibleTeams.has(team)).map(team => {
                    const data = chartData.map(dayData => {
                        const standings = this.calculateStandings(dayData.date);
                        const teamData = standings.find(s => s.team === team);
                        return teamData ? teamData.winRate : 0;
                    });
                    
                    const logoImage = this.teamLogoImages[team];
                    
                    // 포인트 스타일 배열 - 마지막 포인트만 로고, 나머지는 원형
                    const pointStyles = data.map((_, index) => 
                        index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                    );
                    
                    // 포인트 크기 배열 - 마지막 포인트만 크게, 중간은 매우 작게
                    const pointRadii = data.map((_, index) => 
                        index === data.length - 1 && logoImage ? 10 : 2
                    );
                    
                    return {
                        label: team,
                        data: data,
                        borderColor: this.teamColors[team] || '#666',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.1,
                        pointStyle: pointStyles,
                        pointRadius: pointRadii,
                        pointHoverRadius: 8,
                        pointBackgroundColor: this.teamColors[team] || '#666',
                        pointBorderColor: this.teamColors[team] || '#666'
                    };
                });
                
                // 차트가 없으면 새로 생성
                if (!this.winRateChart) {
                    this.winRateChart = new Chart(ctx.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            clip: false,
                            layout: {
                                padding: {
                                    left: 15,
                                    right: 20,
                                    top: 15,
                                    bottom: 15
                                }
                            },
                            animation: false,  // 초기 애니메이션 비활성화
                            plugins: { 
                                legend: { display: false },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            },
                            scales: { 
                                y: { 
                                    min: 0,
                                    max: 1,
                                    title: {
                                        display: true,
                                        text: '승률'
                                    }
                                }
                            }
                        }
                    });
                } else {
                    // 기존 차트 업데이트
                    this.winRateChart.data.labels = dates;
                    this.winRateChart.data.datasets = datasets;
                    this.winRateChart.update({
                        duration: 600,
                        easing: 'easeInOutQuart'
                    });
                }
                
                // 레전드 업데이트
                this.updateWinRateLegend(allTeams);
            }
            
            updateRankChart(selectedDate) {
                if (typeof Chart === 'undefined') return;
                const ctx = document.getElementById('daily-stats-rank-chart');
                if (!ctx) return;
                
                // 선택된 날짜의 인덱스 찾기
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 시즌 시작(3월 22일)부터 선택된 날짜까지의 모든 데이터 사용
                const chartData = this.seasonData.slice(0, selectedIndex + 1);
                
                const dates = chartData.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 모든 팀 목록 가져오기
                const allTeams = getRankingSystem().teams;
                
                const datasets = allTeams.filter(team => this.rankChartVisibleTeams.has(team)).map(team => {
                    const data = chartData.map(dayData => {
                        const standings = this.calculateStandings(dayData.date);
                        const teamData = standings.find(s => s.team === team);
                        return teamData ? teamData.rank : 10;
                    });
                    
                    const logoImage = this.teamLogoImages[team];
                    
                    // 포인트 스타일 배열 - 마지막 포인트만 로고, 나머지는 원형
                    const pointStyles = data.map((_, index) => 
                        index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                    );
                    
                    // 포인트 크기 배열 - 마지막 포인트만 크게, 중간은 매우 작게
                    const pointRadii = data.map((_, index) => 
                        index === data.length - 1 && logoImage ? 10 : 2
                    );
                    
                    return {
                        label: team,
                        data: data,
                        borderColor: this.teamColors[team] || '#666',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.1,
                        pointStyle: pointStyles,
                        pointRadius: pointRadii,
                        pointHoverRadius: 8,
                        pointBackgroundColor: this.teamColors[team] || '#666',
                        pointBorderColor: this.teamColors[team] || '#666'
                    };
                });
                
                // 차트가 없으면 새로 생성
                if (!this.rankChart) {
                    this.rankChart = new Chart(ctx.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            clip: false,
                            layout: {
                                padding: {
                                    left: 15,
                                    right: 20,
                                    top: 15,
                                    bottom: 15
                                }
                            },
                            animation: false,  // 초기 애니메이션 비활성화
                            plugins: { 
                                legend: { display: false },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            },
                            scales: { 
                                y: { 
                                    type: 'linear',
                                    reverse: true,
                                    min: 0.5,
                                    max: 10.5,
                                    title: {
                                        display: true,
                                        text: '순위'
                                    }
                                }
                            }
                        }
                    });
                } else {
                    // 기존 차트 업데이트
                    this.rankChart.data.labels = dates;
                    this.rankChart.data.datasets = datasets;
                    
                    // y축 범위 재설정 (1~10위 강제 표시)
                    this.rankChart.options.scales.y.min = 0.5;
                    this.rankChart.options.scales.y.max = 10.5;
                    
                    this.rankChart.update({
                        duration: 600,
                        easing: 'easeInOutQuart'
                    });
                }
                
                // 레전드 업데이트
                this.updateRankLegend(allTeams);
            }
            
            updateWinRateLegend(teams) {
                const legendContainer = document.getElementById('daily-stats-win-rate-legend');
                if (!legendContainer) return;
                
                // 레전드 컨테이너 스타일 설정 (박스 없이 카드 내부에 배치)
                legendContainer.style.cssText = `
                    display: flex;
                    flex-wrap: wrap;
                    gap: 6px;
                    justify-content: center;
                    padding: 0;
                    background: transparent;
                    flex-shrink: 0;
                    max-height: 60px;
                    overflow-y: auto;
                    margin-top: 8px;
                `;
                
                // 전체 선택/해제 버튼 추가
                const allSelectedCount = teams.filter(team => this.winRateChartVisibleTeams.has(team)).length;
                const allSelected = allSelectedCount === teams.length;
                
                let legendHtml = `<div style="display: flex; flex-wrap: wrap; gap: 6px;">`;
                
                // 전체 선택/해제 버튼
                legendHtml += `
                    <div onclick="window.dailyStatsManager.toggleAllWinRateTeams()" 
                         style="display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid ${allSelected ? '#ef4444' : '#3b82f6'}; cursor: pointer; transition: all 0.2s;">
                        <span style="font-size: 12px; font-weight: 500; color: ${allSelected ? '#ef4444' : '#3b82f6'};">${allSelected ? '전체 해제' : '전체 선택'} (${allSelectedCount}/${teams.length})</span>
                    </div>
                `;
                
                legendHtml += teams.map(team => {
                    const color = this.teamColors[team] || '#666';
                    const logo = this.teamLogos[team] || '';
                    const isVisible = this.winRateChartVisibleTeams.has(team);
                    const opacity = isVisible ? '1' : '0.3';
                    
                    return `
                        <div onclick="window.dailyStatsManager.toggleWinRateTeam('${team}')" 
                             style="display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid #e5e7eb; cursor: pointer; opacity: ${opacity}; transition: opacity 0.2s;">
                            <div style="width: 12px; height: 3px; background: ${color}; border-radius: 2px;"></div>
                            <img src="${logo}" alt="${team}" style="width: 16px; height: 16px; object-fit: contain;" onerror="this.style.display='none'">
                            <span style="font-size: 12px; font-weight: 500; color: #374151;">${team}</span>
                        </div>
                    `;
                }).join('');
                
                legendHtml += '</div>';
                legendContainer.innerHTML = legendHtml;
            }
            
            toggleWinRateTeam(team) {
                if (this.winRateChartVisibleTeams.has(team)) {
                    this.winRateChartVisibleTeams.delete(team);
                    this.removeTeamFromWinRateChart(team);
                } else {
                    this.winRateChartVisibleTeams.add(team);
                    this.addTeamToWinRateChart(team);
                }
                this.updateWinRateLegend(getRankingSystem().teams);
            }
            
            toggleAllWinRateTeams() {
                const allTeams = getRankingSystem().teams;
                const allVisible = allTeams.every(team => this.winRateChartVisibleTeams.has(team));
                
                if (allVisible) {
                    // 전체 해제: 빈 Set으로 만들기 (아무 팀도 표시하지 않음)
                    this.winRateChartVisibleTeams.clear();
                } else {
                    // 전체 선택: 모든 팀 선택
                    this.winRateChartVisibleTeams = new Set(allTeams);
                }
                this.updateWinRateChart(this.currentDate);
            }
            
            updateRankLegend(teams) {
                const legendContainer = document.getElementById('daily-stats-rank-legend');
                if (!legendContainer) return;
                
                // 레전드 컨테이너 스타일 설정 (박스 없이 카드 내부에 배치)
                legendContainer.innerHTML = '';
                legendContainer.style.cssText = `
                    display: flex;
                    flex-wrap: wrap;
                    gap: 6px;
                    justify-content: center;
                    padding: 0;
                    background: transparent;
                    flex-shrink: 0;
                    max-height: 60px;
                    overflow-y: auto;
                    margin-top: 8px;
                `;
                
                // 전체 선택/해제 버튼 추가
                const allSelectedCount = teams.filter(team => this.rankChartVisibleTeams.has(team)).length;
                const allSelected = allSelectedCount === teams.length;
                
                let legendHtml = '';
                
                // 전체 선택/해제 버튼
                legendHtml += `
                    <div onclick="window.dailyStatsManager.toggleAllRankTeams()" 
                         style="display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid ${allSelected ? '#ef4444' : '#3b82f6'}; cursor: pointer; transition: all 0.2s;">
                        <span style="font-size: 12px; font-weight: 500; color: ${allSelected ? '#ef4444' : '#3b82f6'};">${allSelected ? '전체 해제' : '전체 선택'} (${allSelectedCount}/${teams.length})</span>
                    </div>
                `;
                
                legendHtml += teams.map(team => {
                    const color = this.teamColors[team] || '#666';
                    const logo = this.teamLogos[team] || '';
                    const isVisible = this.rankChartVisibleTeams.has(team);
                    const opacity = isVisible ? '1' : '0.3';
                    
                    return `
                        <div onclick="window.dailyStatsManager.toggleRankTeam('${team}')" 
                             style="display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid #e5e7eb; cursor: pointer; opacity: ${opacity}; transition: opacity 0.2s;">
                            <div style="width: 12px; height: 3px; background: ${color}; border-radius: 2px;"></div>
                            <img src="${logo}" alt="${team}" style="width: 16px; height: 16px; object-fit: contain;" onerror="this.style.display='none'">
                            <span style="font-size: 12px; font-weight: 500; color: #374151;">${team}</span>
                        </div>
                    `;
                }).join('');
                
                legendHtml += '</div>';
                legendContainer.innerHTML = legendHtml;
            }
            
            toggleRankTeam(team) {
                if (this.rankChartVisibleTeams.has(team)) {
                    this.rankChartVisibleTeams.delete(team);
                    this.removeTeamFromRankChart(team);
                } else {
                    this.rankChartVisibleTeams.add(team);
                    this.addTeamToRankChart(team);
                }
                this.updateRankLegend(getRankingSystem().teams);
            }
            
            toggleAllRankTeams() {
                const allTeams = getRankingSystem().teams;
                const allVisible = allTeams.every(team => this.rankChartVisibleTeams.has(team));
                
                if (allVisible) {
                    // 전체 해제: 빈 Set으로 만들기 (아무 팀도 표시하지 않음)
                    this.rankChartVisibleTeams.clear();
                } else {
                    // 전체 선택: 모든 팀 선택
                    this.rankChartVisibleTeams = new Set(allTeams);
                }
                this.updateRankChart(this.currentDate);
            }
            
            // 개별 팀 차트 추가/제거 메서드들 (차트 최적화)
            addTeamToRankChart(team) {
                if (!this.rankChart) return;
                
                // 현재 날짜까지의 데이터 가져오기
                const selectedIndex = this.seasonData.findIndex(d => d.date === this.currentDate);
                if (selectedIndex === -1) return;
                
                const chartData = this.seasonData.slice(0, selectedIndex + 1);
                const data = chartData.map(dayData => {
                    const standings = this.calculateStandings(dayData.date);
                    const teamData = standings.find(s => s.team === team);
                    return teamData ? teamData.rank : 10;
                });
                
                const logoImage = this.teamLogoImages[team];
                const pointStyles = data.map((_, index) => 
                    index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                );
                const pointRadii = data.map((_, index) => 
                    index === data.length - 1 && logoImage ? 10 : 2
                );
                
                const newDataset = {
                    label: team,
                    data: data,
                    borderColor: this.teamColors[team] || '#666',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    tension: 0.1,
                    pointStyle: pointStyles,
                    pointRadius: pointRadii,
                    pointHoverRadius: pointRadii.map(r => r + 2)
                };
                
                this.rankChart.data.datasets.push(newDataset);
                this.rankChart.update('none'); // 애니메이션 없이 업데이트
            }
            
            removeTeamFromRankChart(team) {
                if (!this.rankChart) return;
                
                const datasetIndex = this.rankChart.data.datasets.findIndex(dataset => dataset.label === team);
                if (datasetIndex !== -1) {
                    this.rankChart.data.datasets.splice(datasetIndex, 1);
                    this.rankChart.update('none'); // 애니메이션 없이 업데이트
                }
            }
            
            addTeamToWinRateChart(team) {
                if (!this.winRateChart) return;
                
                // 현재 날짜까지의 데이터 가져오기
                const selectedIndex = this.seasonData.findIndex(d => d.date === this.currentDate);
                if (selectedIndex === -1) return;
                
                const chartData = this.seasonData.slice(0, selectedIndex + 1);
                const data = chartData.map(dayData => {
                    const standings = this.calculateStandings(dayData.date);
                    const teamData = standings.find(s => s.team === team);
                    return teamData ? teamData.winRate : 0;
                });
                
                const logoImage = this.teamLogoImages[team];
                const pointStyles = data.map((_, index) => 
                    index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                );
                const pointRadii = data.map((_, index) => 
                    index === data.length - 1 && logoImage ? 10 : 2
                );
                
                const newDataset = {
                    label: team,
                    data: data,
                    borderColor: this.teamColors[team] || '#666',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    tension: 0.1,
                    pointStyle: pointStyles,
                    pointRadius: pointRadii,
                    pointHoverRadius: pointRadii.map(r => r + 2)
                };
                
                this.winRateChart.data.datasets.push(newDataset);
                this.winRateChart.update('none'); // 애니메이션 없이 업데이트
            }
            
            removeTeamFromWinRateChart(team) {
                if (!this.winRateChart) return;
                
                const datasetIndex = this.winRateChart.data.datasets.findIndex(dataset => dataset.label === team);
                if (datasetIndex !== -1) {
                    this.winRateChart.data.datasets.splice(datasetIndex, 1);
                    this.winRateChart.update('none'); // 애니메이션 없이 업데이트
                }
            }
            
            // 날짜 변경 시 차트 최적화 업데이트 (전체 재생성 대신 데이터만 업데이트)
            updateRankChartForDateChange(selectedDate) {
                if (!this.rankChart) return;
                
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 해당 날짜까지의 데이터 가져오기 (updateWinGapChart와 동일 방식)
                const dataUpToDate = this.seasonData.slice(0, selectedIndex + 1);
                
                // 라벨 생성 (날짜)
                const labels = dataUpToDate.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 각 팀별 순위 계산
                const teamRanks = {};
                const teams = getRankingSystem().teams;
                
                teams.forEach(team => {
                    teamRanks[team] = [];
                });
                
                // 각 날짜별로 순위 계산
                dataUpToDate.forEach(dayData => {
                    const standings = this.calculateStandings(dayData.date);
                    standings.forEach(teamData => {
                        teamRanks[teamData.team].push(teamData.rank);
                    });
                });
                
                // 데이터셋 업데이트
                this.rankChart.data.labels = labels;
                this.rankChart.data.datasets.forEach(dataset => {
                    const team = dataset.label;
                    if (!this.rankChartVisibleTeams.has(team)) return;
                    
                    const data = teamRanks[team];
                    const logoImage = this.teamLogoImages[team];
                    
                    // 포인트 스타일 배열 - 마지막 포인트만 로고
                    const pointStyles = data.map((_, index) => 
                        index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                    );
                    
                    // 포인트 크기 배열
                    const pointRadii = data.map((_, index) => 
                        index === data.length - 1 && logoImage ? 10 : 2
                    );
                    
                    dataset.data = data;
                    dataset.pointStyle = pointStyles;
                    dataset.pointRadius = pointRadii;
                    dataset.pointHoverRadius = pointRadii.map(r => r + 2);
                });
                
                // 애니메이션 속도 조절
                const isAnimating = this.isAnimating;
                this.rankChart.update({
                    duration: isAnimating ? 300 : 800,
                    easing: isAnimating ? 'linear' : 'easeInOutQuart'
                });
            }
            
            updateWinRateChartForDateChange(selectedDate) {
                if (!this.winRateChart) return;
                
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 해당 날짜까지의 데이터 가져오기 (updateWinGapChart와 동일 방식)
                const dataUpToDate = this.seasonData.slice(0, selectedIndex + 1);
                
                // 라벨 생성 (날짜)
                const labels = dataUpToDate.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 각 팀별 승률 계산
                const teamWinRates = {};
                const teams = getRankingSystem().teams;
                
                teams.forEach(team => {
                    teamWinRates[team] = [];
                });
                
                // 각 날짜별로 승률 계산
                dataUpToDate.forEach(dayData => {
                    const standings = this.calculateStandings(dayData.date);
                    standings.forEach(teamData => {
                        teamWinRates[teamData.team].push(teamData.winRate);
                    });
                });
                
                // 데이터셋 업데이트
                this.winRateChart.data.labels = labels;
                this.winRateChart.data.datasets.forEach(dataset => {
                    const team = dataset.label;
                    if (!this.winRateChartVisibleTeams.has(team)) return;
                    
                    const data = teamWinRates[team];
                    const logoImage = this.teamLogoImages[team];
                    
                    // 포인트 스타일 배열 - 마지막 포인트만 로고
                    const pointStyles = data.map((_, index) => 
                        index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                    );
                    
                    // 포인트 크기 배열
                    const pointRadii = data.map((_, index) => 
                        index === data.length - 1 && logoImage ? 10 : 2
                    );
                    
                    dataset.data = data;
                    dataset.pointStyle = pointStyles;
                    dataset.pointRadius = pointRadii;
                    dataset.pointHoverRadius = pointRadii.map(r => r + 2);
                });
                
                // 애니메이션 속도 조절
                const isAnimating = this.isAnimating;
                this.winRateChart.update({
                    duration: isAnimating ? 300 : 800,
                    easing: isAnimating ? 'linear' : 'easeInOutQuart'
                });
            }
            
            updateWinCountChartForDateChange(selectedDate) {
                if (!this.winCountChart) return;
                
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 해당 날짜까지의 데이터 가져오기 (updateWinGapChart와 동일 방식)
                const dataUpToDate = this.seasonData.slice(0, selectedIndex + 1);
                
                // 라벨 생성 (날짜)
                const labels = dataUpToDate.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 각 팀별 승수 계산
                const teamWinCounts = {};
                const teams = getRankingSystem().teams;
                
                teams.forEach(team => {
                    teamWinCounts[team] = [];
                });
                
                // 각 날짜별로 승수 계산
                dataUpToDate.forEach(dayData => {
                    const standings = this.calculateStandings(dayData.date);
                    standings.forEach(teamData => {
                        teamWinCounts[teamData.team].push(teamData.wins);
                    });
                });
                
                // 데이터셋 업데이트
                this.winCountChart.data.labels = labels;
                this.winCountChart.data.datasets.forEach(dataset => {
                    const team = dataset.label;
                    if (!this.winCountChartVisibleTeams.has(team)) return;
                    
                    const data = teamWinCounts[team];
                    const logoImage = this.teamLogoImages[team];
                    
                    // 포인트 스타일 배열 - 마지막 포인트만 로고
                    const pointStyles = data.map((_, index) => 
                        index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                    );
                    
                    // 포인트 크기 배열
                    const pointRadii = data.map((_, index) => 
                        index === data.length - 1 && logoImage ? 10 : 2
                    );
                    
                    dataset.data = data;
                    dataset.pointStyle = pointStyles;
                    dataset.pointRadius = pointRadii;
                    dataset.pointHoverRadius = pointRadii.map(r => r + 2);
                });
                
                // 애니메이션 속도 조절
                const isAnimating = this.isAnimating;
                this.winCountChart.update({
                    duration: isAnimating ? 300 : 800,
                    easing: isAnimating ? 'linear' : 'easeInOutQuart'
                });
            }
            
            // 애니메이션 전용 디스플레이 업데이트 (차트 제외)
            updateDisplayForAnimation(date) {
                this.currentDate = date;
                
                // 날짜 표시 업데이트
                const dateObj = new Date(date + 'T00:00:00');
                const dateStr = dateObj.toLocaleDateString('ko-KR', {
                    year: 'numeric', month: 'long', day: 'numeric'
                });
                const dayStr = dateObj.toLocaleDateString('ko-KR', {
                    weekday: 'short'
                });
                
                const currentDateElement = document.getElementById('daily-stats-current-date');
                const dateInputElement = document.getElementById('daily-stats-date-input');
                
                if (currentDateElement) {
                    currentDateElement.textContent = `${dateStr} (${dayStr})`;
                    
                    // 요일별 색상 설정 (0=일요일, 6=토요일)
                    const dayOfWeek = dateObj.getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6; // 일요일 또는 토요일
                    const isHoliday = this.holidays.has(date); // 공휴일 확인
                    
                    if (isWeekend || isHoliday) {
                        // 주말/공휴일: 빨간색
                        currentDateElement.style.color = '#dc2626';
                        currentDateElement.style.background = 'linear-gradient(135deg, #fef2f2 0%, #fecaca 100%)';
                        currentDateElement.style.borderColor = '#f87171';
                    } else {
                        // 평일: 파란색
                        currentDateElement.style.color = '#2563eb';
                        currentDateElement.style.background = 'linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%)';
                        currentDateElement.style.borderColor = '#cbd5e1';
                    }
                }
                if (dateInputElement) dateInputElement.value = date;
                
                // 해당 날짜 데이터 찾기
                const dayData = this.seasonData.find(d => d.date === date);
                
                // 순위표 업데이트
                this.updateStandings(date);
                
                // 경기 결과 업데이트
                this.updateGames(dayData);
                
                // 게임차 차트 업데이트
                if (this.gameGapChart || document.getElementById('daily-stats-game-gap-chart')) {
                    this.updateGameGapChart(date);
                }
                
                // 승차 차트 업데이트
                if (this.winGapChart || document.getElementById('daily-stats-win-gap-chart')) {
                    this.updateWinGapChart(date);
                }
                
                // 버튼 상태 업데이트
                this.updateButtonStates();
            }
            
            // 애니메이션 시작 시 차트 초기화
            initializeChartsForAnimation() {
                // 애니메이션 시작 시 차트를 개막일(첫 번째 데이터)로 초기화
                if (this.seasonData.length === 0) return;
                
                const firstGameDate = this.seasonData[0];
                const initialData = [firstGameDate]; // 첫 번째 날짜 데이터만
                
                if (this.winRateChart) {
                    this.winRateChart.data.labels = initialData.map(d => {
                        const [, month, day] = d.date.split('-');
                        return `${month}/${day}`;
                    });
                    this.winRateChart.data.datasets.forEach(dataset => {
                        const team = dataset.label;
                        if (!this.winRateChartVisibleTeams.has(team)) return;
                        
                        dataset.data = initialData.map(dayData => {
                            const standings = this.calculateStandings(dayData.date);
                            const teamStanding = standings.find(s => s.team === team);
                            return teamStanding ? teamStanding.winRate : null;
                        });
                        
                        // 포인트 스타일 초기화 (마지막 포인트만 로고)
                        const pointStyles = dataset.data.map((_, index) => 
                            index === dataset.data.length - 1 ? this.teamLogoImages[team] : false
                        );
                        const pointRadii = dataset.data.map((_, index) => 
                            index === dataset.data.length - 1 ? 12 : 0
                        );
                        
                        dataset.pointStyle = pointStyles;
                        dataset.pointRadius = pointRadii;
                        dataset.pointHoverRadius = pointRadii.map(r => r + 2);
                    });
                    this.winRateChart.update('none');
                }
                
                if (this.rankChart) {
                    this.rankChart.data.labels = initialData.map(d => {
                        const [, month, day] = d.date.split('-');
                        return `${month}/${day}`;
                    });
                    this.rankChart.data.datasets.forEach(dataset => {
                        const team = dataset.label;
                        if (!this.rankChartVisibleTeams.has(team)) return;
                        
                        dataset.data = initialData.map(dayData => {
                            const standings = this.calculateStandings(dayData.date);
                            const teamStanding = standings.find(s => s.team === team);
                            return teamStanding ? teamStanding.rank : null;
                        });
                        
                        // 포인트 스타일 초기화 (마지막 포인트만 로고)
                        const pointStyles = dataset.data.map((_, index) => 
                            index === dataset.data.length - 1 ? this.teamLogoImages[team] : false
                        );
                        const pointRadii = dataset.data.map((_, index) => 
                            index === dataset.data.length - 1 ? 12 : 0
                        );
                        
                        dataset.pointStyle = pointStyles;
                        dataset.pointRadius = pointRadii;
                        dataset.pointHoverRadius = pointRadii.map(r => r + 2);
                    });
                    this.rankChart.update('none');
                }
            }
            
            // 애니메이션 전용 차트 업데이트 메서드들 (새 데이터 포인트 추가)
            updateChartsForAnimation(selectedDate) {
                if (this.winRateChart) {
                    this.updateWinRateChartForAnimation(selectedDate);
                }
                if (this.winCountChart) {
                    this.updateWinCountChartForAnimation(selectedDate);
                }
                if (this.rankChart) {
                    this.updateRankChartForAnimation(selectedDate);
                }
            }
            
            updateWinRateChartForAnimation(selectedDate) {
                if (!this.winRateChart) return;
                
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 현재까지의 데이터만 사용
                const chartData = this.seasonData.slice(0, selectedIndex + 1);
                const labels = chartData.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 차트 라벨 업데이트
                this.winRateChart.data.labels = labels;
                
                // 각 팀별 데이터 업데이트
                this.winRateChart.data.datasets.forEach(dataset => {
                    const team = dataset.label;
                    if (!this.winRateChartVisibleTeams.has(team)) return;
                    
                    const data = chartData.map(dayData => {
                        const standings = this.calculateStandings(dayData.date);
                        const teamStanding = standings.find(s => s.team === team);
                        return teamStanding ? teamStanding.winRate : null;
                    });
                    
                    // 데이터 전체 교체 (애니메이션을 위해)
                    dataset.data = [...data];
                    
                    // 포인트 스타일 업데이트 (마지막 포인트만 로고, 나머지는 원형)
                    const logoImage = this.teamLogoImages[team];
                    const pointStyles = dataset.data.map((_, index) => 
                        index === dataset.data.length - 1 ? (logoImage || 'circle') : 'circle'
                    );
                    const pointRadii = dataset.data.map((_, index) => 
                        index === dataset.data.length - 1 && logoImage ? 10 : 1.5
                    );
                    
                    dataset.pointStyle = pointStyles;
                    dataset.pointRadius = pointRadii;
                    dataset.pointHoverRadius = pointRadii.map(r => r + 2);
                });
                
                // 부드러운 애니메이션으로 업데이트
                this.winRateChart.update({
                    duration: 400,
                    easing: 'easeInOutCubic'
                });
            }
            
            updateWinCountChartForAnimation(selectedDate) {
                if (!this.winCountChart) return;
                
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 현재까지의 데이터만 사용
                const chartData = this.seasonData.slice(0, selectedIndex + 1);
                const labels = chartData.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 라벨 업데이트
                this.winCountChart.data.labels = labels;

                // 최대 승수 계산 (Y축 max 설정용)
                let maxWins = 0;
                chartData.forEach(dayData => {
                    const standings = this.calculateStandings(dayData.date);
                    standings.forEach(teamData => {
                        if (teamData.wins > maxWins) {
                            maxWins = teamData.wins;
                        }
                    });
                });
                // Y축 max를 5의 배수로 올림
                const yMax = Math.ceil(maxWins / 5) * 5;
                this.winCountChart.options.scales.y.max = yMax;
                
                // 각 데이터셋의 데이터만 업데이트
                this.winCountChart.data.datasets.forEach(dataset => {
                    const team = dataset.label;
                    if (!this.winCountChartVisibleTeams.has(team)) return;
                    
                    const data = chartData.map(dayData => {
                        const standings = this.calculateStandings(dayData.date);
                        const teamData = standings.find(s => s.team === team);
                        return teamData ? teamData.wins : 0;
                    });
                    
                    // 데이터 전체 교체 (애니메이션을 위해)
                    dataset.data = [...data];
                    
                    // 포인트 스타일 업데이트 (마지막 포인트만 로고, 나머지는 원형)
                    const logoImage = this.teamLogoImages[team];
                    const pointStyles = data.map((_, index) => 
                        index === data.length - 1 ? (logoImage || 'circle') : 'circle'
                    );
                    const pointRadii = data.map((_, index) => 
                        index === data.length - 1 && logoImage ? 10 : 1.5
                    );
                    
                    dataset.pointStyle = pointStyles;
                    dataset.pointRadius = pointRadii;
                    dataset.pointHoverRadius = pointRadii.map(r => r + 2);
                });
                
                this.winCountChart.update({
                    duration: 600,
                    easing: 'easeInOutQuart'
                }); // 부드러운 애니메이션으로 업데이트
            }
            
            updateRankChartForAnimation(selectedDate) {
                if (!this.rankChart) return;
                
                const selectedIndex = this.seasonData.findIndex(d => d.date === selectedDate);
                if (selectedIndex === -1) return;
                
                // 현재까지의 데이터만 사용
                const chartData = this.seasonData.slice(0, selectedIndex + 1);
                const labels = chartData.map(d => {
                    const [, month, day] = d.date.split('-');
                    return `${month}/${day}`;
                });
                
                // 차트 라벨 업데이트
                this.rankChart.data.labels = labels;
                
                // 각 팀별 데이터 업데이트
                this.rankChart.data.datasets.forEach(dataset => {
                    const team = dataset.label;
                    if (!this.rankChartVisibleTeams.has(team)) return;
                    
                    const data = chartData.map(dayData => {
                        const standings = this.calculateStandings(dayData.date);
                        const teamStanding = standings.find(s => s.team === team);
                        return teamStanding ? teamStanding.rank : null;
                    });
                    
                    // 데이터 전체 교체 (애니메이션을 위해)
                    dataset.data = [...data];
                    
                    // 포인트 스타일 업데이트 (마지막 포인트만 로고, 나머지는 원형)
                    const logoImage = this.teamLogoImages[team];
                    const pointStyles = dataset.data.map((_, index) => 
                        index === dataset.data.length - 1 ? (logoImage || 'circle') : 'circle'
                    );
                    const pointRadii = dataset.data.map((_, index) => 
                        index === dataset.data.length - 1 && logoImage ? 10 : 1.5
                    );
                    
                    dataset.pointStyle = pointStyles;
                    dataset.pointRadius = pointRadii;
                    dataset.pointHoverRadius = pointRadii.map(r => r + 2);
                });
                
                // 부드러운 애니메이션으로 업데이트
                this.rankChart.update({
                    duration: 400,
                    easing: 'easeInOutCubic'
                });
            }

            showError(message) {
                const standingsContainer = document.getElementById('daily-stats-standings-container');
                const gamesContainer = document.getElementById('daily-stats-games-container');
                
                const errorHtml = `<div style="text-align: center; color: #ef4444; padding: 20px;">❌ ${message}</div>`;
                
                if (standingsContainer) standingsContainer.innerHTML = errorHtml;
                if (gamesContainer) gamesContainer.innerHTML = errorHtml;
            }
            
            // 네비게이션 메서드들
            changeDate(days) {
                const dateParts = this.currentDate.split('-');
                const currentDate = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
                
                // 경기가 있는 날짜만 찾기
                let attempts = 0;
                const maxAttempts = 30; // 최대 30일까지 찾아보기
                
                while (attempts < maxAttempts) {
                    currentDate.setDate(currentDate.getDate() + days);
                    attempts++;
                    
                    const newDateStr = currentDate.getFullYear() + '-' + 
                                      String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                                      String(currentDate.getDate()).padStart(2, '0');
                    
                    // 날짜 범위 체크
                    if (newDateStr < this.startDate || newDateStr > this.endDate) {
                        break;
                    }
                    
                    // 해당 날짜에 경기가 있는지 체크
                    const dayData = this.seasonData.find(d => d.date === newDateStr);
                    if (dayData && dayData.games.length > 0) {
                        this.updateDisplay(newDateStr);
                        return;
                    }
                }
                
                // 경기가 있는 날짜를 찾지 못한 경우, 기존 방식대로 진행
                const finalDate = this.currentDate.split('-');
                const fallbackDate = new Date(parseInt(finalDate[0]), parseInt(finalDate[1]) - 1, parseInt(finalDate[2]));
                fallbackDate.setDate(fallbackDate.getDate() + days);
                
                const fallbackDateStr = fallbackDate.getFullYear() + '-' + 
                                       String(fallbackDate.getMonth() + 1).padStart(2, '0') + '-' + 
                                       String(fallbackDate.getDate()).padStart(2, '0');
                
                if (fallbackDateStr >= this.startDate && fallbackDateStr <= this.endDate) {
                    this.updateDisplay(fallbackDateStr);
                }
            }
            
            selectDate(dateStr) {
                if (dateStr >= this.startDate && dateStr <= this.endDate) {
                    this.updateDisplay(dateStr);
                }
            }
            
            goToday() {
                // 실제 경기 데이터가 있는 최신 날짜 찾기
                let lastGameDate = this.endDate;
                for (let i = this.seasonData.length - 1; i >= 0; i--) {
                    if (this.seasonData[i].games.length > 0) {
                        lastGameDate = this.seasonData[i].date;
                        break;
                    }
                }
                this.updateDisplay(lastGameDate);
            }
            
            toggleAnimation() {
                if (this.isAnimating) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }
            
            startAnimation() {
                if (this.isAnimating) return;
                
                this.isAnimating = true;
                const animationBtn = document.getElementById('daily-stats-animation-btn');
                
                animationBtn.innerHTML = '⏸️ 일시정지';
                animationBtn.style.background = '#dc3545';
                
                // 애니메이션 날짜가 없으면 현재 날짜부터 시작, 있으면 그 날짜부터 계속
                if (!this.animationDate) {
                    this.animationDate = new Date(this.currentDate + 'T00:00:00');
                }
                
                // 애니메이션 시작 시 차트 데이터 초기화 (시작 날짜까지만)
                this.initializeChartsForAnimation();
                
                this.animationInterval = setInterval(() => {
                    if (!this.isAnimating) return;
                    
                    // 경기가 있는 날짜를 찾을 때까지 반복
                    let attempts = 0;
                    const maxAttempts = 30;
                    let hasGameData = false;
                    
                    while (attempts < maxAttempts && !hasGameData) {
                        const dateStr = this.animationDate.toISOString().split('T')[0];
                        
                        // 최대 날짜 체크 (endDate 사용하여 8월 19일 포함)
                        if (dateStr > this.endDate) {
                            this.stopAnimation();
                            return;
                        }
                        
                        // 해당 날짜에 경기가 있는지 체크
                        const dayData = this.seasonData.find(d => d.date === dateStr);
                        if (dayData && dayData.games.length > 0) {
                            // 경기가 있는 날만 업데이트
                            this.updateDisplayForAnimation(dateStr);
                            this.updateChartsForAnimation(dateStr);
                            hasGameData = true;
                        }
                        
                        // 다음 날로 이동 (경기 유무와 관계없이)
                        this.animationDate.setDate(this.animationDate.getDate() + 1);
                        attempts++;
                    }
                    
                    // 경기가 있는 날을 찾지 못하면 애니메이션 종료
                    if (!hasGameData) {
                        this.stopAnimation();
                    }
                }, this.getAnimationInterval()); // 동적 애니메이션 속도
            }
            
            // 애니메이션 속도에 따른 간격 계산 (밀리초)
            getAnimationInterval() {
                const speedMap = {
                    1: 2000,   // 매우 느림: 2초
                    2: 1200,   // 느림: 1.2초  
                    3: 800,    // 보통: 0.8초 (기본값)
                    4: 500,    // 빠름: 0.5초
                    5: 300     // 매우 빠름: 0.3초
                };
                return speedMap[this.animationSpeed] || 800;
            }
            
            // 애니메이션 속도 업데이트
            updateAnimationSpeed(speed) {
                this.animationSpeed = parseInt(speed);
                
                // 애니메이션 중이면 재시작하여 새로운 속도 적용
                if (this.isAnimating) {
                    const wasAnimating = this.isAnimating;
                    this.stopAnimation();
                    if (wasAnimating) {
                        this.startAnimation();
                    }
                }
                
                // 속도 표시 업데이트
                const speedDisplay = document.getElementById('speed-display');
                const speedLabels = {
                    1: '매우느림',
                    2: '느림', 
                    3: '보통',
                    4: '빠름',
                    5: '매우빠름'
                };
                if (speedDisplay) {
                    speedDisplay.textContent = speedLabels[this.animationSpeed] || '보통';
                }
            }
            
            stopAnimation() {
                this.isAnimating = false;
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                    this.animationInterval = null;
                }
                
                const animationBtn = document.getElementById('daily-stats-animation-btn');
                animationBtn.innerHTML = '▶️ 애니메이션';
                animationBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            }
            
            resetAnimation() {
                this.stopAnimation();
                
                // 시작 날짜로 이동하고 애니메이션 날짜도 리셋
                this.animationDate = new Date('2025-03-22T00:00:00');
                this.selectDate('2025-03-22');
            }
        }

        // Service Worker 등록 (간소화)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // 전역 인스턴스
        let completeDailyStats = null;

        // DOM 로드 완료 후 초기화
        document.addEventListener('DOMContentLoaded', function() {
            // 팀 로고 먼저 로드
            window.loadTeamLogos().then(() => {
                // 모든 팀 로고 로드 완료 후 차트들 업데이트
                setTimeout(() => {
                    // 일자별 차트 업데이트
                    if (completeDailyStats && completeDailyStats.rankChart) {
                        completeDailyStats.rankChart.update();
                    }
                    
                    // 메인 차트들 업데이트
                    if (winRateChartInstance) {
                        winRateChartInstance.update();
                    }
                    if (chartState && chartState.chart) {
                        chartState.chart.update();
                    }
                }, 100);
            });
            
            const dailyStatsCard = document.getElementById('daily-stats');
            if (dailyStatsCard) {
                setTimeout(async () => {
                    completeDailyStats = new CompleteDailyStats();
                    
                    // CompleteDailyStats 초기화 완료 대기
                    await completeDailyStats.initPromise;
                    
                    window.dailyStatsModule = completeDailyStats; // 전역 접근
                    window.dailyStatsManager = completeDailyStats; // 레전드 버튼용 전역 접근
                    window.dailyStats = completeDailyStats; // 승률 차트용 전역 접근
                    
                    // 통일된 메인 카드 차트 초기화 시스템
                    initializeMainCharts();
                }, 1000);
            }
        });

        // 전역 함수 (HTML onclick 용)
        function dailyStatsChangeDate(days) { 
            if (completeDailyStats) completeDailyStats.changeDate(days);
        }
        function dailyStatsSelectDate(date) { 
            if (completeDailyStats) completeDailyStats.selectDate(date);
        }
        function dailyStatsGoToday() { 
            if (completeDailyStats) completeDailyStats.goToday();
        }
        function dailyStatsToggleAnimation() { 
            if (completeDailyStats) completeDailyStats.toggleAnimation();
        }
        function dailyStatsResetAnimation() { 
            if (completeDailyStats) completeDailyStats.resetAnimation();
        }
        function dailyStatsUpdateAnimationSpeed(speed) { 
            if (completeDailyStats) completeDailyStats.updateAnimationSpeed(speed);
        }
    </script>
    
    <!-- 순위 변동 그래프 - 데이터 경로 오버라이드 (AdSense 안전) -->
    <script>
        // root index용 데이터 경로 수정 - AdSense 요청은 건드리지 않음
        const originalFetch = window.fetch;
        window.fetch = function(url, ...args) {
            // AdSense 관련 요청은 건드리지 않음
            if (typeof url === 'string' &&
                (url.includes('googlesyndication.com') ||
                 url.includes('googletagmanager.com') ||
                 url.includes('google.com/pagead'))) {
                return originalFetch(url, ...args);
            }

            // 로컬 데이터 파일만 경로 수정
            if (url === 'data/raw-game-records.json') {
                url = 'magic-number/data/raw-game-records.json';
            }
            return originalFetch(url, ...args);
        };
    </script>
    <script src="magic-number/scripts/ui-charts.js"></script>

    <!-- ROOT INDEX 메인 승률 추이 카드 관련 스크립트 (일별통계 섹션과는 별개) -->
    <script>
        // 승률 차트 전역 변수
        let winRateChartInstance = null;
        let winRateChartState = {
            isFullView: true,
            currentPeriod: 0,
            periods: []
        };
        let winRateChartVisibleTeams = new Set(getRankingSystem().teams);
        // winRateChartTeamLogos 제거: 글로벌 teamLogos 사용
        
        // 단순화된 로고 시스템: window.loadTeamLogos만 사용
        
        // 통일된 메인 카드 차트 초기화 시스템
        async function initializeMainCharts() {
            try {
                // 1단계: 팀 로고 이미지 로드 (일일 차트와 같은 방식)
                console.log('메인 차트 초기화 시작...');
                if (typeof window.loadTeamLogos === 'function') {
                    console.log('팀 로고 로딩 시작...');
                    await window.loadTeamLogos();
                    console.log('팀 로고 이미지 로드 완료. 로드된 팀:', Object.keys(window.teamLogoImages));
                    // 글로벌 접근을 위해 teamLogos도 확인
                    console.log('글로벌 teamLogos:', Object.keys(teamLogos));
                }
                
                // 2-1단계: 승수 변동 추이 차트 초기화 (ui-charts.js 사용)
                if (typeof window.initWinCountChart === 'function') {
                    console.log('승수 변동 차트 초기화 중...');
                    const winCountCanvas = document.getElementById('winCountChart');
                    console.log('winCountChart 캔버스 존재:', !!winCountCanvas);
                    await window.initWinCountChart();
                } else {
                    console.warn('window.initWinCountChart 함수를 찾을 수 없습니다');
                }

                // 2-2단계: 순위 변동 차트 초기화 (simple-chart.js 사용)
                if (typeof initSimpleChart === 'function') {
                    console.log('순위 변동 차트 초기화 중...');
                    const rankCanvas = document.getElementById('rankChart');
                    console.log('rankChart 캔버스 존재:', !!rankCanvas);
                    await initSimpleChart();
                    // 순위 변동 차트 설정
                    if (chartState && chartState.chart) {
                        chartState.chart.options.layout.padding = {
                            left: 15, right: 15, top: 15, bottom: 15
                        };
                        chartState.chart.update('none');
                    }
                    console.log('순위 변동 차트 초기화 완료');
                } else {
                    console.warn('initSimpleChart 함수를 찾을 수 없습니다');
                }
                
                // 3단계: 승률 추이 차트 초기화 (dailyStats 데이터 대기)
                const waitForDailyStatsAndInitWinRate = async () => {
                    let retryCount = 0;
                    const maxRetries = 20; // 최대 20초 대기
                    
                    while (retryCount < maxRetries) {
                        console.log(`승률 차트 대기 중... (${retryCount + 1}/${maxRetries})`);
                        console.log('window.dailyStats 존재:', !!window.dailyStats);
                        console.log('seasonData 존재:', !!(window.dailyStats && window.dailyStats.seasonData));
                        
                        if (window.dailyStats && window.dailyStats.seasonData && window.dailyStats.seasonData.length > 0) {
                            console.log('승률 추이 차트 초기화 중...');
                            const winRateCanvas = document.getElementById('winRateChart');
                            console.log('winRateChart 캔버스 존재:', !!winRateCanvas);
                            console.log('createWinRateChart 함수 존재:', typeof createWinRateChart === 'function');
                            console.log('winRateChartInstance 상태:', !!winRateChartInstance);
                            
                            if (!winRateChartInstance && typeof createWinRateChart === 'function') {
                                await createWinRateChart();
                                console.log('승률 추이 차트 초기화 완료');
                            }
                            
                            // 승차 변화 차트도 초기화
                            if (!winGapChartInstance && typeof createWinGapChart === 'function') {
                                await createWinGapChart();
                                console.log('승차 변화 차트 초기화 완료');
                            }
                            break;
                        }
                        
                        retryCount++;
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    if (retryCount >= maxRetries) {
                        console.warn('승률 추이 차트 초기화 시간 초과');
                    }
                };
                
                // 메인 차트들을 비동기로 초기화 (메인 흐름을 차단하지 않음)
                waitForDailyStatsAndInitWinRate();
                createWinGapChart(); // 승차 변화 차트 초기화
                
                // 4단계: 일별통계 내 차트 업데이트 (로고 로딩 완료 후)
                setTimeout(() => {
                    if (completeDailyStats && completeDailyStats.rankChart) {
                        console.log('일별통계 순위 차트 업데이트');
                        completeDailyStats.rankChart.update();
                    }
                }, 500);
                
                
                console.log('메인 차트 초기화 완료');
                
            } catch (error) {
                console.error('메인 차트 초기화 실패:', error);
            }
        }

        // 승차 변화 차트 전역 변수
        let winGapChartInstance = null;
        let winGapChartState = {
            isFullView: true,
            currentPeriod: 0,
            periods: []
        };

        // 승차 변화 차트 처리 함수들
        function handlePrevPeriodWinGap() {
            console.log('이전 버튼 클릭');
            console.log('현재 상태:', winGapChartState);
            if (!winGapChartState.isFullView && winGapChartState.currentPeriod > 0) {
                winGapChartState.currentPeriod--;
                console.log('이전 기간으로 변경:', winGapChartState.currentPeriod);
                
                // 차트를 완전히 재생성하여 데이터 포인트 업데이트 보장
                if (winGapChartInstance) {
                    console.log('🔄 기존 차트 destroy하고 캔버스 재생성');
                    winGapChartInstance.destroy();
                    winGapChartInstance = null;
                    
                    // 캔버스 요소 완전 교체
                    const canvasContainer = document.querySelector('#winGapChart').parentElement;
                    const oldCanvas = document.querySelector('#winGapChart');
                    const newCanvas = document.createElement('canvas');
                    newCanvas.id = 'winGapChart';
                    newCanvas.style.cssText = oldCanvas.style.cssText;
                    canvasContainer.replaceChild(newCanvas, oldCanvas);
                    console.log('🎨 캔버스 요소 완전 교체됨 (월별 네비게이션)');
                }
                
                updateWinGapChart();
            } else {
                console.log('이전 버튼 비활성 조건:', {
                    isFullView: winGapChartState.isFullView,
                    currentPeriod: winGapChartState.currentPeriod
                });
            }
        }

        function handleNextPeriodWinGap() {
            console.log('다음 버튼 클릭');
            console.log('현재 상태:', winGapChartState);
            if (!winGapChartState.isFullView && winGapChartState.currentPeriod < winGapChartState.periods.length - 1) {
                winGapChartState.currentPeriod++;
                console.log('다음 기간으로 변경:', winGapChartState.currentPeriod);
                
                // 차트를 완전히 재생성하여 데이터 포인트 업데이트 보장
                if (winGapChartInstance) {
                    console.log('🔄 기존 차트 destroy하고 캔버스 재생성');
                    winGapChartInstance.destroy();
                    winGapChartInstance = null;
                    
                    // 캔버스 요소 완전 교체
                    const canvasContainer = document.querySelector('#winGapChart').parentElement;
                    const oldCanvas = document.querySelector('#winGapChart');
                    const newCanvas = document.createElement('canvas');
                    newCanvas.id = 'winGapChart';
                    newCanvas.style.cssText = oldCanvas.style.cssText;
                    canvasContainer.replaceChild(newCanvas, oldCanvas);
                    console.log('🎨 캔버스 요소 완전 교체됨 (월별 네비게이션)');
                }
                
                updateWinGapChart();
            } else {
                console.log('다음 버튼 비활성 조건:', {
                    isFullView: winGapChartState.isFullView,
                    currentPeriod: winGapChartState.currentPeriod,
                    periodsLength: winGapChartState.periods.length
                });
            }
        }

        function handlePeriodToggleWinGap() {
            console.log('전체시즌 토글 버튼 클릭');
            console.log('현재 isFullView:', winGapChartState.isFullView);
            winGapChartState.isFullView = !winGapChartState.isFullView;
            console.log('변경된 isFullView:', winGapChartState.isFullView);
            
            // 차트를 완전히 재생성하여 데이터 포인트 업데이트 보장
            if (winGapChartInstance) {
                console.log('🔄 기존 차트 destroy하고 캔버스 재생성');
                winGapChartInstance.destroy();
                winGapChartInstance = null;
                
                // 캔버스 요소 완전 교체
                const canvasContainer = document.querySelector('#winGapChart').parentElement;
                const oldCanvas = document.querySelector('#winGapChart');
                const newCanvas = document.createElement('canvas');
                newCanvas.id = 'winGapChart';
                newCanvas.style.cssText = oldCanvas.style.cssText;
                canvasContainer.replaceChild(newCanvas, oldCanvas);
                console.log('🎨 캔버스 요소 완전 교체됨');
            }
            
            updateWinGapChart();
        }

        // 승차 변화 차트 생성 및 업데이트 함수
        async function createWinGapChart() {
            console.log('🎯 createWinGapChart 함수 시작');
            try {
                // Chart.js 지연 로딩 먼저 실행
                console.log('📦 Chart.js 지연 로딩 시작');
                await window.loadChartJs();
                console.log('✅ Chart.js 로딩 완료');
                
                console.log('Chart 라이브러리 확인:', typeof Chart);
                if (typeof Chart === 'undefined') {
                    console.error('❌ Chart.js 라이브러리가 여전히 로드되지 않음');
                    return;
                }
                
                const ctx = document.getElementById('winGapChart');
                console.log('캔버스 요소:', ctx);
                if (!ctx) {
                    console.error('❌ winGapChart 캔버스를 찾을 수 없음');
                    return;
                }

                // 일자별 통계 데이터가 로드될 때까지 대기
                let retryCount = 0;
                const maxRetries = 10;
                console.log('📊 dailyStats 데이터 대기 중...');

                while (!window.dailyStats?.seasonData && retryCount < maxRetries) {
                    console.log(`대기 중... (${retryCount + 1}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    retryCount++;
                }

                console.log('dailyStats:', !!window.dailyStats);
                console.log('seasonData:', !!window.dailyStats?.seasonData);
                console.log('seasonData 길이:', window.dailyStats?.seasonData?.length);

                if (!window.dailyStats?.seasonData) {
                    console.error('❌ 일자별 통계 데이터를 로드할 수 없습니다.');
                    return;
                }

                console.log('📈 updateWinGapChart 호출');
                // 첫 차트 생성 시에만 currentPeriod 초기화
                if (window.dailyStats?.seasonData) {
                    const tempPeriods = createMonthlyPeriods(window.dailyStats.seasonData);
                    winGapChartState.currentPeriod = tempPeriods.length - 1; // 가장 최근 기간으로 설정
                    console.log('currentPeriod 초기화됨:', winGapChartState.currentPeriod);
                }
                
                updateWinGapChart();
                updateWinGapProgressIndicator();
                console.log('✅ 승차 변화 차트 초기화 완료');
            } catch (error) {
                console.error('❌ 승차 변화 차트 생성 실패:', error);
                console.error('에러 스택:', error.stack);
            }
        }

        // 승차 변화 차트 업데이트 함수
        function updateWinGapChart() {
            // dailyStats가 아직 로드되지 않았다면 잠시 후 다시 시도
            if (!window.dailyStats) {
                setTimeout(() => updateWinGapChart(), 500);
                return;
            }
            
            if (!window.dailyStats.seasonData) {
                console.error('seasonData가 없습니다');
                return;
            }

            if (!window.dailyStats || !window.dailyStats.seasonData) {
                console.error('window.dailyStats 또는 seasonData가 초기화되지 않았습니다');
                return;
            }
            
            const seasonData = window.dailyStats.seasonData;
            
            if (!Array.isArray(seasonData) || seasonData.length === 0) {
                console.error('seasonData가 배열이 아니거나 비어있습니다:', seasonData);
                return;
            }

            // 기간별 데이터 준비
            winGapChartState.periods = createMonthlyPeriods(seasonData);
            
            let chartData;
            if (winGapChartState.isFullView) {
                chartData = seasonData;
            } else {
                const period = winGapChartState.periods[winGapChartState.currentPeriod];
                if (!period) {
                    return;
                }
                // period.data를 직접 사용 (이미 해당 월의 데이터가 포함되어 있음)
                chartData = period.data || [];
            }

            if (chartData.length === 0) {
                return;
            }

            // 승차 계산
            const teamWinGaps = {};
            const teams = ['KIA', '삼성', 'LG', '두산', 'KT', 'NC', 'SSG', '롯데', '한화', '키움'];
            
            teams.forEach(team => {
                teamWinGaps[team] = [];
            });

            chartData.forEach(dayData => {
                const standings = window.dailyStats.calculateStandings(dayData.date);
                const firstPlaceWins = Math.max(...standings.map(team => team.wins));
                
                standings.forEach(teamData => {
                    const winGap = teamData.gamesBehind || 0; // 공식 게임차 사용
                    teamWinGaps[teamData.team].push(winGap);
                });
            });

            const labels = chartData.map(d => {
                const [, month, day] = d.date.split('-');
                return `${month}/${day}`;
            });

            const datasets = teams.map(team => {
                const teamColor = window.dailyStats.teamColors[team] || '#666';
                const data = teamWinGaps[team];
                const logoImage = window.teamLogoImages[team];
                
                // pointStyle 방식 제거 - plugins 시스템으로 대체

                return {
                    label: team,
                    data: data,
                    borderColor: teamColor,
                    backgroundColor: teamColor + '20',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    pointBackgroundColor: teamColor,
                    pointBorderColor: teamColor
                };
            });

            
            const ctx = document.getElementById('winGapChart');
            if (!ctx) {
                return;
            }

            if (!winGapChartInstance) {
                try {
                    winGapChartInstance = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    plugins: [{
                        id: 'teamLogos',
                        afterDraw: (chart) => {
                            const ctx = chart.ctx;
                            if (!window.teamLogoImages || Object.keys(window.teamLogoImages).length === 0) {
                                return;
                            }
                            
                            chart.data.datasets.forEach((dataset, index) => {
                                const meta = chart.getDatasetMeta(index);
                                if (meta.data && meta.data.length > 0 && !meta.hidden) {
                                    const lastPoint = meta.data[meta.data.length - 1];
                                    const teamName = dataset.label;
                                    const logoImg = window.teamLogoImages[teamName];
                                    
                                    if (logoImg && lastPoint && typeof lastPoint.x === 'number' && typeof lastPoint.y === 'number') {
                                        ctx.save();
                                        ctx.globalCompositeOperation = 'source-over';
                                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                                        ctx.shadowBlur = 3;
                                        ctx.shadowOffsetX = 2;
                                        ctx.shadowOffsetY = 2;
                                        const size = 32;
                                        ctx.drawImage(logoImg, lastPoint.x - size/2, lastPoint.y - size/2, size, size);
                                        ctx.restore();
                                    }
                                }
                            });
                        }
                    }],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                left: 10,
                                right: 20,
                                top: 25,
                                bottom: 10
                            }
                        },
                        scales: {
                            y: {
                                reverse: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: '게임차'
                                },
                                ticks: {
                                    stepSize: 1,
                                    callback: function(value) {
                                        return value === 0 ? '동률' : `${value}게임차`;
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: false
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45,
                                    font: {
                                        size: 11
                                    },
                                    maxTicksLimit: 120
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                itemSort: (a, b) => a.parsed.y - b.parsed.y, // 승차 낮은 순(순위 높은 순)으로 정렬
                                callbacks: {
                                    title: function(tooltipItems) {
                                        return `${tooltipItems[0].label} 기준`;
                                    },
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        return `${context.dataset.label}: ${value === 0 ? '동률' : value + '게임차'}`;
                                    }
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        animation: {
                            duration: 600,
                            easing: 'easeInOutQuart'
                        }
                    }
                });
                } catch (chartError) {
                    return;
                }
            } else {
                try {
                    winGapChartInstance.data.labels = [...labels];
                    winGapChartInstance.data.datasets = datasets.map(ds => ({...ds, data: [...ds.data]}));
                    
                    winGapChartInstance.resize();
                    winGapChartInstance.update('active');
                } catch (updateError) {
                    return;
                }
            }

            // 네비게이션 버튼 업데이트
            updateWinGapNavigation();
            // 레전드 업데이트 (ui-charts.js의 커스텀 레전드 사용)
            console.log('승차 차트 레전드 업데이트 시도');
            console.log('createWinGapCustomLegend 함수 존재:', typeof createWinGapCustomLegend);
            console.log('window.createWinGapCustomLegend 함수 존재:', typeof window.createWinGapCustomLegend);
            if (typeof window.createWinGapCustomLegend === 'function') {
                console.log('커스텀 레전드 사용');
                window.createWinGapCustomLegend(teams, winGapChartInstance);
            } else if (typeof createWinGapCustomLegend === 'function') {
                console.log('로컬 커스텀 레전드 사용');
                createWinGapCustomLegend(teams, winGapChartInstance);
            } else {
                console.log('기본 레전드 사용');
                updateWinGapLegend(teams);
            }
        }

        // 승차 변화 차트 네비게이션 업데이트
        function updateWinGapNavigation() {
            const prevBtn = document.getElementById('prevPeriodWinGap');
            const nextBtn = document.getElementById('nextPeriodWinGap');
            const toggleBtn = document.getElementById('periodToggleWinGap');
            const periodText = document.getElementById('currentPeriodTextWinGap');

            if (winGapChartState.isFullView) {
                if (prevBtn) {
                    prevBtn.style.opacity = '0.3';
                    prevBtn.style.display = 'none';
                    prevBtn.textContent = '← 이전월';
                }
                if (nextBtn) {
                    nextBtn.style.opacity = '0.3';
                    nextBtn.style.display = 'none';
                    nextBtn.textContent = '다음월 →';
                }
                if (toggleBtn) toggleBtn.textContent = '🗓️ 월별 보기';
                
                // 전체 시즌 기간 표시
                if (periodText) {
                    if (winGapChartState.periods && winGapChartState.periods.length > 0) {
                        const firstPeriod = winGapChartState.periods[0];
                        const lastPeriod = winGapChartState.periods[winGapChartState.periods.length - 1];
                        if (firstPeriod.data.length > 0 && lastPeriod.data.length > 0) {
                            const startDate = new Date(firstPeriod.data[0].date);
                            const endDate = new Date(lastPeriod.data[lastPeriod.data.length - 1].date);
                            periodText.textContent = `전체 시즌: ${startDate.getFullYear()}년 ${startDate.getMonth() + 1}월 ${startDate.getDate()}일 - ${endDate.getFullYear()}년 ${endDate.getMonth() + 1}월 ${endDate.getDate()}일`;
                        } else {
                            periodText.textContent = `전체 시즌: 2025년 3월 22일 개막 ~ 현재`;
                        }
                    } else {
                        periodText.textContent = `전체 시즌: 2025년 3월 22일 개막 ~ 현재`;
                    }
                    periodText.style.visibility = 'visible';
                }
            } else {
                // 이전월 버튼 처리
                if (winGapChartState.currentPeriod === 0) {
                    if (prevBtn) prevBtn.style.display = 'none';
                } else {
                    if (prevBtn) {
                        prevBtn.style.display = 'inline-block';
                        prevBtn.style.opacity = '1';
                        const prevPeriod = winGapChartState.periods[winGapChartState.currentPeriod - 1];
                        prevBtn.textContent = prevPeriod ? `← ${prevPeriod.name}` : '← 이전월';
                    }
                }
                
                // 다음월 버튼 처리
                if (winGapChartState.currentPeriod >= winGapChartState.periods.length - 1) {
                    if (nextBtn) nextBtn.style.display = 'none';
                } else {
                    if (nextBtn) {
                        nextBtn.style.display = 'inline-block';
                        nextBtn.style.opacity = '1';
                        const nextPeriod = winGapChartState.periods[winGapChartState.currentPeriod + 1];
                        nextBtn.textContent = nextPeriod ? `${nextPeriod.name} →` : '다음월 →';
                    }
                }
                
                if (toggleBtn) toggleBtn.textContent = '📊 전체 시즌 보기';
                
                const currentPeriod = winGapChartState.periods[winGapChartState.currentPeriod];
                if (periodText && currentPeriod) {
                    periodText.textContent = `현재 보는 기간: ${currentPeriod.name}`;
                    periodText.style.visibility = 'visible';
                }
            }
            
            // 진행 인디케이터도 업데이트
            updateWinGapProgressIndicator();
        }

        // 승차 변화 차트 진행 인디케이터 업데이트
        function updateWinGapProgressIndicator() {
            const container = document.getElementById('progressDotsWinGap');
            if (!container) return;

            if (winGapChartState.isFullView) {
                container.innerHTML = '';
                return;
            }

            const dots = winGapChartState.periods.map((period, index) => {
                const isActive = index === winGapChartState.currentPeriod;
                return `<div style="
                    width: 8px; 
                    height: 8px; 
                    border-radius: 50%; 
                    background: ${isActive ? '#28a745' : '#ddd'};
                    transition: all 0.3s ease;
                " title="${period.name}"></div>`;
            }).join('');

            container.innerHTML = dots;
        }

        // 승차 변화 차트 레전드 업데이트
        function updateWinGapLegend(teams) {
            const legendContainer = document.getElementById('winGapChartLegend');
            if (!legendContainer) return;

            legendContainer.innerHTML = '';

            const allSelected = teams.every(team => winGapChartInstance.isDatasetVisible(winGapChartInstance.data.datasets.findIndex(d => d.label === team)));

            // 전체 선택/해제 버튼
            const allButton = document.createElement('button');
            allButton.textContent = allSelected ? '전체 해제' : '전체 선택';
            allButton.style.cssText = `
                padding: 4px 8px;
                margin: 2px;
                border: 1px solid #ddd;
                border-radius: 4px;
                background: ${allSelected ? '#ff6b6b' : '#28a745'};
                color: white;
                cursor: pointer;
                font-size: 11px;
                transition: all 0.2s ease;
            `;
            allButton.onclick = () => toggleAllWinGapTeams();
            legendContainer.appendChild(allButton);

            // 팀별 버튼
            teams.forEach(team => {
                const datasetIndex = winGapChartInstance.data.datasets.findIndex(d => d.label === team);
                const isVisible = winGapChartInstance.isDatasetVisible(datasetIndex);
                const teamColor = window.dailyStats.teamColors[team] || '#666';

                const button = document.createElement('button');
                button.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    padding: 4px 8px;
                    margin: 2px;
                    border: 1px solid ${teamColor};
                    border-radius: 4px;
                    background: ${isVisible ? teamColor : 'white'};
                    color: ${isVisible ? 'white' : teamColor};
                    cursor: pointer;
                    font-size: 11px;
                    opacity: ${isVisible ? '1' : '0.6'};
                    transition: all 0.2s ease;
                `;

                // 팀 로고
                if (window.teamLogoImages[team]) {
                    const img = document.createElement('img');
                    img.src = window.teamLogoImages[team].src;
                    img.style.cssText = 'width: 14px; height: 14px; object-fit: contain;';
                    button.appendChild(img);
                }

                button.appendChild(document.createTextNode(team));
                button.onclick = () => toggleWinGapTeam(datasetIndex);
                legendContainer.appendChild(button);
            });
        }

        // 승차 변화 차트 팀 토글
        function toggleWinGapTeam(datasetIndex) {
            if (!winGapChartInstance) return;
            
            const isVisible = winGapChartInstance.isDatasetVisible(datasetIndex);
            winGapChartInstance.setDatasetVisibility(datasetIndex, !isVisible);
            winGapChartInstance.update('none');
            
            const teams = ['KIA', '삼성', 'LG', '두산', 'KT', 'NC', 'SSG', '롯데', '한화', '키움'];
            console.log('팀 토글 후 레전드 업데이트');
            if (typeof window.createWinGapCustomLegend === 'function') {
                window.createWinGapCustomLegend(teams, winGapChartInstance);
            } else if (typeof createWinGapCustomLegend === 'function') {
                createWinGapCustomLegend(teams, winGapChartInstance);
            } else {
                updateWinGapLegend(teams);
            }
        }

        // 승차 변화 차트 전체 팀 토글
        function toggleAllWinGapTeams() {
            if (!winGapChartInstance) return;

            const teams = ['KIA', '삼성', 'LG', '두산', 'KT', 'NC', 'SSG', '롯데', '한화', '키움'];
            const allVisible = teams.every(team => winGapChartInstance.isDatasetVisible(winGapChartInstance.data.datasets.findIndex(d => d.label === team)));

            teams.forEach(team => {
                const datasetIndex = winGapChartInstance.data.datasets.findIndex(d => d.label === team);
                winGapChartInstance.setDatasetVisibility(datasetIndex, !allVisible);
            });

            winGapChartInstance.update('none');
            console.log('전체 팀 토글 후 레전드 업데이트');
            if (typeof window.createWinGapCustomLegend === 'function') {
                window.createWinGapCustomLegend(teams, winGapChartInstance);
            } else if (typeof createWinGapCustomLegend === 'function') {
                createWinGapCustomLegend(teams, winGapChartInstance);
            } else {
                updateWinGapLegend(teams);
            }
        }

        // 승률 차트 처리 함수들
        function handlePrevPeriodWinRate() {
            if (!winRateChartState.isFullView && winRateChartState.currentPeriod > 0) {
                winRateChartState.currentPeriod--;
                updateWinRateChart();
            }
        }

        function handleNextPeriodWinRate() {
            if (!winRateChartState.isFullView && winRateChartState.currentPeriod < winRateChartState.periods.length - 1) {
                winRateChartState.currentPeriod++;
                updateWinRateChart();
            }
        }

        function handlePeriodToggleWinRate() {
            winRateChartState.isFullView = !winRateChartState.isFullView;
            updateWinRateChart();
        }

        // 승률 차트 생성 및 업데이트 함수 (안정성 개선)
        async function createWinRateChart() {
            try {
                // Chart.js 지연 로딩 먼저 실행
                await window.loadChartJs();
                console.log('승률 차트: Chart.js 로딩 완료');
                
                if (typeof Chart === 'undefined') {
                    console.error('승률 차트: Chart.js 라이브러리 로드 실패');
                    return;
                }
                
                const ctx = document.getElementById('winRateChart');
                if (!ctx) {
                    console.error('승률 차트: winRateChart 캔버스를 찾을 수 없음');
                    return;
                }

                // 일자별 통계 데이터가 로드될 때까지 대기 (최대 10초)
                let retryCount = 0;
                const maxRetries = 10;
                
                const waitForDailyStats = () => {
                    if (!window.dailyStats || !window.dailyStats.seasonData || window.dailyStats.seasonData.length === 0) {
                        retryCount++;
                        if (retryCount < maxRetries) {
                            setTimeout(createWinRateChart, 1000);
                            return false;
                        } else {
                            console.warn('일자별 통계 데이터 로드 시간 초과, 기본 차트 생성');
                            // 기본 빈 차트 생성
                            winRateChartState.periods = [{ name: '전체 시즌', data: [] }];
                            winRateChartState.currentPeriod = 0;
                            return true;
                        }
                    }
                    return true;
                };
                
                if (!waitForDailyStats()) return;

                // 팀 로고 먼저 로드
                await window.loadTeamLogos();

                // 데이터 처리
                const processedData = await processSeasonDataForWinRateFromDaily();
                
                if (!processedData || processedData.length === 0) {
                    // 최소한 빈 차트라도 생성
                    winRateChartState.periods = [{ name: '전체 시즌', data: [] }];
                    winRateChartState.currentPeriod = 0;
                } else {
                    winRateChartState.periods = createMonthlyPeriods(processedData);
                    winRateChartState.currentPeriod = winRateChartState.periods.length - 1;
                }

                // 팀 표시 상태 초기화 (모든 팀 표시)
                winRateChartVisibleTeams = new Set(['LG', 'KIA', '삼성', '두산', 'SSG', 'NC', '롯데', '한화', 'KT', '키움']);
                
                // 차트 생성
                if (winRateChartInstance) {
                    winRateChartInstance.destroy();
                }

                winRateChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: []
                    },
                    plugins: [{
                        id: 'teamLogos',
                        afterDraw: (chart) => {
                            const ctx = chart.ctx;
                            if (!window.teamLogoImages || Object.keys(window.teamLogoImages).length === 0) {
                                return;
                            }
                            
                            chart.data.datasets.forEach((dataset, index) => {
                                const meta = chart.getDatasetMeta(index);
                                if (meta.data && meta.data.length > 0 && !meta.hidden) {
                                    const lastPoint = meta.data[meta.data.length - 1];
                                    const teamName = dataset.label;
                                    const logoImg = window.teamLogoImages[teamName];
                                    
                                    if (logoImg && lastPoint && typeof lastPoint.x === 'number' && typeof lastPoint.y === 'number') {
                                        ctx.save();
                                        ctx.globalCompositeOperation = 'source-over';
                                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                                        ctx.shadowBlur = 3;
                                        ctx.shadowOffsetX = 2;
                                        ctx.shadowOffsetY = 2;
                                        const size = 32;
                                        ctx.drawImage(logoImg, lastPoint.x - size/2, lastPoint.y - size/2, size, size);
                                        ctx.restore();
                                    }
                                }
                            });
                        }
                    }],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                left: 10,
                                right: 20,
                                top: 10,
                                bottom: 10
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        elements: {
                            point: {
                                borderWidth: 0,  // 테두리 제거하여 채워진 점으로 표시
                                radius: 2        // 점 크기 2px로 줄임
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(3)}`;
                                    }
                                }
                            },
                            legend: {
                                display: false // 기본 레전드 숨김 (커스텀 레전드 사용)
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: false
                                },
                                ticks: {
                                    maxTicksLimit: 30, // 기본값 (업데이트에서 재설정됨)
                                    maxRotation: 45,   // 사선 각도 설정
                                    minRotation: 45,   // 최소 각도도 45도로 고정
                                    font: {
                                        size: 11       // 다른 차트와 동일한 폰트 크기
                                    },
                                    callback: function(value, index, ticks) {
                                        return this.getLabelForValue(value);
                                    }
                                },
                                grid: {
                                    display: true,
                                    color: '#e5e7eb'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '승률'
                                },
                                min: 0.000,
                                max: 1.000,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(3);
                                    },
                                    stepSize: 0.100
                                }
                            }
                        }
                    }
                });

                await updateWinRateChart();
                
                // 초기 레전드 생성
                updateWinRateChartLegend();
            } catch (error) {
                console.error('승률 차트 생성 실패:', error);
            }
        }

        // 일자별 통계 데이터를 활용하여 승률 차트용 데이터 생성
        async function processSeasonDataForWinRateFromDaily() {
            if (!window.dailyStats || !window.dailyStats.seasonData) {
                return [];
            }

            const processedData = [];
            const teams = ['LG', 'KIA', '삼성', '두산', 'SSG', 'NC', '롯데', '한화', 'KT', '키움'];
            
            for (const dayData of window.dailyStats.seasonData) {
                const date = dayData.date;
                const standings = window.dailyStats.calculateStandings(date);
                
                if (!standings || standings.length === 0) continue;
                
                const standingsMap = {};
                standings.forEach(team => {
                    const teamName = team.team_name || team.team || team.name || '';
                    const winRate = team.winRate || team.win_rate || 0;
                    
                    if (teamName && teams.includes(teamName)) {
                        standingsMap[teamName] = winRate;
                    }
                });
                
                if (Object.keys(standingsMap).length >= 5) {
                    processedData.push({ date, standings: standingsMap });
                }
            }

            return processedData;
        }

        // 월별 기간 생성
        function createMonthlyPeriods(data) {
            const periods = [];
            const monthlyData = {};
            
            data.forEach(item => {
                const date = new Date(item.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = [];
                }
                monthlyData[monthKey].push(item);
            });

            Object.keys(monthlyData).sort().forEach(monthKey => {
                const [year, month] = monthKey.split('-');
                const monthData = monthlyData[monthKey];
                monthData.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                periods.push({
                    name: `${year}년 ${month}월`,
                    label: `${year}년 ${month}월`,
                    start: monthData[0].date,
                    end: monthData[monthData.length - 1].date,
                    data: monthData
                });
            });

            return periods;
        }

        // 승률 차트 업데이트 (효율적으로 개선)
        async function updateWinRateChart() {
            if (!winRateChartInstance || !winRateChartState.periods.length) return;
            
            // 공통 팀 로고 시스템 사용 (이미 로드되어 있어야 함)
            // window.teamLogoImages 사용 (loadTeamLogos에서 로드됨)

            const teams = getRankingSystem().teams;
            
            // 일자별 통계와 동일한 팀 색상 사용
            const teamColors = window.dailyStats ? window.dailyStats.teamColors : {
                'LG': '#C30452', 'KIA': '#EA0029', '삼성': '#074CA1',
                '두산': '#131230', 'SSG': '#CE0E2D', 'NC': '#315288',
                '롯데': '#002955', '한화': '#FF6600', 'KT': '#000000', '키움': '#820024'
            };

            let chartData, labels;

            if (winRateChartState.isFullView) {
                // 전체 시즌 데이터
                const allData = winRateChartState.periods.flatMap(p => p.data);
                labels = allData.map(d => {
                    const date = new Date(d.date);
                    return `${date.getMonth() + 1}/${date.getDate()}`;
                });
                chartData = allData;
            } else {
                // 현재 월 데이터
                const currentPeriodData = winRateChartState.periods[winRateChartState.currentPeriod];
                if (!currentPeriodData) return;
                
                labels = currentPeriodData.data.map(d => {
                    const date = new Date(d.date);
                    return `${date.getMonth() + 1}/${date.getDate()}`;
                });
                chartData = currentPeriodData.data;
            }

            // 승률 범위 계산 (Y축 최적화)
            let minWinRate = 1.0, maxWinRate = 0.0;
            chartData.forEach(item => {
                teams.forEach(team => {
                    const winRate = item.standings[team];
                    if (winRate != null && !isNaN(winRate)) {
                        if (winRate < minWinRate) minWinRate = winRate;
                        if (winRate > maxWinRate) maxWinRate = winRate;
                    }
                });
            });

            // Y축 범위 조정 (여유 공간 추가)
            const padding = (maxWinRate - minWinRate) * 0.1;
            const yMin = Math.max(0, minWinRate - padding);
            const yMax = Math.min(1, maxWinRate + padding);

            // 데이터셋 구성 (표시 상태인 팀들만)
            const datasets = teams.filter(team => winRateChartVisibleTeams.has(team)).map(team => {
                const data = chartData.map(item => item.standings[team] || 0);
                
                return {
                    label: team,
                    data: data,
                    borderColor: teamColors[team],
                    backgroundColor: teamColors[team],
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    pointRadius: 3,           // 점 크기 3px
                    pointHoverRadius: 6,      // 호버시 점 크기 6px
                    pointBorderWidth: 0       // 테두리 제거 (채워진 점으로 표시)
                };
            });

            // 기존 차트 데이터만 업데이트 (재생성 대신 효율적 업데이트)
            try {
                winRateChartInstance.data.labels = labels;
                winRateChartInstance.data.datasets = datasets;
                
                // Y축 범위 업데이트
                winRateChartInstance.options.scales.y.min = yMin;
                winRateChartInstance.options.scales.y.max = yMax;
                winRateChartInstance.options.scales.x.ticks.maxTicksLimit = 
                    winRateChartState.isFullView ? 120 : labels.length;
                
                // 차트 업데이트 (애니메이션 없이 빠르게)
                winRateChartInstance.update('none');
                
            } catch (error) {
                console.warn('승률 차트 업데이트 실패, 재생성:', error);
                // 업데이트 실패시에만 재생성
                recreateWinRateChart(labels, datasets, yMin, yMax);
            }

            // 커스텀 레전드 업데이트
            updateWinRateChartLegend();

            // UI 업데이트
            updateWinRateChartUI();
        }

        // 차트 재생성이 필요한 경우에만 호출되는 함수
        function recreateWinRateChart(labels, datasets, yMin, yMax) {
            if (typeof Chart === 'undefined') return;
            if (winRateChartInstance) {
                winRateChartInstance.destroy();
                winRateChartInstance = null;
            }
            
            const ctx = document.getElementById('winRateChart');
            if (!ctx) return;
            
            winRateChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                plugins: [{
                    id: 'teamLogos',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        if (!window.teamLogoImages || Object.keys(window.teamLogoImages).length === 0) {
                            return;
                        }
                        
                        chart.data.datasets.forEach((dataset, index) => {
                            const meta = chart.getDatasetMeta(index);
                            if (meta.data && meta.data.length > 0 && !meta.hidden) {
                                const lastPoint = meta.data[meta.data.length - 1];
                                const teamName = dataset.label;
                                const logoImg = window.teamLogoImages[teamName];
                                
                                if (logoImg && lastPoint && typeof lastPoint.x === 'number' && typeof lastPoint.y === 'number') {
                                    ctx.save();
                                    ctx.globalCompositeOperation = 'source-over';
                                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                                    ctx.shadowBlur = 3;
                                    ctx.shadowOffsetX = 2;
                                    ctx.shadowOffsetY = 2;
                                    const size = 32;
                                    ctx.drawImage(logoImg, lastPoint.x - size/2, lastPoint.y - size/2, size, size);
                                    ctx.restore();
                                }
                            }
                        });
                    }
                }],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 10,
                            right: 50,  // 우측 패딩 추가로 로고 짤림 방지
                            top: 10,
                            bottom: 10
                        }
                    },
                    elements: {
                        point: {
                            borderWidth: 0,  // 테두리 제거하여 채워진 점으로 표시
                            radius: 3        // 점 크기 3px (비어있는 원형 대신 채워진 점)
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            itemSort: function(a, b) {
                                // 승률이 높은 팀부터 정렬 (내림차순)
                                return b.parsed.y - a.parsed.y;
                            },
                            callbacks: {
                                label: (context) => {
                                    const winRate = context.parsed.y.toFixed(3);
                                    return `${context.dataset.label}: ${winRate}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            min: yMin,
                            max: yMax,
                            ticks: {
                                callback: (value) => value.toFixed(3)
                            },
                            title: {
                                display: true,
                                text: '승률'
                            }
                        },
                        x: {
                            ticks: {
                                maxTicksLimit: 120, // x축에 더 많은 날짜 표시
                                maxRotation: 30,   // 읽기 쉽도록 각도 줄임
                                minRotation: 30,   // 최소 각도도 30도로 조정
                                font: {
                                    size: 9        // 더 많은 라벨을 위해 폰트 크기 줄임
                                }
                            },
                            grid: {
                                display: true,
                                color: '#e5e7eb'
                            }
                        }
                    }
                }
            });
        }

        // 승률 차트 UI 업데이트
        function updateWinRateChartUI() {
            // 토글 버튼 텍스트 업데이트
            const toggleBtn = document.getElementById('periodToggleWinRate');
            if (toggleBtn) {
                toggleBtn.textContent = winRateChartState.isFullView ? '📊 월별 보기' : '📊 전체 시즌 보기';
            }

            // 네비게이션 버튼 활성화/비활성화
            const prevBtn = document.getElementById('prevPeriodWinRate');
            const nextBtn = document.getElementById('nextPeriodWinRate');
            const winrateChartNav = document.getElementById('winrate-chart-nav');
            
            if (prevBtn && nextBtn) {
                if (winRateChartState.isFullView) {
                    prevBtn.disabled = true;
                    nextBtn.disabled = true;
                    prevBtn.style.opacity = '0.5';
                    nextBtn.style.opacity = '0.5';
                    prevBtn.textContent = '← 이전월';
                    nextBtn.textContent = '다음월 →';
                    // 전체시즌 모드에서는 버튼 숨김
                    prevBtn.style.display = 'none';
                    nextBtn.style.display = 'none';
                } else {
                    prevBtn.disabled = winRateChartState.currentPeriod === 0;
                    nextBtn.disabled = winRateChartState.currentPeriod >= winRateChartState.periods.length - 1;
                    prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
                    nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
                    
                    // 이전월이 없으면 버튼 숨김, 있으면 표시
                    if (winRateChartState.currentPeriod === 0) {
                        prevBtn.style.display = 'none';
                    } else {
                        prevBtn.style.display = 'inline-block';
                        const prevPeriod = winRateChartState.periods[winRateChartState.currentPeriod - 1];
                        prevBtn.textContent = `← ${prevPeriod.label}`;
                    }
                    
                    // 다음월이 없으면 버튼 숨김, 있으면 표시
                    if (winRateChartState.currentPeriod >= winRateChartState.periods.length - 1) {
                        nextBtn.style.display = 'none';
                    } else {
                        nextBtn.style.display = 'inline-block';
                        const nextPeriod = winRateChartState.periods[winRateChartState.currentPeriod + 1];
                        nextBtn.textContent = `${nextPeriod.label} →`;
                    }
                }
            }
            
            // 네비게이션 컨테이너는 항상 space-between 유지 (플레이스홀더 div가 정렬 처리)

            // 현재 기간 텍스트 업데이트
            const periodText = document.getElementById('currentPeriodTextWinRate');
            if (periodText) {
                if (winRateChartState.isFullView) {
                    // 전체 시즌 모드일 때 전체 기간 표시
                    if (winRateChartState.periods.length > 0) {
                        // 첫 번째 기간의 시작일과 마지막 기간의 종료일 계산
                        const firstPeriod = winRateChartState.periods[0];
                        const lastPeriod = winRateChartState.periods[winRateChartState.periods.length - 1];
                        
                        if (firstPeriod.data.length > 0 && lastPeriod.data.length > 0) {
                            const startDate = new Date(firstPeriod.data[0].date);
                            const endDate = new Date(lastPeriod.data[lastPeriod.data.length - 1].date);
                            periodText.textContent = `전체 시즌: ${startDate.getFullYear()}년 ${startDate.getMonth() + 1}월 ${startDate.getDate()}일 - ${endDate.getFullYear()}년 ${endDate.getMonth() + 1}월 ${endDate.getDate()}일`;
                        } else {
                            periodText.textContent = `전체 시즌: 2025년 3월 22일 개막 ~ 현재`;
                        }
                    } else {
                        periodText.textContent = `전체 시즌: 2025년 3월 22일 개막 ~ 현재`;
                    }
                    periodText.style.visibility = 'visible';
                } else if (winRateChartState.periods[winRateChartState.currentPeriod]) {
                    periodText.textContent = `현재 보는 기간: ${winRateChartState.periods[winRateChartState.currentPeriod].label}`;
                    periodText.style.visibility = 'visible';
                } else {
                    periodText.style.visibility = 'hidden';
                }
            }

            // 진행 인디케이터 업데이트
            updateWinRateProgressIndicator();
        }

        // ROOT INDEX 메인 승률 추이 카드 - 진행 인디케이터 업데이트 (일별통계 섹션과는 별개)
        function updateWinRateProgressIndicator() {
            const container = document.getElementById('progressDotsWinRate');
            if (!container) return;

            if (winRateChartState.isFullView) {
                // 전체 시즌 모드에서는 진행 인디케이터 숨김
                container.innerHTML = '';
                return;
            }

            // 월별 모드에서 진행 인디케이터 표시
            let html = '';
            for (let i = 0; i < winRateChartState.periods.length; i++) {
                const isActive = i === winRateChartState.currentPeriod;
                html += `<div style="
                    width: 6px;             /* 인디케이터 점 크기 6px (기존 8px에서 축소) */
                    height: 6px;
                    border-radius: 50%;     /* 원형 점 */
                    background: ${isActive ? '#28a745' : '#dee2e6'};  /* 활성: 초록색, 비활성: 회색 */
                    transition: all 0.3s ease;  /* 부드러운 색상 전환 효과 */
                "></div>`;
            }
            container.innerHTML = html;
        }

        // 승률 차트 커스텀 레전드 업데이트 (simple-chart.js와 완전히 동일한 스타일)
        function updateWinRateChartLegend() {
            const legendContainer = document.getElementById('winRateChartLegend');
            if (!legendContainer) return;
            
            // 기존 레전드 초기화
            legendContainer.innerHTML = '';
            legendContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
                justify-content: center;
                padding: 0;
                background: transparent;
                border: none;
                margin-bottom: 0;
            `;

            // 종합 순위 기준 팀 순서 사용 (KBO 규정 동률 처리 반영)
            let teams = getRankingSystem().teams;
            const teamColors = window.dailyStats ? window.dailyStats.teamColors : {
                'LG': '#C30452', 'KIA': '#EA0029', '삼성': '#074CA1',
                '두산': '#131230', 'SSG': '#CE0E2D', 'NC': '#315288',
                '롯데': '#002955', '한화': '#FF6600', 'KT': '#000000', '키움': '#820024'
            };
            
            // 글로벌 teamLogos 사용 (이미 올바른 경로로 정의됨)

            // 전체 선택/해제 버튼을 먼저 추가 (앞쪽에 배치)
            const allSelectedCount = teams.filter(team => winRateChartVisibleTeams.has(team)).length;
            const allSelected = allSelectedCount === teams.length;
            
            const toggleAllItem = document.createElement('div');
            toggleAllItem.style.cssText = `
                display: flex;
                align-items: center;
                gap: 5px;
                padding: 5px 12px;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                background: linear-gradient(135deg, ${allSelected ? '#ef4444' : '#3b82f6'} 0%, ${allSelected ? '#dc2626' : '#2563eb'} 100%);
                color: white;
                font-weight: 600;
                font-size: 13px;
                white-space: nowrap;
                flex-shrink: 0;
                min-height: 34px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.15);
                border: none;
            `;

            const toggleText = document.createElement('span');
            const selectedCount = winRateChartVisibleTeams.size;
            const totalCount = teams.length;
            toggleText.textContent = allSelected ? `전체 해제 (${selectedCount}/${totalCount})` : `전체 선택 (${selectedCount}/${totalCount})`;
            
            toggleAllItem.addEventListener('click', () => {
                toggleAllWinRateTeams();
            });

            toggleAllItem.appendChild(toggleText);
            legendContainer.appendChild(toggleAllItem);

            // 팀 레전드 아이템들 추가
            teams.forEach(teamName => {
                const isVisible = winRateChartVisibleTeams.has(teamName);
                
                // 레전드 아이템 생성 (simple-chart.js와 동일)
                const legendItem = document.createElement('div');
                legendItem.setAttribute('data-team', teamName);
                legendItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 5px;
                    padding: 5px 8px;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    background: rgba(255,255,255,0.9);
                    border: 1px solid rgba(0,0,0,0.1);
                    font-weight: 600;
                    font-size: 13px;
                    white-space: nowrap;
                    flex-shrink: 0;
                    min-height: 34px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
                    opacity: ${isVisible ? '1' : '0.4'};
                `;

                // 색상 인디케이터 (원형, simple-chart.js와 동일)
                const colorBox = document.createElement('div');
                colorBox.style.cssText = `
                    width: 12px;
                    height: 12px;
                    background-color: ${teamColors[teamName]};
                    border-radius: 50%;
                    border: 2px solid white;
                    box-shadow: 0 0 0 1px rgba(0,0,0,0.2);
                    flex-shrink: 0;
                    opacity: ${isVisible ? '1' : '0.4'};
                `;

                // 팀 로고 이미지
                const logoImg = document.createElement('img');
                logoImg.src = teamLogos[teamName] || '';
                logoImg.alt = teamName;
                logoImg.style.cssText = `
                    width: 20px;
                    height: 20px;
                    object-fit: contain;
                    border-radius: 3px;
                    flex-shrink: 0;
                    filter: ${isVisible ? 'none' : 'grayscale(100%)'};
                `;
                logoImg.onerror = () => logoImg.style.display = 'none';

                // 팀명 텍스트
                const teamText = document.createElement('span');
                teamText.textContent = teamName;
                teamText.style.cssText = `
                    color: #333;
                    font-weight: 700;
                    font-size: 13px;
                    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
                    opacity: ${isVisible ? '1' : '0.4'};
                `;

                // 클릭 이벤트로 팀 토글
                legendItem.addEventListener('click', () => {
                    toggleWinRateTeam(teamName);
                });

                // DOM에 추가
                legendItem.appendChild(colorBox);
                legendItem.appendChild(logoImg);
                legendItem.appendChild(teamText);
                legendContainer.appendChild(legendItem);
            });
        }

        // 개별 팀 표시/숨김 토글
        function toggleWinRateTeam(team) {
            if (winRateChartInstance) {
                // Chart.js의 데이터셋에서 해당 팀 찾기
                const datasets = winRateChartInstance.data.datasets;
                const teamDatasetIndex = datasets.findIndex(dataset => dataset.label === team);
                
                if (teamDatasetIndex !== -1) {
                    // Chart.js의 메타데이터를 사용하여 개별 데이터셋 숨김/표시
                    const meta = winRateChartInstance.getDatasetMeta(teamDatasetIndex);
                    meta.hidden = !meta.hidden;
                    
                    // 가시성 상태 업데이트
                    if (meta.hidden) {
                        winRateChartVisibleTeams.delete(team);
                    } else {
                        winRateChartVisibleTeams.add(team);
                    }
                    
                    // 차트 업데이트 (다시 그리지 않고 애니메이션으로)
                    winRateChartInstance.update('none');
                    
                    // 레전드만 업데이트
                    updateWinRateChartLegend();
                }
            }
        }

        // 전체 팀 표시/숨김 토글
        function toggleAllWinRateTeams() {
            if (winRateChartInstance) {
                const teams = getRankingSystem().teams;
                const allVisible = teams.every(team => winRateChartVisibleTeams.has(team));
                
                const datasets = winRateChartInstance.data.datasets;
                
                if (allVisible) {
                    // 전체 해제
                    winRateChartVisibleTeams.clear();
                    datasets.forEach((dataset, index) => {
                        const meta = winRateChartInstance.getDatasetMeta(index);
                        meta.hidden = true;
                    });
                } else {
                    // 전체 선택
                    teams.forEach(team => winRateChartVisibleTeams.add(team));
                    datasets.forEach((dataset, index) => {
                        const meta = winRateChartInstance.getDatasetMeta(index);
                        meta.hidden = false;
                    });
                }
                
                // 차트 업데이트 (다시 그리지 않고 애니메이션으로)
                winRateChartInstance.update('none');
                
                // 레전드만 업데이트
                updateWinRateChartLegend();
            }
        }

        // 승률 차트 초기화 (Chart.js 지연 로딩)
        async function initWinRateChart() {
            await window.loadChartJs();
            
            if (typeof Chart !== 'undefined') {
                createWinRateChart();
            }
        }

        // 승률 차트를 일자별 통계 로드 후에 초기화하는 함수 (Chart.js 지연 로딩)
        async function initWinRateChartAfterDaily() {
            // 필요한 데이터가 로드될 때까지 대기
            if (!window.dailyStats || !window.dailyStats.seasonData) {
                setTimeout(initWinRateChartAfterDaily, 500);
                return;
            }
            
            // Chart.js 지연 로딩
            await window.loadChartJs();
            
            if (typeof Chart !== 'undefined') {
                createWinRateChart();
            }
        }
        
        // 강제 승률 차트 초기화 (메인 카드용) - 독립적 데이터 로딩
        async function forceInitWinRateChart() {
            if (typeof Chart === 'undefined') return;
            const ctx = document.getElementById('winRateChart');
            if (!ctx || winRateChartInstance) return;
            
            // 독립적으로 데이터 로드
            let chartData = null;
            try {
                const response = await fetch(`magic-number/data/stats-comprehensive.json?v=${Date.now()}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.history && data.history.length > 0) {
                        chartData = data.history;
                    }
                }
            } catch (error) {
                console.error('메인 승률 차트 데이터 로드 실패:', error);
            }
            
            // 데이터가 없으면 일자별 통계 데이터 사용 (백업)
            if (!chartData && window.dailyStats && window.dailyStats.seasonData && window.dailyStats.seasonData.length > 0) {
                chartData = window.dailyStats.seasonData;
            }
            
            // 여전히 데이터가 없으면 빈 차트 생성
            if (!chartData) {
                winRateChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['데이터 로딩 중...'],
                        datasets: [{
                            label: '데이터 로딩 중',
                            data: [0],
                            borderColor: '#666',
                            backgroundColor: 'rgba(102, 102, 102, 0.1)'
                        }]
                    },
                    plugins: [{
                        id: 'teamLogos',
                        afterDraw: (chart) => {
                            const ctx = chart.ctx;
                            if (!window.teamLogoImages || Object.keys(window.teamLogoImages).length === 0) {
                                return;
                            }
                            
                            chart.data.datasets.forEach((dataset, index) => {
                                const meta = chart.getDatasetMeta(index);
                                if (meta.data && meta.data.length > 0 && !meta.hidden) {
                                    const lastPoint = meta.data[meta.data.length - 1];
                                    const teamName = dataset.label;
                                    const logoImg = window.teamLogoImages[teamName];
                                    
                                    if (logoImg && lastPoint && typeof lastPoint.x === 'number' && typeof lastPoint.y === 'number') {
                                        ctx.save();
                                        ctx.globalCompositeOperation = 'source-over';
                                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                                        ctx.shadowBlur = 3;
                                        ctx.shadowOffsetX = 2;
                                        ctx.shadowOffsetY = 2;
                                        const size = 32;
                                        ctx.drawImage(logoImg, lastPoint.x - size/2, lastPoint.y - size/2, size, size);
                                        ctx.restore();
                                    }
                                }
                            });
                        }
                    }],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
                return;
            }
            
            // 실제 데이터로 차트 생성
            createWinRateChart();
        }

        // 중복 제거: initializeMainCharts에서 이미 처리됨
    </script>

    <!-- 전반기/후반기 성적 비교 스크립트 -->
    <script>
        // 전반기/후반기 성적 데이터 로딩 및 업데이트
        async function updateHalfSeasonStats() {
            try {
                console.log('📊 전반기/후반기 성적 업데이트 시작...');
                
                // stats-comprehensive.json을 메인으로 사용 (streakAnalysis 포함)
                let kboData = null;
                let serviceData = null;
                
                try {
                    // stats-comprehensive.json 로드 (streakAnalysis 포함)
                    const enhancedResponse = await fetch(`magic-number/data/stats-comprehensive.json?v=${Date.now()}`);
                    if (enhancedResponse.ok) {
                        kboData = await enhancedResponse.json();
                        console.log('✅ stats-comprehensive.json 로드 성공');
                    }
                } catch (e) {
                    console.error('❌ stats-comprehensive.json 로드 실패:', e);
                }
                
                // api-data.json 제거됨 - stats-comprehensive.json에 통합
                console.log('✅ api-data.json → stats-comprehensive.json 통합 완료');
                
                if (!kboData || !kboData.standings) {
                    console.warn('⚠️ KBO 데이터가 없어서 전반기/후반기 성적을 표시할 수 없습니다.');
                    return;
                }

                console.log('✅ 데이터 로드 완료, 팀 수:', kboData.standings.length);
                window.kboData = kboData; // 전역 변수로 저장
                
                const standings = kboData.standings;
                const halfSeasonData = await calculateHalfSeasonStats(standings);
                console.log('✅ 전반기/후반기 데이터 계산 완료:', halfSeasonData.length, '개 팀');
                
                renderHalfSeasonTable(halfSeasonData);
                console.log('✅ 전반기/후반기 테이블 렌더링 완료');
                
            } catch (error) {
                console.error('❌ 전반기/후반기 성적 업데이트 실패:', error);
                console.error('오류 상세:', error.stack);
                
                // 실패 시 기본 데이터로 시도
                try {
                    console.log('🔄 기본 데이터로 재시도...');
                    await loadFallbackHalfSeasonData();
                } catch (fallbackError) {
                    console.error('❌ 기본 데이터 로드도 실패:', fallbackError);
                    // 최종 실패 시 빈 테이블 표시
                    const tbody = document.getElementById('half-season-tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="24" style="text-align: center; padding: 20px;">데이터를 불러오는 중 오류가 발생했습니다. 페이지를 새로고침해주세요.</td></tr>';
                    }
                }
            }
        }

        // 2025-season-data-clean.txt 파일에서 실제 7월 12일 기준 전반기/후반기 성적 계산
        async function calculateActualHalfSeasonRecord(teamName) {
            try {
                const response = await fetch(`magic-number/data/2025-season-data-clean.txt?v=${Date.now()}`);
                if (!response.ok) {
                    console.warn(`⚠️ 시즌 데이터 파일을 불러올 수 없습니다: ${response.status}`);
                    return null;
                }
                const seasonData = await response.text();
                const lines = seasonData.split('\n');
                
                // 7월 12일을 기준으로 전반기/후반기 분할
                const allStarDate = new Date(2025, 6, 12); // 7월 12일
                
                let firstHalfStats = { 
                    wins: 0, losses: 0, draws: 0, 
                    runsScored: 0, runsAllowed: 0,
                    oneRunGames: { wins: 0, total: 0 },
                    threeRunGames: { wins: 0, total: 0 },
                    maxWinStreak: 0, maxLoseStreak: 0
                };
                let secondHalfStats = { 
                    wins: 0, losses: 0, draws: 0,
                    runsScored: 0, runsAllowed: 0,
                    oneRunGames: { wins: 0, total: 0 },
                    threeRunGames: { wins: 0, total: 0 },
                    maxWinStreak: 0, maxLoseStreak: 0
                };
                
                // 전반기/후반기 각각의 연속 기록 추적
                let firstHalfCurrentStreak = { type: null, count: 0 };
                let secondHalfCurrentStreak = { type: null, count: 0 };
                
                let currentDate = null;
                let gameCount = 0;
                let lastPeriod = 'first'; // 이전 기간 추적
                
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    
                    // 날짜 라인 체크 (YYYY-MM-DD 형식 또는 YYYY-MM-DD (요일) 형식)
                    if (/^\d{4}-\d{2}-\d{2}(\s*\([월화수목금토일]\))?$/.test(trimmedLine)) {
                        const dateOnly = trimmedLine.replace(/\s*\([월화수목금토일]\)/, ''); // 요일 정보 제거
                        currentDate = new Date(dateOnly);
                        continue;
                    }
                    
                    // 경기 결과 라인 체크
                    if (trimmedLine.includes(':') && currentDate) {
                        const result = parseGameResultWithScore(trimmedLine, teamName);
                        if (result) {
                            gameCount++;
                            const isFirstHalf = currentDate <= allStarDate;
                            const stats = isFirstHalf ? firstHalfStats : secondHalfStats;
                            const currentStreak = isFirstHalf ? firstHalfCurrentStreak : secondHalfCurrentStreak;
                            
                            // 전반기에서 후반기로 넘어갈 때 연속 기록 리셋
                            const currentPeriod = isFirstHalf ? 'first' : 'second';
                            if (currentPeriod !== lastPeriod) {
                                secondHalfCurrentStreak.type = null;
                                secondHalfCurrentStreak.count = 0;
                                lastPeriod = currentPeriod;
                            }
                            
                            // 기본 승/패/무 기록
                            if (result.result === 'win') {
                                stats.wins++;
                                // 연승 계산 (무승부는 무시하고 연패→연승 전환 시에만 리셋)
                                if (currentStreak.type === 'win') {
                                    // 연승 지속
                                    currentStreak.count++;
                                } else if (currentStreak.type === 'loss') {
                                    // 연패에서 연승으로 전환
                                    currentStreak.type = 'win';
                                    currentStreak.count = 1;
                                } else {
                                    // 처음 또는 무승부 후 연승 시작
                                    currentStreak.type = 'win';
                                    currentStreak.count = 1;
                                }
                                stats.maxWinStreak = Math.max(stats.maxWinStreak, currentStreak.count);
                                
                            } else if (result.result === 'loss') {
                                stats.losses++;
                                // 연패 계산 (무승부는 무시하고 연승→연패 전환 시에만 리셋)
                                if (currentStreak.type === 'loss') {
                                    // 연패 지속
                                    currentStreak.count++;
                                } else if (currentStreak.type === 'win') {
                                    // 연승에서 연패로 전환
                                    currentStreak.type = 'loss';
                                    currentStreak.count = 1;
                                } else {
                                    // 처음 또는 무승부 후 연패 시작
                                    currentStreak.type = 'loss';
                                    currentStreak.count = 1;
                                }
                                stats.maxLoseStreak = Math.max(stats.maxLoseStreak, currentStreak.count);
                                
                            } else if (result.result === 'draw') {
                                stats.draws++;
                                // 무승부는 연승/연패 기록에 전혀 영향 없음 - type과 count 모두 유지
                            }
                            
                            // 득점/실점 기록
                            stats.runsScored += result.runsScored;
                            stats.runsAllowed += result.runsAllowed;
                            
                            // 1점차/3점차 게임 기록
                            const scoreDiff = Math.abs(result.runsScored - result.runsAllowed);
                            if (scoreDiff === 1 && result.result !== 'draw') {
                                stats.oneRunGames.total++;
                                if (result.result === 'win') stats.oneRunGames.wins++;
                            }
                            if (scoreDiff <= 3 && result.result !== 'draw') {
                                stats.threeRunGames.total++;
                                if (result.result === 'win') stats.threeRunGames.wins++;
                            }
                        }
                    }
                }
                
                console.log(`✅ ${teamName} 전반기/후반기 실제 데이터 계산 완료:`, {
                    전반기: `${firstHalfStats.wins}승 ${firstHalfStats.losses}패 ${firstHalfStats.draws}무 (최대연승: ${firstHalfStats.maxWinStreak}, 최대연패: ${firstHalfStats.maxLoseStreak})`,
                    후반기: `${secondHalfStats.wins}승 ${secondHalfStats.losses}패 ${secondHalfStats.draws}무 (최대연승: ${secondHalfStats.maxWinStreak}, 최대연패: ${secondHalfStats.maxLoseStreak})`
                });
                
                return {
                    firstHalf: firstHalfStats,
                    secondHalf: secondHalfStats
                };
                
            } catch (error) {
                console.error(`❌ ${teamName} 성적 계산 오류:`, error);
                return null;
            }
        }
        
        // 경기 결과 파싱 함수 (점수 포함)
        function parseGameResultWithScore(gameResultLine, teamName) {
            // 새로운 형식: "시간 상태 구장 홈팀 어웨이팀 점수 방송사 구분"
            const newFormatParts = gameResultLine.trim().split(/\s+/);

            if (newFormatParts.length >= 8) {
                const [time, state, stadium, homeTeam, awayTeam, scoreOrStatus, broadcast, ...categoryParts] = newFormatParts;
                const category = categoryParts.join(' ');

                // 완료된 페넌트레이스 경기만 처리
                if (state === '종료' && category.includes('페넌트레이스')) {
                    // 점수 파싱 (away:home 형식)
                    const scoreMatch = scoreOrStatus.match(/^(\d+):(\d+)$/);
                    if (scoreMatch) {
                        const [, awayScore, homeScore] = scoreMatch;
                        const awayScoreInt = parseInt(awayScore);
                        const homeScoreInt = parseInt(homeScore);

                        // 해당 팀의 결과 판정
                        if (homeTeam === teamName) {
                            // 홈팀인 경우
                            let result;
                            if (homeScoreInt > awayScoreInt) result = 'win';
                            else if (homeScoreInt < awayScoreInt) result = 'loss';
                            else result = 'draw';

                            return {
                                result: result,
                                runsScored: homeScoreInt,
                                runsAllowed: awayScoreInt,
                                isHome: true
                            };
                        } else if (awayTeam === teamName) {
                            // 원정팀인 경우
                            let result;
                            if (awayScoreInt > homeScoreInt) result = 'win';
                            else if (awayScoreInt < homeScoreInt) result = 'loss';
                            else result = 'draw';

                            return {
                                result: result,
                                runsScored: awayScoreInt,
                                runsAllowed: homeScoreInt,
                                isHome: false
                            };
                        }
                    }
                }

                // 취소된 경기는 처리하지 않음 (전반기/후반기 성적에 포함하지 않음)
                return null;

            } else {
                // 기존 형식 지원: "롯데 2:12 LG(H)" - 첫번째 팀이 원정팀, (H) 마크가 있는 팀이 홈팀
                const oldFormatMatch = gameResultLine.match(/^(\S+)\s+(\d+):(\d+)\s+(\S+)\(([HA])\)$/);
                if (!oldFormatMatch) return null;

                const [, firstTeam, firstScore, secondScore, secondTeam, homeMarker] = oldFormatMatch;
                const score1 = parseInt(firstScore);
                const score2 = parseInt(secondScore);

                let homeTeam, awayTeam, homeScore, awayScore;

                if (homeMarker === 'H') {
                    // (H) 마크가 있는 팀이 홈팀
                    homeTeam = secondTeam;
                    awayTeam = firstTeam;
                    homeScore = score2;
                    awayScore = score1;
                } else {
                    // (A) 마크가 있는 팀이 원정팀
                    homeTeam = firstTeam;
                    awayTeam = secondTeam;
                    homeScore = score1;
                    awayScore = score2;
                }

                // 해당 팀의 결과 판정
                if (homeTeam === teamName) {
                    // 홈팀인 경우
                    let result;
                    if (homeScore > awayScore) result = 'win';
                    else if (homeScore < awayScore) result = 'loss';
                    else result = 'draw';

                    return {
                        result: result,
                        runsScored: homeScore,
                        runsAllowed: awayScore,
                        isHome: true
                    };
                } else if (awayTeam === teamName) {
                    // 원정팀인 경우
                    let result;
                    if (awayScore > homeScore) result = 'win';
                    else if (awayScore < homeScore) result = 'loss';
                    else result = 'draw';

                    return {
                        result: result,
                        runsScored: awayScore,
                        runsAllowed: homeScore,
                        isHome: false
                    };
                }
            }

            return null;
        }
        
        // 기존 parseGameResult 함수 (하위 호환성을 위해 유지)
        function parseGameResult(gameResultLine, teamName) {
            const result = parseGameResultWithScore(gameResultLine, teamName);
            return result ? result.result : null;
        }

        // 올스타전 기준(7월 12일) 전반기/후반기 성적 계산
        async function calculateHalfSeasonStats(standings) {
            const halfSeasonStats = [];
            
            // KBO 규정에 따른 순위 순서로 정렬
            const sortedStandings = [...standings].sort((a, b) => {
                // dashboardData가 로드되지 않은 경우 기본 정렬 사용
                if (!window.dashboardData || !window.dashboardData.standings) {
                    return (a.rank || 0) - (b.rank || 0);
                }
                const rankingSystem = getRankingSystem();
                const aRank = rankingSystem.teamRanks[a.team_name || a.team] || 999;
                const bRank = rankingSystem.teamRanks[b.team_name || b.team] || 999;
                return aRank - bRank;
            });
            
            // 각 팀별로 순차적으로 실제 데이터 계산
            for (const [index, team] of sortedStandings.entries()) {
                try {
                    // 실제 시즌 데이터에서 전반기/후반기 성적 계산
                    // stats-comprehensive.json은 team_name, api-data.json은 team 사용
                    const teamName = team.team_name || team.team;
                    let actualRecord = await calculateActualHalfSeasonRecord(teamName);
                    
                    if (!actualRecord) {
                        console.warn(`⚠️ ${teamName}: 실제 데이터 계산 실패 - 기본값 사용`);
                        // 기본값 사용 (전체 시즌 데이터를 비율로 분할)
                        const halfWins = Math.floor(team.wins * 0.5);
                        const halfLosses = Math.floor(team.losses * 0.5);
                        const halfDraws = Math.floor(team.draws * 0.5);
                        
                        actualRecord = {
                            firstHalf: { 
                                wins: halfWins, 
                                losses: halfLosses, 
                                draws: halfDraws,
                                runsScored: 0,
                                runsAllowed: 0,
                                oneRunGames: { wins: 0, total: 0 },
                                threeRunGames: { wins: 0, total: 0 },
                                maxWinStreak: 0,
                                maxLoseStreak: 0
                            },
                            secondHalf: { 
                                wins: team.wins - halfWins, 
                                losses: team.losses - halfLosses, 
                                draws: team.draws - halfDraws,
                                runsScored: 0,
                                runsAllowed: 0,
                                oneRunGames: { wins: 0, total: 0 },
                                threeRunGames: { wins: 0, total: 0 },
                                maxWinStreak: 0,
                                maxLoseStreak: 0
                            }
                        };
                    }
                    
                    const firstHalfWins = actualRecord.firstHalf.wins;
                    const firstHalfLosses = actualRecord.firstHalf.losses;
                    const firstHalfDraws = actualRecord.firstHalf.draws;
                    const firstHalfGames = firstHalfWins + firstHalfLosses + firstHalfDraws;
                    const firstHalfWinRate = (firstHalfWins + firstHalfLosses) > 0 ? 
                        firstHalfWins / (firstHalfWins + firstHalfLosses) : 0;
                    
                    const secondHalfWins = actualRecord.secondHalf.wins;
                    const secondHalfLosses = actualRecord.secondHalf.losses;
                    const secondHalfDraws = actualRecord.secondHalf.draws;
                    const secondHalfGames = secondHalfWins + secondHalfLosses + secondHalfDraws;
                    const secondHalfWinRate = (secondHalfWins + secondHalfLosses) > 0 ? 
                        secondHalfWins / (secondHalfWins + secondHalfLosses) : 0;
                    
                
                    // stats-comprehensive.json 또는 api-data.json에서 실제 연속 기록 데이터 가져오기
                    const streakData = window.kboData?.streakAnalysis?.find(s => s.team_name === teamName);
                    const actualMaxWinStreak = streakData?.max_win_streak || 5; // 기본값 5
                    const actualMaxLoseStreak = streakData?.max_lose_streak || 5; // 기본값 5
                    
                    // 롯데의 경우 특별히 12연패 확인
                    if (teamName === '롯데') {
                        console.log(`✅ 롯데 연속기록 확인 - 최대연승: ${actualMaxWinStreak}, 최대연패: ${actualMaxLoseStreak}`);
                    }
                    
                    
                    // 실제 데이터에서 추가 통계 계산
                    const firstHalfRunsPerGame = firstHalfGames > 0 ? 
                        actualRecord.firstHalf.runsScored / firstHalfGames : 4.5;
                    const firstHalfRunsAllowedPerGame = firstHalfGames > 0 ?
                        actualRecord.firstHalf.runsAllowed / firstHalfGames : 4.5;
                    const firstHalfOneRunWinRate = actualRecord.firstHalf.oneRunGames.total > 0 ?
                        actualRecord.firstHalf.oneRunGames.wins / actualRecord.firstHalf.oneRunGames.total : 0.5;
                    const firstHalfThreeRunWinRate = actualRecord.firstHalf.threeRunGames.total > 0 ?
                        actualRecord.firstHalf.threeRunGames.wins / actualRecord.firstHalf.threeRunGames.total : 0.65;
                    
                    const secondHalfRunsPerGame = secondHalfGames > 0 ?
                        actualRecord.secondHalf.runsScored / secondHalfGames : 4.5;
                    const secondHalfRunsAllowedPerGame = secondHalfGames > 0 ?
                        actualRecord.secondHalf.runsAllowed / secondHalfGames : 4.5;
                    const secondHalfOneRunWinRate = actualRecord.secondHalf.oneRunGames.total > 0 ?
                        actualRecord.secondHalf.oneRunGames.wins / actualRecord.secondHalf.oneRunGames.total : 0.5;
                    const secondHalfThreeRunWinRate = actualRecord.secondHalf.threeRunGames.total > 0 ?
                        actualRecord.secondHalf.threeRunGames.wins / actualRecord.secondHalf.threeRunGames.total : 0.65;
                    
                    const teamStats = {
                        team: teamName,
                        rank: team.displayRank || team.rank || (index + 1),  // 실제 종합 순위 사용
                        // 현재 시즌 전체 데이터
                        currentSeason: {
                            wins: team.wins,
                            losses: team.losses,
                            draws: team.draws,
                            winRate: team.winRate || parseFloat(team.win_rate) || 0
                        },
                        // 전반기 데이터
                        firstHalf: {
                            games: firstHalfGames,
                            wins: firstHalfWins,
                            losses: firstHalfLosses,
                            draws: firstHalfDraws,
                            winRate: firstHalfWinRate,
                            runsPerGame: firstHalfRunsPerGame,
                            runsAllowedPerGame: firstHalfRunsAllowedPerGame,
                            oneRunWinRate: firstHalfOneRunWinRate,
                            threeRunWinRate: firstHalfThreeRunWinRate,
                            maxWinStreak: actualRecord.firstHalf.maxWinStreak || 0,
                            maxLoseStreak: actualRecord.firstHalf.maxLoseStreak || 0
                        },
                        // 후반기 데이터
                        secondHalf: {
                            games: secondHalfGames,
                            wins: secondHalfWins,
                            losses: secondHalfLosses,
                            draws: secondHalfDraws,
                            winRate: secondHalfWinRate,
                            runsPerGame: secondHalfRunsPerGame,
                            runsAllowedPerGame: secondHalfRunsAllowedPerGame,
                            oneRunWinRate: secondHalfOneRunWinRate,
                            threeRunWinRate: secondHalfThreeRunWinRate,
                            maxWinStreak: actualRecord.secondHalf.maxWinStreak || 0,
                            maxLoseStreak: actualRecord.secondHalf.maxLoseStreak || 0
                        }
                    };
                    
                    halfSeasonStats.push(teamStats);
                    
                } catch (error) {
                    console.error(`${team.team_name} 계산 오류:`, error);
                }
            }
            
            // 전반기 순위 계산 (승률 기준 정렬)
            const firstHalfRanking = [...halfSeasonStats]
                .sort((a, b) => {
                    const aWinRate = Math.round(a.firstHalf.winRate * 10000) / 10000; // 4자리 정확도
                    const bWinRate = Math.round(b.firstHalf.winRate * 10000) / 10000;
                    if (aWinRate === bWinRate) {
                        return (b.firstHalf.wins - b.firstHalf.losses) - (a.firstHalf.wins - a.firstHalf.losses);
                    }
                    return bWinRate - aWinRate;
                })
                .map((team, index) => ({ team: team.team, rank: index + 1 }));
            
            
            // 후반기 순위 계산 (후반기 경기가 있는 팀만)
            const secondHalfRanking = [...halfSeasonStats]
                .filter(team => team.secondHalf.games > 0)
                .sort((a, b) => {
                    const aWinRate = Math.round(a.secondHalf.winRate * 10000) / 10000; // 4자리 정확도
                    const bWinRate = Math.round(b.secondHalf.winRate * 10000) / 10000;
                    if (aWinRate === bWinRate) {
                        return (b.secondHalf.wins - b.secondHalf.losses) - (a.secondHalf.wins - a.secondHalf.losses);
                    }
                    return bWinRate - aWinRate;
                })
                .map((team, index) => ({ team: team.team, rank: index + 1 }));
            

            // 순위 정보 추가 및 성적 변화 계산
            halfSeasonStats.forEach(team => {
                team.firstHalf.rank = firstHalfRanking.find(r => r.team === team.team)?.rank || 0;
                const secondHalfRank = secondHalfRanking.find(r => r.team === team.team);
                team.secondHalf.rank = secondHalfRank ? secondHalfRank.rank : '-';
                
                // 성적 변화 계산
                const winRateChange = team.secondHalf.winRate - team.firstHalf.winRate;
                const rankChange = team.firstHalf.rank - (typeof team.secondHalf.rank === 'number' ? team.secondHalf.rank : team.firstHalf.rank);
                
                team.performance = {
                    winRateChange: winRateChange,
                    rankChange: rankChange,
                    trend: winRateChange > 0.05 ? '상승' : 
                           winRateChange < -0.05 ? '하락' : '유지'
                };
            });

            return halfSeasonStats;
        }

        // 전반기/후반기 테이블 정렬 함수
        let halfSeasonSortDirection = {};
        function sortHalfSeasonTable(column) {
            const tbody = document.getElementById('half-season-tbody');
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            
            // 현재 정렬 방향 확인/변경
            if (!halfSeasonSortDirection[column]) {
                halfSeasonSortDirection[column] = 'desc';
            } else {
                halfSeasonSortDirection[column] = halfSeasonSortDirection[column] === 'desc' ? 'asc' : 'desc';
            }
            
            const isDescending = halfSeasonSortDirection[column] === 'desc';
            
            rows.sort((a, b) => {
                const rowA = a.getAttribute('data-team');
                const rowB = b.getAttribute('data-team');
                
                // 현재 데이터에서 값 찾기
                const teamA = window.halfSeasonData?.find(team => team.team === rowA);
                const teamB = window.halfSeasonData?.find(team => team.team === rowB);
                
                if (!teamA || !teamB) return 0;
                
                let valueA, valueB;
                
                // 중첩된 속성 접근
                const columnParts = column.split('.');
                if (columnParts.length === 2) {
                    valueA = teamA[columnParts[0]][columnParts[1]];
                    valueB = teamB[columnParts[0]][columnParts[1]];
                } else {
                    valueA = teamA[column];
                    valueB = teamB[column];
                }
                
                // 순위는 숫자가 작을수록 좋음 (특별 처리)
                if (column.includes('rank')) {
                    // '-'는 가장 낮은 순위로 처리
                    if (valueA === '-') valueA = 999;
                    if (valueB === '-') valueB = 999;
                    valueA = parseInt(valueA) || 999;
                    valueB = parseInt(valueB) || 999;
                    return isDescending ? valueB - valueA : valueA - valueB;
                }
                
                // 숫자 비교
                if (!isNaN(valueA) && !isNaN(valueB)) {
                    return isDescending ? valueB - valueA : valueA - valueB;
                }
                
                // 문자열 비교
                return isDescending ? 
                    valueB.toString().localeCompare(valueA.toString()) : 
                    valueA.toString().localeCompare(valueB.toString());
            });
            
            // 정렬된 행들을 다시 tbody에 추가하면서 항상 실제 순위 유지
            rows.forEach((row, index) => {
                tbody.appendChild(row);
                
                // 모든 경우에 실제 팀 순위를 유지
                const rankCell = row.cells[0];
                const teamName = row.getAttribute('data-team');
                
                if (rankCell && window.kboData && window.kboData.standings) {
                    // kboData에서 해당 팀의 실제 순위 찾기
                    const teamData = window.kboData.standings.find(t => 
                        (t.team_name || t.team) === teamName
                    );
                    
                    if (teamData) {
                        const actualRank = teamData.displayRank || teamData.rank || (index + 1);
                        rankCell.innerHTML = `<strong>${actualRank}</strong>`;
                    } else {
                        // 팀을 찾지 못한 경우 기존 순위 유지
                        if (!rankCell.innerHTML.includes('<strong>')) {
                            rankCell.innerHTML = `<strong>${index + 1}</strong>`;
                        }
                    }
                }
            });
        }

        // 전반기/후반기 성적 테이블 렌더링
        function renderHalfSeasonTable(halfSeasonData) {
            const tbody = document.getElementById('half-season-tbody');
            if (!tbody) return;

            // 전역 변수에 데이터 저장 (정렬 함수에서 사용)
            window.halfSeasonData = halfSeasonData;

            tbody.innerHTML = '';

            // 팀 색상 및 로고 정의
            const teamColors = {
                'KIA': '#EA1E22',
                '삼성': '#074CA1', 
                'LG': '#C30452',
                '두산': '#131F5A',
                'KT': '#000000',
                'SSG': '#CE2B3C',
                'NC': '#315288',
                '롯데': '#041F7B',
                '한화': '#FF7A00',
                '키움': '#820024'
            };

            const teamLogos = {
                'KIA': '<img src="magic-number/images/teams/kia.png" alt="KIA" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                '삼성': '<img src="magic-number/images/teams/samsung.png" alt="삼성" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                'LG': '<img src="magic-number/images/teams/lg.png" alt="LG" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                '두산': '<img src="magic-number/images/teams/doosan.png" alt="두산" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                'KT': '<img src="magic-number/images/teams/kt.png" alt="KT" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                'SSG': '<img src="magic-number/images/teams/ssg.png" alt="SSG" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                'NC': '<img src="magic-number/images/teams/nc.png" alt="NC" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                '롯데': '<img src="magic-number/images/teams/lotte.png" alt="롯데" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                '한화': '<img src="magic-number/images/teams/hanwha.png" alt="한화" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">',
                '키움': '<img src="magic-number/images/teams/kiwoom.png" alt="키움" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;">'
            };

            halfSeasonData.forEach(team => {
                const teamColor = teamColors[team.team] || '#333';
                const teamLogo = teamLogos[team.team] || '';
                
                // 성적 변화에 따른 색상과 아이콘
                let trendColor = '#666';
                let trendIcon = '➡️';
                if (team.performance.trend === '상승') {
                    trendColor = '#27ae60';
                    trendIcon = '📈';
                } else if (team.performance.trend === '하락') {
                    trendColor = '#e74c3c';
                    trendIcon = '📉';
                }

                const row = document.createElement('tr');
                row.setAttribute('data-team', team.team);
                
                // KBO 규정 동률 처리가 적용된 순위 사용
                const teamRanks = getRankingSystem().teamRanks;
                const actualRank = teamRanks[team.team] || team.rank;
                
                row.innerHTML = `
                    <td class="half-season-data rank">${actualRank}</td>
                    <td class="half-season-data team">
                        <span style="color: ${teamColor}; font-weight: 600;">
                            ${teamLogo ? teamLogo.replace('20px', '16px') : ''}
                            ${team.team}
                        </span>
                    </td>
                    <!-- 현재 시즌 -->
                    <td class="half-season-data current">
                        ${team.currentSeason.wins}-${team.currentSeason.losses}-${team.currentSeason.draws}
                    </td>
                    <td class="half-season-data current winrate">
                        ${team.currentSeason.winRate.toFixed(3)}
                    </td>
                    <!-- 전반기 -->
                    <td class="half-season-data first-half">${team.firstHalf.games}</td>
                    <td class="half-season-data first-half">
                        ${team.firstHalf.wins}-${team.firstHalf.losses}-${team.firstHalf.draws}
                    </td>
                    <td class="half-season-data first-half winrate">
                        ${team.firstHalf.winRate.toFixed(3)}
                    </td>
                    <td class="half-season-data first-half rank" style="color: ${teamColor};">
                        ${team.firstHalf.rank}
                    </td>
                    <td class="half-season-data first-half">
                        ${team.firstHalf.runsPerGame.toFixed(1)}
                    </td>
                    <td class="half-season-data first-half">
                        ${team.firstHalf.runsAllowedPerGame.toFixed(1)}
                    </td>
                    <td class="half-season-data first-half">
                        ${team.firstHalf.oneRunWinRate.toFixed(3)}
                    </td>
                    <td class="half-season-data first-half">
                        ${team.firstHalf.threeRunWinRate.toFixed(3)}
                    </td>
                    <td class="half-season-data first-half win-streak">
                        ${team.firstHalf.maxWinStreak}
                    </td>
                    <td class="half-season-data first-half lose-streak last">
                        ${team.firstHalf.maxLoseStreak}
                    </td>
                    <!-- 후반기 -->
                    <td class="half-season-data second-half">${team.secondHalf.games || '-'}</td>
                    <td class="half-season-data second-half">
                        ${team.secondHalf.games > 0 ? 
                          `${team.secondHalf.wins}-${team.secondHalf.losses}-${team.secondHalf.draws}` : 
                          '-'}
                    </td>
                    <td class="half-season-data second-half winrate">
                        ${team.secondHalf.games > 0 ? team.secondHalf.winRate.toFixed(3) : '-'}
                    </td>
                    <td class="half-season-data second-half rank" style="color: ${teamColor};">
                        ${team.secondHalf.rank === '-' ? '-' : team.secondHalf.rank}
                    </td>
                    <td class="half-season-data second-half">
                        ${team.secondHalf.games > 0 ? team.secondHalf.runsPerGame.toFixed(1) : '-'}
                    </td>
                    <td class="half-season-data second-half">
                        ${team.secondHalf.games > 0 ? team.secondHalf.runsAllowedPerGame.toFixed(1) : '-'}
                    </td>
                    <td class="half-season-data second-half">
                        ${team.secondHalf.games > 0 ? team.secondHalf.oneRunWinRate.toFixed(3) : '-'}
                    </td>
                    <td class="half-season-data second-half">
                        ${team.secondHalf.games > 0 ? team.secondHalf.threeRunWinRate.toFixed(3) : '-'}
                    </td>
                    <td class="half-season-data second-half win-streak">
                        ${team.secondHalf.games > 0 ? team.secondHalf.maxWinStreak : '-'}
                    </td>
                    <td class="half-season-data second-half lose-streak">
                        ${team.secondHalf.games > 0 ? team.secondHalf.maxLoseStreak : '-'}
                    </td>
                    <!-- 성적 변화 -->
                    <td class="half-season-data performance" style="color: ${trendColor};">
                        <span style="display: inline-block; line-height: 1;">${trendIcon}</span>
                        <span style="display: inline-block; margin: 0 1px; line-height: 1;">${team.performance.trend}</span>
                        <span style="display: inline-block; font-size: 0.8rem; line-height: 1;">${team.secondHalf.games > 0 ? 
                          `${team.performance.winRateChange >= 0 ? '+' : ''}${team.performance.winRateChange.toFixed(3)}` :
                          ''}</span>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        // 페이지 로드 시 전반기/후반기 성적 업데이트
        window.addEventListener('load', function() {
            updateHalfSeasonStats();
        });

        // ========== 성능 최적화된 월별 탭 시스템 ==========
        
        // 디바운스 함수 - 스크롤 이벤트 최적화
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }


        // 최적화된 전체 게임 월별 탭 초기화
        function initAllGamesMonthTabs() {
            const container = document.querySelector('#teamDetailedRecordsContent .all-games-month-tabs-container');
            
            if (!container) {
                return;
            }

            // 기존 이벤트 리스너 제거 (중복 방지)
            const existingListener = container.getAttribute('data-listener-added');
            if (existingListener) return;

            // 이벤트 위임 사용 - 하나의 리스너로 모든 탭 처리
            container.addEventListener('click', (e) => {
                const tab = e.target.closest('.all-games-month-tab');
                if (!tab) {
                    return;
                }

                handleMonthTabClick(tab, '.all-games-month-tab', 'all-games-month', '#teamDetailedRecordsContent .table-container');
            });

            // 리스너 추가 표시
            container.setAttribute('data-listener-added', 'true');
        }

        // 최적화된 팀별 월별 탭 초기화
        function initTeamMonthTabs() {
            const container = document.querySelector('.team-month-tabs-container');
            
            if (!container) {
                return;
            }

            // 기존 이벤트 리스너 제거 (중복 방지)
            const existingListener = container.getAttribute('data-listener-added');
            if (existingListener) return;

            // 이벤트 위임 사용 - 하나의 리스너로 모든 탭 처리
            container.addEventListener('click', (e) => {
                const tab = e.target.closest('.team-month-tab');
                if (!tab) return;

                handleMonthTabClick(tab, '.team-month-tab', 'team-month', '#team-detailed-table-wrapper');
            });

            // 리스너 추가 표시
            container.setAttribute('data-listener-added', 'true');
        }

        // 통합된 월별 탭 클릭 핸들러
        function handleMonthTabClick(clickedTab, tabSelector, idPrefix, containerSelector) {
            const allTabs = document.querySelectorAll(tabSelector);
            const container = document.querySelector(containerSelector);
            
            if (!container) {
                // 대안으로 모든 테이블 컨테이너 시도
                const altContainer = document.querySelector('.table-container');
                if (altContainer) {
                    performOptimizedScroll(clickedTab, idPrefix, altContainer);
                }
                return;
            }

            // 배치로 스타일 업데이트 (리플로우 최소화)
            requestAnimationFrame(() => {
                // 모든 탭 비활성화
                allTabs.forEach(tab => {
                    tab.classList.remove('active');
                    Object.assign(tab.style, {
                        background: 'white',
                        borderColor: '#dee2e6',
                        color: '#666'
                    });
                });

                // 클릭된 탭 활성화
                clickedTab.classList.add('active');
                Object.assign(clickedTab.style, {
                    background: '#495057',
                    borderColor: '#495057',
                    color: 'white'
                });
                

                // 디바운스된 스크롤 실행
                performOptimizedScroll(clickedTab, idPrefix, container);
            });
        }

        // 최적화된 스크롤 함수
        function performOptimizedScroll(tab, idPrefix, container) {
            const monthNum = tab.getAttribute('data-month');
            
            // "현재" 탭 클릭시 첫 로드시와 동일한 스크롤 위치로 이동
            if (monthNum === 'current') {
                if (container && container.closest('#teamDetailedRecordsContent')) {
                    requestAnimationFrame(() => {
                        const teamContent = document.getElementById('teamDetailedRecordsContent');
                        if (teamContent) {
                            // 전체 탭인지 개별 팀 탭인지 구분
                            const isTeamTab = currentSelectedTeam !== '전체';
                            if (isTeamTab) {
                                // 팀 탭인 경우 팀별 스크롤 함수 사용
                                scrollTeamGamesToRecentGame(teamContent);
                            } else {
                                // 전체 탭인 경우 전체 게임 스크롤 함수 사용
                                scrollAllGamesToRecentDate(teamContent, false);
                            }
                        }
                    });
                }
                return;
            }
            
            const targetElement = document.getElementById(`${idPrefix}-${monthNum}-start`);
            
            if (!targetElement || !container) return;

            // 스크롤 계산을 requestAnimationFrame 내에서 실행
            requestAnimationFrame(() => {
                const stickyHeader = container.querySelector('thead tr');
                const stickyHeaderHeight = stickyHeader?.offsetHeight || 50;
                
                const containerRect = container.getBoundingClientRect();
                const targetRect = targetElement.getBoundingClientRect();
                const scrollOffset = targetRect.top - containerRect.top + container.scrollTop;
                
                // 부드러운 스크롤 - 여백을 줄여서 더 위쪽으로
                container.scrollTo({
                    top: Math.max(0, scrollOffset - stickyHeaderHeight + 5),
                    behavior: 'smooth'
                });
            });
        }


        // 최적화된 자동 스크롤 함수 - 기존 setTimeout 코드를 대체
        function autoScrollToRecentGames(currentSelectedTeam) {
            requestAnimationFrame(() => {
                const teamContent = document.querySelector('#teamDetailedRecordsContent');
                if (!teamContent) return;

                if (currentSelectedTeam === '전체') {
                    scrollAllGamesToRecentDate(teamContent, false); // 전체 탭: 10경기
                } else {
                    scrollTeamGamesToRecentGame(teamContent);
                    // 팀 탭에서도 전체 게임 뷰가 있으면 15경기로 스크롤
                    setTimeout(() => {
                        scrollAllGamesToRecentDate(teamContent, true); // 팀 탭: 15경기
                    }, 100);
                }
            });
        }

        function scrollTeamGamesToRecentGame(teamContent) {
            const tableWrapper = teamContent.querySelector('.table-scroll-wrapper');
            const table = document.getElementById('detailedGameTable');
            
            if (!tableWrapper || !table) return;

            const rows = table.querySelectorAll('tbody tr');
            let targetRow = null;
            let recentGameIndex = -1;

            // 가장 최근 경기 찾기 (과거 경기)
            for (let i = rows.length - 1; i >= 0; i--) {
                const row = rows[i];
                if (!row.classList.contains('future-game-row')) {
                    recentGameIndex = i;
                    break;
                }
            }

            if (recentGameIndex >= 0) {
                // 최근 15경기가 보이도록 조정 (더 더 많이 위로)
                const targetIndex = Math.max(0, recentGameIndex - 15);
                targetRow = rows[targetIndex];
            } else {
                // 과거 경기가 없으면 첫 번째 미래 경기 찾기
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (row.classList.contains('future-game-row')) {
                        targetRow = row;
                        break;
                    }
                }
            }

            // 부드러운 스크롤 (헤더 높이 계산)
            if (targetRow) {
                requestAnimationFrame(() => {
                    // 헤더 높이 정확히 계산
                    const stickyHeader = table.querySelector('thead tr');
                    const headerHeight = stickyHeader ? stickyHeader.offsetHeight : 40;
                    
                    const wrapperRect = tableWrapper.getBoundingClientRect();
                    const rowRect = targetRow.getBoundingClientRect();
                    // 헤더 높이만 고려해서 더 위쪽으로 조정
                    const scrollPosition = tableWrapper.scrollTop + (rowRect.top - wrapperRect.top) - headerHeight;

                    tableWrapper.scrollTo({
                        top: Math.max(0, scrollPosition),
                        behavior: 'smooth'
                    });
                });
            }
        }

        // 팀별 필터 초기화 함수
        function initializeTeamFilters() {
            if (currentSelectedTeam === '전체') return;
            
            // 상대팀 필터 옵션 생성
            const opponentSelect = document.getElementById('opponentFilter');
            if (!opponentSelect) return;
            
            opponentSelect.innerHTML = '<option value="all">전체 상대팀</option>';
            
            // dashboardData에서 headToHead 정보 확인
            console.log('dashboardData:', dashboardData);
            console.log('currentSelectedTeam:', currentSelectedTeam);
            
            if (dashboardData?.headToHead && dashboardData.headToHead[currentSelectedTeam]) {
                // 현재 팀의 상대전적 데이터에서 상대팀 목록 추출
                const opponents = Object.keys(dashboardData.headToHead[currentSelectedTeam]);
                
                // 순위별로 정렬
                const rankingSystem = getRankingSystem();
                const rankedTeams = rankingSystem.teams;
                const sortedOpponents = opponents.sort((a, b) => {
                    const rankA = rankedTeams.indexOf(a);
                    const rankB = rankedTeams.indexOf(b);
                    return rankA - rankB;
                });
                
                console.log('opponents found (ranked):', sortedOpponents);
                
                sortedOpponents.forEach((opponent, index) => {
                    const rank = rankedTeams.indexOf(opponent) + 1;
                    opponentSelect.innerHTML += `<option value="${opponent}">${rank}위 ${opponent}</option>`;
                });
            } else {
                // 백업: gameRecordsData에서 상대팀 추출
                if (gameRecordsData && gameRecordsData[currentSelectedTeam]) {
                    const gameOpponents = new Set();
                    gameRecordsData[currentSelectedTeam].games.forEach(game => {
                        if (game.opponent) gameOpponents.add(game.opponent);
                    });
                    const opponents = Array.from(gameOpponents);
                    
                    // 순위별로 정렬
                    const rankingSystem = getRankingSystem();
                    const rankedTeams = rankingSystem.teams;
                    const sortedOpponents = opponents.sort((a, b) => {
                        const rankA = rankedTeams.indexOf(a);
                        const rankB = rankedTeams.indexOf(b);
                        return rankA - rankB;
                    });
                    
                    console.log('opponents from gameRecords (ranked):', sortedOpponents);
                    
                    sortedOpponents.forEach((opponent, index) => {
                        const rank = rankedTeams.indexOf(opponent) + 1;
                        opponentSelect.innerHTML += `<option value="${opponent}">${rank}위 ${opponent}</option>`;
                    });
                }
            }
            
            // 필터 상태 초기화
            currentOpponentFilter = 'all';
            currentVenueFilter = 'all';
            updateVenueFilterButtons();
        }

        // 상대팀 필터 및 홈/원정 필터 적용 함수
        function applyTeamFilters() {
            if (currentSelectedTeam === '전체') return;
            
            const opponentFilter = document.getElementById('opponentFilter')?.value || 'all';
            currentOpponentFilter = opponentFilter;
            
            const tbody = document.getElementById('detailedGameTableBody');
            if (!tbody) return;
            
            const rows = tbody.querySelectorAll('tr');
            let visibleCount = 0;
            
            rows.forEach(row => {
                if (row.style.backgroundColor && row.style.backgroundColor.includes('233, 236, 239')) {
                    // 구분선 행은 항상 표시
                    row.style.display = '';
                    return;
                }
                
                let shouldShow = true;
                
                // 상대팀 필터
                if (currentOpponentFilter !== 'all') {
                    const opponentCell = row.querySelector('.opponent-cell');
                    if (opponentCell) {
                        // innerHTML에서 팀명 추출 (로고 제거)
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = opponentCell.innerHTML;
                        const teamName = tempDiv.textContent.trim();
                        
                        console.log('Filtering opponent:', teamName, 'vs filter:', currentOpponentFilter);
                        if (teamName !== currentOpponentFilter) {
                            shouldShow = false;
                        }
                    }
                }
                
                // 홈/원정 필터
                if (currentVenueFilter !== 'all') {
                    const venueCell = row.querySelector('.venue-cell');
                    if (venueCell) {
                        const venueText = venueCell.textContent.trim();
                        if (currentVenueFilter === 'home' && venueText !== '홈') {
                            shouldShow = false;
                        } else if (currentVenueFilter === 'away' && venueText !== '원정') {
                            shouldShow = false;
                        }
                    }
                }
                
                row.style.display = shouldShow ? '' : 'none';
                if (shouldShow) visibleCount++;
            });
            
            // 통계 업데이트
            updateFilteredStats(visibleCount);
        }

        // 홈/원정 필터 설정 함수
        function setVenueFilter(filter) {
            currentVenueFilter = filter;
            updateVenueFilterButtons();
            applyTeamFilters();
        }

        // 홈/원정 필터 버튼 상태 업데이트
        function updateVenueFilterButtons() {
            const buttons = ['venueAll', 'venueHome', 'venueAway'];
            const filters = ['all', 'home', 'away'];
            
            buttons.forEach((buttonId, index) => {
                const button = document.getElementById(buttonId);
                if (button) {
                    const isActive = currentVenueFilter === filters[index];
                    button.style.background = isActive ? '#495057' : 'transparent';
                    button.style.color = isActive ? 'white' : '#666';
                }
            });
        }

        // 필터링된 통계 업데이트 (선택사항)
        function updateFilteredStats(visibleCount) {
            // 필요시 필터링된 경기 수에 따른 통계 업데이트
            // 현재는 기본 구현만 제공
        }

        function scrollAllGamesToRecentDate(teamContent, isTeamTab = false) {
            const allGamesWrapper = teamContent.querySelector('.table-container');
            if (!allGamesWrapper) return;

            const rows = allGamesWrapper.querySelectorAll('tbody tr');
            const today = new Date();

            // 오늘 이전 가장 최근 경기 찾기
            for (let i = rows.length - 1; i >= 0; i--) {
                const firstCell = rows[i].querySelector('td:first-child');
                if (!firstCell) continue;
                
                const dateMatch = firstCell.textContent.match(/(\d{1,2})월 (\d{1,2})일/);
                if (!dateMatch) continue;
                
                const gameDate = new Date(2025, parseInt(dateMatch[1]) - 1, parseInt(dateMatch[2]));
                if (gameDate <= today) {
                    // 전체 탭: 11경기(10경기 보이도록), 팀 탭: 15경기
                    const gamesCount = isTeamTab ? 15 : 11;
                    const targetIndex = Math.max(0, i - gamesCount);
                    const targetRow = rows[targetIndex];
                    
                    allGamesWrapper.scrollTo({
                        top: targetRow.offsetTop - 30, // 여백 더 줄여서 더 많이 보이게
                        behavior: 'smooth'
                    });
                    break;
                }
            }
        }

        // 키보드 접근성 개선
        document.addEventListener('keydown', function(e) {
            // 일별 통계 네비게이션
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        dailyStatsChangeDate(-1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        dailyStatsChangeDate(1);
                        break;
                    case 'Home':
                        e.preventDefault();
                        dailyStatsGoToday();
                        break;
                }
            }
            
            // 차트 네비게이션
            if (e.altKey) {
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        if (typeof handlePrevPeriod === 'function') handlePrevPeriod();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        if (typeof handleNextPeriod === 'function') handleNextPeriod();
                        break;
                }
            }
        });

        // Focus 스타일 개선
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                button:focus, input:focus, select:focus {
                    outline: 3px solid #3b82f6 !important;
                    outline-offset: 2px !important;
                }
                .team-logo:focus {
                    outline: 2px solid #3b82f6;
                    outline-offset: 1px;
                    border-radius: 4px;
                }
                .nav-btn:focus {
                    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5) !important;
                }
            </style>
        `);

    </script>

    <!-- 연승/연패 기록 분석 스크립트 -->
    <script>
        
        // gameRecordsData에서 분석 (종합 순위와 동일한 방식)
        function analyzeFromGameRecordsData() {
            if (!dashboardData?.standings) return;
            
            // 종합 순위 기준 팀 순서 사용
            const teams = getRankingSystem().teams;
            const allTeamsData = {};
            
            teams.forEach(team => {
                if (gameRecordsData && gameRecordsData[team]) {
                    const games = gameRecordsData[team].games;
                    const streakData = calculateStreakPatternsFromGames(games);
                    allTeamsData[team] = streakData;
                }
            });
            
            renderAllTeamsStreakRecords(allTeamsData);
        }
        
        // gameRecordsData의 게임 배열에서 연승/연패 패턴 계산 (개선된 버전)
        function calculateStreakPatternsFromGames(games) {
            if (!games || games.length === 0) {
                return {
                    winStreaks: {},
                    loseStreaks: {},
                    maxWinStreak: 0,
                    maxLoseStreak: 0,
                    totalGames: 0
                };
            }
            
            const winStreaks = {};
            const loseStreaks = {};
            let maxWinStreak = 0;
            let maxLoseStreak = 0;
            
            // 날짜순으로 정렬하고 유효한 게임만 필터링 (과거부터 현재까지)
            const sortedGames = games
                .filter(game => game && game.result && game.date && game.date !== 'undefined')
                .sort((a, b) => new Date(a.date) - new Date(b.date));
            
            let currentStreak = 0;
            let currentType = null;
            
            
            for (const game of sortedGames) {
                // 무승부는 무시 (연속을 끊지 않음)
                if (game.result === 'D' || game.result === 'T') {
                    continue;
                }
                
                // 승부 결과만 처리 (승 또는 패)
                if (game.result === 'W' || game.result === 'L') {
                    if (game.result === currentType) {
                        currentStreak++;
                    } else {
                        // 이전 연속 기록 저장
                        if (currentStreak > 0 && currentType) {
                            if (currentType === 'W') {
                                winStreaks[currentStreak] = (winStreaks[currentStreak] || 0) + 1;
                                maxWinStreak = Math.max(maxWinStreak, currentStreak);
                            } else if (currentType === 'L') {
                                loseStreaks[currentStreak] = (loseStreaks[currentStreak] || 0) + 1;
                                maxLoseStreak = Math.max(maxLoseStreak, currentStreak);
                            }
                        }
                        currentType = game.result;
                        currentStreak = 1;
                    }
                }
            }
            
            // 마지막 연속 기록 처리
            if (currentStreak > 0 && currentType) {
                if (currentType === 'W') {
                    winStreaks[currentStreak] = (winStreaks[currentStreak] || 0) + 1;
                    maxWinStreak = Math.max(maxWinStreak, currentStreak);
                } else if (currentType === 'L') {
                    loseStreaks[currentStreak] = (loseStreaks[currentStreak] || 0) + 1;
                    maxLoseStreak = Math.max(maxLoseStreak, currentStreak);
                }
            }
            
            
            return {
                winStreaks,
                loseStreaks,
                maxWinStreak,
                maxLoseStreak,
                totalGames: sortedGames.filter(g => g.result === 'W' || g.result === 'L').length
            };
        }
        
        // 연승/연패 기록 렌더링
        function renderStreakRecords(teamName, streakData) {
            if (!streakData) {
                document.getElementById('streakRecordsContent').innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #dc2626;">
                        ${teamName} 팀의 기록을 분석할 수 없습니다.
                    </div>
                `;
                return;
            }
            
            const { winStreaks, loseStreaks, maxWinStreak, maxLoseStreak, totalGames } = streakData;
            
            // 연승 데이터 정렬 (1승, 2연승, 3연승...)
            const sortedWinStreaks = Object.keys(winStreaks)
                .map(Number)
                .sort((a, b) => a - b)
                .map(streak => ({ streak, count: winStreaks[streak] }));
            
            // 연패 데이터 정렬 (1패, 2연패, 3연패...)
            const sortedLoseStreaks = Object.keys(loseStreaks)
                .map(Number)
                .sort((a, b) => a - b)
                .map(streak => ({ streak, count: loseStreaks[streak] }));
            
            // 최대 연승/연패 길이 구하기 (테이블 행 수 맞추기 위해)
            const maxRows = Math.max(15, sortedWinStreaks.length, sortedLoseStreaks.length);
            
            // 빈 행 채우기
            while (sortedWinStreaks.length < maxRows) {
                sortedWinStreaks.push({ streak: sortedWinStreaks.length + 1, count: 0 });
            }
            while (sortedLoseStreaks.length < maxRows) {
                sortedLoseStreaks.push({ streak: sortedLoseStreaks.length + 1, count: 0 });
            }
            
            let html = `
                <div style="margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px;">
                        <div style="text-align: center; padding: 15px; background: var(--positive-bg-light); border-radius: 8px; border: 1px solid #d4edda;">
                            <div style="font-size: var(--text-lg); font-weight: var(--font-weight-bold); color: var(--positive-color);">최장 연승</div>
                            <div style="font-size: var(--text-2xl); font-weight: var(--font-weight-bold); color: var(--positive-color);">${maxWinStreak}경기</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: var(--negative-bg-light); border-radius: 8px; border: 1px solid #f8d7da;">
                            <div style="font-size: var(--text-lg); font-weight: var(--font-weight-bold); color: var(--negative-color);">최장 연패</div>
                            <div style="font-size: var(--text-2xl); font-weight: var(--font-weight-bold); color: var(--negative-color);">${maxLoseStreak}경기</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                            <div style="font-size: var(--text-lg); font-weight: var(--font-weight-bold); color: #495057;">분석 경기수</div>
                            <div style="font-size: var(--text-2xl); font-weight: var(--font-weight-bold); color: #495057;">${totalGames}경기</div>
                        </div>
                    </div>
                </div>
                
                <!-- 통합 테이블 -->
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; background: white; border: 1px solid #dee2e6; border-radius: 8px; overflow: hidden;">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); color: white;">
                                <th colspan="2" style="padding: 12px; text-align: center; border-right: 2px solid white; font-size: var(--text-lg);">
                                    🔥 연승 기록
                                </th>
                                <th colspan="2" style="padding: 12px; text-align: center; font-size: var(--text-lg);">
                                    💧 연패 기록
                                </th>
                            </tr>
                            <tr style="background: #f8f9fa;">
                                <th style="padding: 10px; text-align: center; border: 1px solid #dee2e6; width: 25%;">연승 수</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #dee2e6; width: 25%;">횟수</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #dee2e6; width: 25%;">연패 수</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #dee2e6; width: 25%;">횟수</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${Array.from({ length: maxRows }, (_, i) => {
                                const winData = sortedWinStreaks[i];
                                const loseData = sortedLoseStreaks[i];
                                
                                return `
                                    <tr>
                                        <td style="padding: 8px; text-align: center; border: 1px solid #dee2e6; font-weight: var(--font-weight-bold); ${winData.count === 0 ? 'color: #ccc;' : ''}">
                                            ${winData.streak === 1 ? '1승' : `${winData.streak}연승`}
                                        </td>
                                        <td style="padding: 8px; text-align: center; border: 1px solid #dee2e6; ${winData.count > 0 ? 'color: var(--positive-color); font-weight: var(--font-weight-bold);' : 'color: #ccc;'}">
                                            ${winData.count > 0 ? `${winData.count}회` : '-'}
                                        </td>
                                        <td style="padding: 8px; text-align: center; border: 1px solid #dee2e6; font-weight: var(--font-weight-bold); ${loseData.count === 0 ? 'color: #ccc;' : ''}">
                                            ${loseData.streak === 1 ? '1패' : `${loseData.streak}연패`}
                                        </td>
                                        <td style="padding: 8px; text-align: center; border: 1px solid #dee2e6; ${loseData.count > 0 ? 'color: var(--negative-color); font-weight: var(--font-weight-bold);' : 'color: #ccc;'}">
                                            ${loseData.count > 0 ? `${loseData.count}회` : '-'}
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('streakRecordsContent').innerHTML = html;
        }
        
        // 전체 팀 연승/연패 기록 렌더링 (종합 순위와 동일한 방식)
        function renderAllTeamsStreakRecords(allTeamsData) {
            if (!dashboardData?.standings) return;
            
            // 종합 순위 기준 팀 순서 사용
            const teams = getRankingSystem().teams;
            const teamRanks = getRankingSystem().teamRanks;
            
            // 전체 팀의 최대 연승/연패 찾기
            let globalMaxWinStreak = 0;
            let globalMaxLoseStreak = 0;
            
            Object.values(allTeamsData).forEach(teamData => {
                if (teamData) {
                    globalMaxWinStreak = Math.max(globalMaxWinStreak, teamData.maxWinStreak || 0);
                    globalMaxLoseStreak = Math.max(globalMaxLoseStreak, teamData.maxLoseStreak || 0);
                }
            });
            
            // 최소 10까지는 표시, 최대값이 더 크면 그것까지 표시
            const maxWinCols = Math.max(10, globalMaxWinStreak);
            const maxLoseCols = Math.max(10, globalMaxLoseStreak);
            
            // 연승/연패 컬럼 배열 생성
            const winColumns = Array.from({length: maxWinCols}, (_, i) => i + 1);
            const loseColumns = Array.from({length: maxLoseCols}, (_, i) => i + 1);
            
            let html = `
                <div class="table-scroll-wrapper">
                    <table id="streakRecordsTable" class="streak-records-table sortable-table">
                        <thead>
                            <tr class="main-header">
                                <th rowspan="2" class="sortable rank-header" data-column="rank">순위</th>
                                <th rowspan="2" class="team-header">팀명</th>
                                <th colspan="${maxWinCols}" class="section-header wins-section">🔥 연승 기록 (횟수)</th>
                                <th rowspan="2" class="sortable max-header wins-max" data-column="maxWins">최장<br>연승</th>
                                <th colspan="${maxLoseCols}" class="section-header losses-section">💧 연패 기록 (횟수)</th>
                                <th rowspan="2" class="sortable max-header losses-max" data-column="maxLosses">최장<br>연패</th>
                            </tr>
                            <tr class="sub-header">
                                ${winColumns.map(n => 
                                    `<th class="sortable streak-count-header wins-count" data-column="wins${n}">${n}${n === 1 ? '승' : '연승'}</th>`
                                ).join('')}
                                ${loseColumns.map(n => 
                                    `<th class="sortable streak-count-header losses-count" data-column="losses${n}">${n}${n === 1 ? '패' : '연패'}</th>`
                                ).join('')}
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // 각 팀별 행 생성
            teams.forEach((team, index) => {
                const teamData = allTeamsData[team];
                
                // KBO 규정 동률 처리가 적용된 순위 사용
                const rank = teamRanks[team] || 999;
                
                if (!teamData) {
                    // 전체 컬럼 수 계산: 연승컬럼 + 최장연승 + 연패컬럼 + 최장연패
                    const totalCols = maxWinCols + 1 + maxLoseCols + 1;
                    html += `
                        <tr data-rank="${rank}" data-team="${team}" class="no-data-row">
                            <td class="rank-cell rank-${rank <= 3 ? rank : 'other'}">${rank}</td>
                            <td class="team-cell">${getTeamWithLogo(team)}</td>
                            <td colspan="${totalCols}" class="no-data-cell">데이터 없음</td>
                        </tr>
                    `;
                    return;
                }
                
                const { winStreaks, loseStreaks, maxWinStreak, maxLoseStreak } = teamData;
                
                html += `
                    <tr class="${index % 2 === 0 ? 'even-row' : 'odd-row'}" 
                        data-rank="${rank}" 
                        data-team="${team}" 
                        data-maxwins="${maxWinStreak}" 
                        data-maxlosses="${maxLoseStreak}">
                        <td class="rank-cell rank-${rank <= 3 ? rank : 'other'}">${rank}</td>
                        <td class="team-cell">${getTeamWithLogo(team)}</td>
                `;
                
                // 연승 데이터 (동적 컬럼 수)
                for (let i = 1; i <= maxWinCols; i++) {
                    const count = winStreaks[i] || 0;
                    html += `<td data-wins${i}="${count}" class="streak-count-cell wins-data ${count > 0 ? 'has-data' : 'no-data'}">${count > 0 ? count : '-'}</td>`;
                }
                
                // 최장 연승 (연승 섹션 바로 다음)
                html += `<td class="max-streak-cell max-wins-cell" data-maxwins="${maxWinStreak}">${maxWinStreak}</td>`;
                
                // 연패 데이터 (동적 컬럼 수)
                for (let i = 1; i <= maxLoseCols; i++) {
                    const count = loseStreaks[i] || 0;
                    html += `<td data-losses${i}="${count}" class="streak-count-cell losses-data ${count > 0 ? 'has-data' : 'no-data'}">${count > 0 ? count : '-'}</td>`;
                }
                
                // 최장 연패
                html += `<td class="max-streak-cell max-losses-cell" data-maxlosses="${maxLoseStreak}">${maxLoseStreak}</td>
                </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('streakRecordsContent').innerHTML = html;
            
            // 테이블 정렬 기능 추가
            setTimeout(() => {
                const streakTable = document.getElementById('streakRecordsTable');
                if (!streakTable) return;
                
                // 모든 sortable 헤더에 클릭 이벤트 추가
                const sortableHeaders = streakTable.querySelectorAll('th.sortable');
                sortableHeaders.forEach((header) => {
                    // 기존 이벤트 리스너 제거 (중복 방지)
                    const existingHandler = header._sortHandler;
                    if (existingHandler) {
                        header.removeEventListener('click', existingHandler);
                    }
                    
                    // 실제 컬럼 인덱스 계산 (복잡한 헤더 구조 고려)
                    let actualColumnIndex = 0;
                    const columnAttr = header.getAttribute('data-column');
                    
                    if (columnAttr === 'rank') {
                        actualColumnIndex = 0;
                    } else if (header.classList.contains('team-header')) {
                        actualColumnIndex = 1;
                    } else if (columnAttr === 'maxWins') {
                        // 최장연승 컬럼: 순위(1) + 팀명(1) + 연승컬럼들(maxWinCols) = 2 + maxWinCols
                        actualColumnIndex = 2 + maxWinCols;
                    } else if (columnAttr === 'maxLosses') {
                        // 최장연패 컬럼: 순위(1) + 팀명(1) + 연승컬럼들(maxWinCols) + 최장연승(1) + 연패컬럼들(maxLoseCols) = 3 + maxWinCols + maxLoseCols
                        actualColumnIndex = 3 + maxWinCols + maxLoseCols;
                    } else if (columnAttr?.startsWith('wins')) {
                        // 연승 컬럼: wins1, wins2, wins3...
                        const winsNum = parseInt(columnAttr.replace('wins', ''));
                        actualColumnIndex = 1 + winsNum; // 순위(1) + 팀명(1) + 연승번호
                    } else if (columnAttr?.startsWith('losses')) {
                        // 연패 컬럼: losses1, losses2, losses3...
                        const lossesNum = parseInt(columnAttr.replace('losses', ''));
                        actualColumnIndex = 2 + maxWinCols + lossesNum; // 순위(1) + 팀명(1) + 연승컬럼들(maxWinCols) + 최장연승(1) + 연패번호
                    } else {
                        // 폴백으로 기존 방식 사용
                        const allHeaders = Array.from(streakTable.querySelectorAll('thead tr th'));
                        actualColumnIndex = allHeaders.indexOf(header);
                    }
                    
                    // 새 이벤트 리스너 추가
                    const sortHandler = () => {
                        sortTable(streakTable, actualColumnIndex, header);
                    };
                    header._sortHandler = sortHandler;
                    header.addEventListener('click', sortHandler);
                    
                    // 마우스 커서 포인터로 변경
                    header.style.cursor = 'pointer';
                });
                
                // 기본적으로 순위 컬럼으로 정렬 (오름차순)
                const rankHeader = streakTable.querySelector('th[data-column="rank"]');
                if (rankHeader && rankHeader.click) {
                    // 순위 컬럼으로 강제 정렬
                    setTimeout(() => {
                        rankHeader.click();
                        // 내림차순이면 다시 클릭해서 오름차순으로
                        if (rankHeader.classList.contains('sort-desc')) {
                            rankHeader.click();
                        }
                    }, 50);
                }
            }, 100);
        }
        
        // 게임별 기록 데이터 로드 완료 후 연승/연패 분석 실행
        function initStreakRecords() {
            if (gameRecordsData) {
                console.log('연승/연패: gameRecordsData 발견, 분석 시작');
                analyzeFromGameRecordsData();
            } else {
                console.log('연승/연패: gameRecordsData 대기 중...');
                // 연승/연패 기록 데이터가 없으면 기본 메시지 표시
                document.getElementById('streakRecordsContent').innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #dc2626;">
                        게임별 기록 데이터를 불러올 수 없습니다.
                    </div>
                `;
            }
        }
        
        // 페이지 로드 시 자동 실행
        window.addEventListener('load', function() {
            setTimeout(initStreakRecords, 5000);
        });
    </script>


    <!-- ================== AdSense 레퍼런스 방식 사용 ================== -->
    <!-- 각 광고 뒤에 개별 script 태그로 초기화 (중복 초기화 제거됨) -->

    <!-- ================== 성능 최적화 스크립트 ================== -->
    <script>
    // 사전계산 데이터 로드 및 적용
    let precomputedUIData = null;
    
    async function loadPrecomputedUIData() {
        try {
            const response = await fetch('data/ui-precomputed-data.json');
            if (!response.ok) {
                console.warn('사전계산 데이터 로드 실패, 기존 방식으로 대체');
                return null;
            }
            precomputedUIData = await response.json();
            console.log('✅ 사전계산 UI 데이터 로드 완료');
            return precomputedUIData;
        } catch (error) {
            console.warn('사전계산 데이터 로드 중 오류:', error.message);
            return null;
        }
    }
    
    // 팀 설정 최적화
    function getOptimizedTeamConfig(teamName) {
        if (precomputedUIData?.teamConfigurations?.[teamName]) {
            return precomputedUIData.teamConfigurations[teamName];
        }
        // 기존 방식으로 폴백
        return null;
    }
    
    // 연승/연패 분석 최적화
    function getOptimizedStreakAnalysis(teamName) {
        if (precomputedUIData?.streakAnalysis?.[teamName]) {
            return precomputedUIData.streakAnalysis[teamName];
        }
        return null;
    }
    
    // 전후반기 통계 최적화  
    function getOptimizedHalfSeasonStats(teamName) {
        if (precomputedUIData?.halfSeasonStats?.[teamName]) {
            return precomputedUIData.halfSeasonStats[teamName];
        }
        return null;
    }
    
    // 페이지 로드 시 사전계산 데이터 먼저 로드
    document.addEventListener('DOMContentLoaded', async function() {
        const startTime = performance.now();

        // 사전계산 데이터 로드
        await loadPrecomputedUIData();

        // 시즌 경기 데이터 로드 (중계사 분석용)
        await loadSeasonGamesData();

        const loadTime = performance.now() - startTime;
        console.log(`⚡ 최적화 데이터 로드 시간: ${loadTime.toFixed(2)}ms`);

        // 기존 초기화 함수가 있다면 실행
        if (typeof initializeDashboard === 'function') {
            initializeDashboard();
        }

        // 중계사별 승률 분석 초기화 (데이터 로드 후)
        setTimeout(() => {
            renderBroadcasterStats();
        }, 1000);

        // 팀명 정렬 버튼 이벤트 리스너는 헤더 생성 후 renderBroadcasterStats에서 처리

    });

    // 전역 변수로 정렬 상태 관리
    window.broadcasterSortState = {
        team: null,
        order: 'none'
    };

    // 중계사별 승률 분석 렌더링 함수
    function renderBroadcasterStats(sortByName = false, sortByTeam = null, sortOrder = 'desc') {
        console.log('🔧 renderBroadcasterStats 시작');

        const tbody = document.getElementById('broadcasterBody');
        const theadElement = document.getElementById('broadcasterHeader');

        if (!tbody || !theadElement) {
            console.error('❌ broadcasterBody 또는 broadcasterHeader 요소를 찾을 수 없습니다');
            return;
        }

        console.log('✅ HTML 요소 찾기 완료');

        if (!dashboardData?.standings) {
            console.log('dashboardData 로딩 중... 재시도합니다');
            tbody.innerHTML = `
                <tr>
                    <td colspan="11" style="text-align: center; padding: 20px;">
                        데이터를 로드하고 있습니다...
                    </td>
                </tr>
            `;
            setTimeout(() => renderBroadcasterStats(), 2000);
            return;
        }

        // 팀 순서 결정
        const rankingSystem = getRankingSystem();
        let teams = rankingSystem.teams;
        if (sortByName) {
            teams = [...teams].sort();
        }

        // 팀 로고 매핑
        const teamLogos = {
            'LG': 'magic-number/images/teams/lg.png',
            'KIA': 'magic-number/images/teams/kia.png',
            'SSG': 'magic-number/images/teams/ssg.png',
            '두산': 'magic-number/images/teams/doosan.png',
            '삼성': 'magic-number/images/teams/samsung.png',
            'KT': 'magic-number/images/teams/kt.png',
            'NC': 'magic-number/images/teams/nc.png',
            '롯데': 'magic-number/images/teams/lotte.png',
            '키움': 'magic-number/images/teams/kiwoom.png',
            '한화': 'magic-number/images/teams/hanwha.png'
        };

        // 헤더 생성 (매번 생성하되, 이벤트는 중복 방지)
        let headerHtml = '<tr><th style="width: 10%;">중계사</th>';
        teams.forEach(teamName => {
            const logoPath = teamLogos[teamName] || 'magic-number/images/teams/default.png';
            headerHtml += `
                <th class="team-header-sort" style="width: 9%; cursor: pointer; user-select: none;" title="클릭하여 정렬 변경" data-team="${teamName}">
                    <img src="${logoPath}" alt="${teamName}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">
                    ${teamName}
                </th>
            `;
        });
        headerHtml += '</tr>';
        theadElement.innerHTML = headerHtml;

        // 이벤트 리스너 추가 (중복 제거 후 다시 추가)
        document.querySelectorAll('.team-header-sort').forEach(header => {
            header.addEventListener('click', function() {
                const clickedTeam = this.getAttribute('data-team');

                if (window.broadcasterSortState.team === clickedTeam) {
                    // 같은 팀 재클릭: 토글
                    window.broadcasterSortState.order = window.broadcasterSortState.order === 'desc' ? 'asc' : 'desc';
                } else {
                    // 다른 팀 클릭: 새로운 정렬
                    window.broadcasterSortState.team = clickedTeam;
                    window.broadcasterSortState.order = 'desc';
                }

                console.log(`${clickedTeam} 클릭 - 정렬: ${window.broadcasterSortState.order}`);
                renderBroadcasterStats(sortByName, window.broadcasterSortState.team, window.broadcasterSortState.order);
            });
        });

        // 실제 KBO 경기 데이터에서 중계사별 데이터 계산 (캐시 초기화)
        window.cachedBroadcasterData = {};
        teams.forEach(teamName => {
            const data = calculateRealBroadcasterData(teamName);
            window.cachedBroadcasterData[teamName] = data;
            console.log(`📊 ${teamName} 중계사별 데이터:`, Object.keys(data));
        });
        const allTeamsData = window.cachedBroadcasterData;

        // 중계사 목록 (알파벳 순, clean.txt 실제 데이터 기준, TVING 제외)
        const broadcasters = [
            { key: 'kbs_2tv', name: 'KBS 2TV' },
            { key: 'kbs_n_sports', name: 'KBS N SPORTS' },
            { key: 'mbc_sports_plus', name: 'MBC SPORTS+' },
            { key: 'mbc_tv', name: 'MBC TV' },
            { key: 'sbs_sports', name: 'SBS SPORTS' },
            { key: 'sbs_tv', name: 'SBS TV' },
            { key: 'spotv', name: 'SPOTV' },
            { key: 'spotv2', name: 'SPOTV2' }
        ];

        // 모든 중계사 포함 (TVING 제거로 필터링 불필요)
        const broadcastersForTotal = broadcasters;

        let html = '';

        // 중계사 정렬 (특정 팀의 실제 데이터 셀 승률 기준)
        let sortedBroadcasters = [...broadcasters];
        if (sortByTeam && allTeamsData[sortByTeam]) {
            sortedBroadcasters.sort((a, b) => {
                const winRateA = allTeamsData[sortByTeam][a.key].winRate;
                const winRateB = allTeamsData[sortByTeam][b.key].winRate;

                // 정렬 순서에 따라 오름차순/내림차순 결정
                if (sortOrder === 'desc') {
                    return winRateB - winRateA; // 내림차순 (높은 승률 → 낮은 승률)
                } else {
                    return winRateA - winRateB; // 오름차순 (낮은 승률 → 높은 승률)
                }
            });
            console.log(`${sortByTeam} 팀 기준으로 중계사 ${sortOrder === 'desc' ? '내림차순 (높은 승률→낮은 승률)' : '오름차순 (낮은 승률→높은 승률)'} 정렬 완료`);
            console.log(`정렬된 중계사 순서:`, sortedBroadcasters.map(b => `${b.name}: ${allTeamsData[sortByTeam][b.key].winRate.toFixed(3)}`));
        }

        // 각 중계사별로 행 생성
        sortedBroadcasters.forEach(broadcaster => {
            // 해당 중계사에서 모든 팀의 승률 수집 (그라데이션용)
            const broadcasterWinRates = teams.map(teamName =>
                allTeamsData[teamName][broadcaster.key].winRate
            );

            html += `<tr><td class="broadcaster-name">${broadcaster.name}</td>`;

            // 각 팀별 데이터 셀 생성
            teams.forEach(teamName => {
                const teamData = allTeamsData[teamName]?.[broadcaster.key];

                // 디버깅: 데이터 존재 여부 확인
                if (!teamData) {
                    console.error(`❌ ${teamName} 팀의 ${broadcaster.key} 데이터가 없습니다.`);
                    console.log('allTeamsData[teamName]:', allTeamsData[teamName]);
                    return;
                }

                // 팀 기준 그라데이션 (해당 팀의 중계사별 성과 비교) - 알파벳 순
                const teamWinRates = [
                    allTeamsData[teamName]?.['kbs_2tv']?.winRate || 0,
                    allTeamsData[teamName]?.['kbs_n_sports']?.winRate || 0,
                    allTeamsData[teamName]?.['mbc_sports_plus']?.winRate || 0,
                    allTeamsData[teamName]?.['mbc_tv']?.winRate || 0,
                    allTeamsData[teamName]?.['sbs_sports']?.winRate || 0,
                    allTeamsData[teamName]?.['sbs_tv']?.winRate || 0,
                    allTeamsData[teamName]?.['spotv']?.winRate || 0,
                    allTeamsData[teamName]?.['spotv2']?.winRate || 0
                ];
                const cellStyle = getBroadcasterCellStyleByTeam(teamData.winRate, teamWinRates);

                const totalGames = teamData.wins + teamData.losses + teamData.draws;
                html += `
                    <td style="${cellStyle}; text-align: center; padding: 4px 2px; font-size: var(--font-xs); line-height: 1.3;">
                        <div>${teamData.wins}-${teamData.losses}-${teamData.draws} (${teamData.winRate.toFixed(3)})</div>
                        <div style="color: #666; font-size: 11px;">${totalGames}경기</div>
                    </td>
                `;
            });

            html += '</tr>';
        });

        // 총 합계 행 추가
        html += '<tr style="border-top: 2px solid #666; font-weight: bold; background: #f8f9fa;"><td class="broadcaster-name" style="font-weight: bold;">총 합계</td>';

        // 각 팀별 총합 계산
        teams.forEach(teamName => {
            let totalWins = 0, totalLosses = 0, totalDraws = 0;

            broadcastersForTotal.forEach(broadcaster => {
                const teamData = allTeamsData[teamName][broadcaster.key];
                totalWins += teamData.wins;
                totalLosses += teamData.losses;
                totalDraws += teamData.draws;
            });

            const totalGames = totalWins + totalLosses + totalDraws;
            const totalWinRate = totalGames > 0 ? totalWins / (totalWins + totalLosses) : 0;

            html += `
                <td style="text-align: center; padding: 4px 2px; font-size: var(--font-xs); font-weight: bold; line-height: 1.3;">
                    <div>${totalWins}-${totalLosses}-${totalDraws} (${totalWinRate.toFixed(3)})</div>
                    <div style="color: #666; font-size: 11px;">${totalGames}경기</div>
                </td>
            `;
        });

        html += '</tr>';

        tbody.innerHTML = html;
    }

    // 승률에 따른 세밀한 그라데이션 셀 스타일 반환 (범용)
    function getEnhancedWinRateCellStyle(winRate) {
        if (winRate >= 0.700) {
            return 'background: var(--positive-bg-very-strong);';
        } else if (winRate >= 0.600) {
            return 'background: var(--positive-bg-strong);';
        } else if (winRate >= 0.550) {
            return 'background: var(--positive-bg-medium);';
        } else if (winRate > 0.500) {
            return 'background: var(--positive-bg-light);';
        } else if (winRate === 0.500) {
            return 'background: var(--neutral-bg-light);';
        } else if (winRate >= 0.450) {
            return 'background: var(--negative-bg-light);';
        } else if (winRate >= 0.400) {
            return 'background: var(--negative-bg-medium);';
        } else if (winRate >= 0.300) {
            return 'background: var(--negative-bg-strong);';
        } else {
            return 'background: var(--negative-bg-very-strong);';
        }
    }

    // 팀별 중계사 승률 비교를 위한 셀 스타일 반환 (상대적 그라데이션)
    function getBroadcasterCellStyleByTeam(winRate, teamWinRates) {
        // 해당 팀의 모든 중계사 승률 중에서 상대적 위치 계산
        const sortedRates = [...teamWinRates].sort((a, b) => b - a);
        const maxRate = sortedRates[0];
        const minRate = sortedRates[sortedRates.length - 1];

        let backgroundColor, textColor, fontWeight = 'var(--font-weight-semibold)';

        // 팀 내에서 상대적 순위 계산
        const rank = sortedRates.indexOf(winRate) + 1;
        const totalCount = teamWinRates.length;

        if (rank === 1) {
            // 팀 내 최고 승률
            backgroundColor = 'var(--positive-bg-very-strong)';
            textColor = 'var(--positive-color)';
            fontWeight = 'var(--font-weight-bold)';
        } else if (rank === 2) {
            // 팀 내 2위
            backgroundColor = 'var(--positive-bg-strong)';
            textColor = 'var(--positive-color)';
            fontWeight = 'var(--font-weight-bold)';
        } else if (rank === 3) {
            // 팀 내 3위
            backgroundColor = 'var(--positive-bg-medium)';
            textColor = 'var(--positive-color)';
        } else if (rank <= Math.ceil(totalCount / 2)) {
            // 팀 내 상위권
            backgroundColor = 'var(--positive-bg-light)';
            textColor = 'var(--positive-color)';
        } else if (rank === totalCount) {
            // 팀 내 최하위
            backgroundColor = 'var(--negative-bg-very-strong)';
            textColor = 'var(--negative-color)';
            fontWeight = 'var(--font-weight-bold)';
        } else if (rank === totalCount - 1) {
            // 팀 내 하위 2위
            backgroundColor = 'var(--negative-bg-strong)';
            textColor = 'var(--negative-color)';
            fontWeight = 'var(--font-weight-bold)';
        } else {
            // 팀 내 하위권
            backgroundColor = 'var(--negative-bg-medium)';
            textColor = 'var(--negative-color)';
        }

        return `background: ${backgroundColor}; color: ${textColor}; font-weight: ${fontWeight}; text-align: center; border-radius: 4px; padding: 6px;`;
    }

    // 중계사별 팀 승률 비교를 위한 셀 스타일 반환 (상대적 그라데이션)
    function getBroadcasterCellStyleByBroadcaster(winRate, broadcasterWinRates) {
        // 해당 중계사의 모든 팀 승률 중에서 상대적 위치 계산
        const sortedRates = [...broadcasterWinRates].sort((a, b) => b - a);

        let backgroundColor, textColor, fontWeight = 'var(--font-weight-semibold)';

        // 중계사 내에서 상대적 순위 계산
        const rank = sortedRates.indexOf(winRate) + 1;
        const totalCount = broadcasterWinRates.length;

        if (rank === 1) {
            // 중계사 내 최고 승률 팀
            backgroundColor = 'var(--positive-bg-very-strong)';
            textColor = 'var(--positive-color)';
            fontWeight = 'var(--font-weight-bold)';
        } else if (rank === 2) {
            // 중계사 내 2위 팀
            backgroundColor = 'var(--positive-bg-strong)';
            textColor = 'var(--positive-color)';
            fontWeight = 'var(--font-weight-bold)';
        } else if (rank === 3) {
            // 중계사 내 3위 팀
            backgroundColor = 'var(--positive-bg-medium)';
            textColor = 'var(--positive-color)';
        } else if (rank <= Math.ceil(totalCount / 2)) {
            // 중계사 내 상위권 팀
            backgroundColor = 'var(--positive-bg-light)';
            textColor = 'var(--positive-color)';
        } else if (rank === totalCount) {
            // 중계사 내 최하위 팀
            backgroundColor = 'var(--negative-bg-very-strong)';
            textColor = 'var(--negative-color)';
            fontWeight = 'var(--font-weight-bold)';
        } else if (rank === totalCount - 1) {
            // 중계사 내 하위 2위 팀
            backgroundColor = 'var(--negative-bg-strong)';
            textColor = 'var(--negative-color)';
            fontWeight = 'var(--font-weight-bold)';
        } else {
            // 중계사 내 하위권 팀
            backgroundColor = 'var(--negative-bg-medium)';
            textColor = 'var(--negative-color)';
        }

        return `background: ${backgroundColor}; color: ${textColor}; font-weight: ${fontWeight}; text-align: center; border-radius: 4px; padding: 6px;`;
    }

    // clean.txt 파일에서 실제 KBO 경기 데이터 로드
    async function loadSeasonGamesData() {
        try {
            const response = await fetch(`magic-number/data/2025-season-data-clean.txt?v=${Date.now()}`);
            if (response.ok) {
                const cleanText = await response.text();
                window.seasonGamesData = parseCleanTextData(cleanText);
                console.log('✅ clean.txt 경기 데이터 로드 완료:', window.seasonGamesData.length, '게임');
            } else {
                console.warn('⚠️ clean.txt 데이터 로드 실패');
                window.seasonGamesData = [];
            }
        } catch (error) {
            console.error('❌ clean.txt 데이터 로드 에러:', error);
            window.seasonGamesData = [];
        }
    }

    // clean.txt 파일 파싱 함수
    function parseCleanTextData(cleanText) {
        const games = [];
        const lines = cleanText.split('\n');
        let currentDate = '';

        for (const line of lines) {
            const trimmedLine = line.trim();

            // 날짜 라인 감지 (예: "2025-03-22 (금)")
            if (trimmedLine.match(/^\d{4}-\d{2}-\d{2} \([월화수목금토일]\)$/)) {
                currentDate = trimmedLine.substring(0, 10); // "2025-03-22"
                continue;
            }

            // 경기 데이터 라인 파싱
            // 형식: "18:30    종료     잠실     LG   한화   0:4      SBS SPORTS 페넌트레이스"
            // 스코어 형식: 원정팀점수:홈팀점수
            const gameMatch = trimmedLine.match(/^(\d{2}:\d{2})\s+종료\s+(\S+)\s+(\S+)\s+(\S+)\s+(\d+):(\d+)\s+(.+)$/);
            if (gameMatch && currentDate) {
                const [, time, stadium, homeTeam, awayTeam, awayScore, homeScore, broadcastInfo] = gameMatch;

                const homeScoreInt = parseInt(homeScore);
                const awayScoreInt = parseInt(awayScore);
                let winner = null;

                if (homeScoreInt > awayScoreInt) {
                    winner = homeTeam;
                } else if (awayScoreInt > homeScoreInt) {
                    winner = awayTeam;
                } // 무승부는 winner가 null로 남음

                // 중계사 정보 추출 (페넌트레이스 앞부분)
                const broadcast = broadcastInfo.replace(/\s*페넌트레이스$/, '').trim();

                games.push({
                    date: currentDate,
                    time: time,
                    stadium: stadium,
                    home_team: homeTeam,
                    away_team: awayTeam,
                    home_score: homeScoreInt,
                    away_score: awayScoreInt,
                    winner: winner,
                    broadcast: broadcast,
                    state: "종료"
                });
            }
        }

        return games;
    }

    // 실제 KBO 경기 데이터를 기반으로 중계사별 집계 계산
    function calculateRealBroadcasterData(teamName) {
        const seasonGames = window.seasonGamesData || [];

        // 중계사별 집계 초기화 (알파벳 순, clean.txt 실제 중계사 기준, TVING 제외)
        const broadcasterStats = {
            kbs_2tv: { wins: 0, losses: 0, draws: 0, winRate: 0 },
            kbs_n_sports: { wins: 0, losses: 0, draws: 0, winRate: 0 },
            mbc_sports_plus: { wins: 0, losses: 0, draws: 0, winRate: 0 },
            mbc_tv: { wins: 0, losses: 0, draws: 0, winRate: 0 },
            sbs_sports: { wins: 0, losses: 0, draws: 0, winRate: 0 },
            sbs_tv: { wins: 0, losses: 0, draws: 0, winRate: 0 },
            spotv: { wins: 0, losses: 0, draws: 0, winRate: 0 },
            spotv2: { wins: 0, losses: 0, draws: 0, winRate: 0 }
        };

        // 해당 팀의 경기만 필터링하여 집계
        seasonGames.forEach(game => {
            if (game.home_team === teamName || game.away_team === teamName) {
                const broadcast = game.broadcast || '';
                let broadcasterKey = null;

                // 중계사 분류 (clean.txt 정확한 매칭, TVING 제외)
                if (broadcast === 'KBS N SPORTS') broadcasterKey = 'kbs_n_sports';
                else if (broadcast === 'MBC SPORTS+') broadcasterKey = 'mbc_sports_plus';
                else if (broadcast === 'SBS SPORTS') broadcasterKey = 'sbs_sports';
                else if (broadcast === 'SPOTV') broadcasterKey = 'spotv';
                else if (broadcast === 'SPOTV2') broadcasterKey = 'spotv2';
                else if (broadcast === 'SBS TV') broadcasterKey = 'sbs_tv';
                else if (broadcast === 'KBS 2TV') broadcasterKey = 'kbs_2tv';
                else if (broadcast === 'MBC TV') broadcasterKey = 'mbc_tv';
                // TVING과 기타 중계사는 집계에서 제외

                if (broadcasterKey && broadcasterStats[broadcasterKey]) {
                    const stats = broadcasterStats[broadcasterKey];

                    // 승부 결과 계산
                    if (game.winner === teamName) {
                        stats.wins++;
                    } else if (game.winner && game.winner !== teamName) {
                        stats.losses++;
                    } else {
                        stats.draws++; // 무승부 또는 결과가 없는 경우
                    }
                }
            }
        });

        // 승률 계산
        Object.keys(broadcasterStats).forEach(key => {
            const stats = broadcasterStats[key];
            const totalGames = stats.wins + stats.losses;
            stats.winRate = totalGames > 0 ? stats.wins / totalGames : 0;
        });

        return broadcasterStats;
    }

    </script>

    <!-- AdSense Lazy Loading 스크립트 -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Intersection Observer로 AdSense 광고 lazy loading
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const adContainer = entry.target;
                    const adElement = adContainer.querySelector('.adsbygoogle');

                    if (adElement && !adElement.hasAttribute('data-loaded')) {
                        // 광고 로딩 마크
                        adElement.setAttribute('data-loaded', 'true');

                        // AdSense 광고 초기화 (이미 로드된 스크립트 사용)
                        try {
                            (window.adsbygoogle = window.adsbygoogle || []).push({});
                        } catch (e) {
                            console.warn('AdSense loading error:', e);
                        }

                        // 관찰 중단
                        observer.unobserve(adContainer);
                    }
                }
            });
        }, {
            rootMargin: '200px 0px', // 200px 전에 미리 로딩
            threshold: 0.1
        });

        // 모든 AdSense 광고 컨테이너 관찰
        document.querySelectorAll('.adsense-ad-wrapper').forEach(wrapper => {
            observer.observe(wrapper);
        });

        console.log('AdSense lazy loading 초기화 완료');
    });
    </script>

    <!-- ============================================================ -->

</body>
</html>