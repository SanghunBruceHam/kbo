
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KBO Food Chain — Circular (Interactive)</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#fff; }
  .container { max-width: 1100px; margin: 24px auto; }
  #chart { width: 100%; height: 900px; border: 1px solid #eee; border-radius: 12px; position: relative; }
  .node { cursor: pointer; }
  .edge-label { font-size: 10px; fill: #333; }
  .tooltip {
    position: absolute; padding: 6px 8px; background: rgba(0,0,0,0.8);
    color: #fff; border-radius: 6px; font-size: 12px; pointer-events: none; opacity: 0;
    transform: translate(-50%, -140%);
  }
  .controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }
  .update-info {
    font-size: 14px;
    color: #666;
  }
  button {
    padding: 8px 16px;
    background: #0066b3;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
  }
  button:hover {
    background: #0052a0;
  }
  .loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 16px;
    color: #666;
  }
</style>
</head>
<body>
<div class="container">
  <h2>KBO Food Chain — Circular (Interactive)</h2>
  <p>Node size = influence score (Out−In). Edge width = (Wins−Losses). Ties removed. Hover edges for W–L–T.</p>
  <div class="controls">
    <div class="update-info">
      마지막 업데이트: <span id="lastUpdate">-</span> |
      자동 새로고침: <span id="autoRefreshStatus">켜짐</span>
    </div>
    <div>
      <button id="refreshBtn">데이터 새로고침</button>
      <button id="toggleAutoRefresh">자동 새로고침 토글</button>
    </div>
  </div>
  <div id="chart">
    <div class="loading" style="display: none;">데이터 로딩 중...</div>
  </div>
  <div id="tooltip" class="tooltip"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
<script>
// 전역 설정
let autoRefreshInterval = null;
let autoRefreshEnabled = true;
const REFRESH_INTERVAL = 60000; // 1분마다 새로고침

// 차트 그리기 함수
function drawChart(data) {
  // 기존 SVG 제거
  d3.select('#chart svg').remove();

  const el = document.getElementById('chart');
  const width = el.clientWidth;
  const height = el.clientHeight || 900;

  const radius = Math.min(width, height) * 0.40;
  const centerX = width/2;
  const centerY = height/2;

  const svg = d3.select('#chart').append('svg')
    .attr('width', width)
    .attr('height', height);

  const defs = svg.append('defs');

  const uniqueColors = Array.from(new Set(data.edges.map(e => e.color)));
  uniqueColors.forEach((c,i) => {
    defs.append('marker')
      .attr('id', 'arrow-'+i)
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 12)
      .attr('refY', 0)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', c);
  });

  const colorToMarker = new Map(uniqueColors.map((c,i) => [c, 'url(#arrow-'+i+')']));

  const angleStep = (2*Math.PI) / data.nodes.length;
  data.nodes.forEach((n, i) => {
    n.x = centerX + radius*Math.cos(i*angleStep - Math.PI/2);
    n.y = centerY + radius*Math.sin(i*angleStep - Math.PI/2);
  });

  const nodeById = new Map(data.nodes.map(d => [d.id, d]));

  // 엣지 그리기
  const edges = svg.append('g').attr('class','edges')
    .selectAll('path')
    .data(data.edges)
    .enter().append('path')
    .attr('fill','none')
    .attr('stroke', d => d.color)
    .attr('stroke-width', d => d.width)
    .attr('marker-end', d => colorToMarker.get(d.color))
    .attr('d', d => {
        const s = nodeById.get(d.source), t = nodeById.get(d.target);
        const mx = (s.x + t.x) / 2, my = (s.y + t.y) / 2;
        const cx = (mx - centerX) * 1.15 + centerX;
        const cy = (my - centerY) * 1.15 + centerY;
        return `M ${s.x},${s.y} Q ${cx},${cy} ${t.x},${t.y}`;
    })
    .style('opacity', 0)
    .transition()
    .duration(800)
    .style('opacity', 1);

  const labels = svg.append('g').attr('class','edge-labels')
    .selectAll('text')
    .data(data.edges)
    .enter().append('text')
    .attr('class','edge-label')
    .attr('text-anchor','middle')
    .attr('x', d => (nodeById.get(d.source).x + nodeById.get(d.target).x)/2)
    .attr('y', d => (nodeById.get(d.source).y + nodeById.get(d.target).y)/2)
    .text(d => d.label)
    .style('opacity', 0)
    .transition()
    .delay(400)
    .duration(600)
    .style('opacity', 1);

  const tip = d3.select('#tooltip');
  edges
    .on('mousemove', (event,d) => {
       tip.style('opacity', 1)
          .style('left', (event.pageX)+'px')
          .style('top', (event.pageY-10)+'px')
          .html(`<strong>${d.source} → ${d.target}</strong><br/>${d.label}`);
    })
    .on('mouseleave', () => tip.style('opacity', 0));

  // 노드 그리기
  const nodes = svg.append('g').attr('class','nodes')
    .selectAll('g')
    .data(data.nodes)
    .enter().append('g')
    .attr('class','node')
    .attr('transform', d => `translate(${d.x},${d.y})`)
    .style('opacity', 0);

  // 배경 원 (테두리 효과)
  nodes.append('circle')
    .attr('r', d => d.radius)
    .attr('fill', '#fff')
    .attr('stroke', d => d.color)
    .attr('stroke-width', 3);

  // 클리핑 패스 정의 (원형 마스크)
  nodes.append('clipPath')
    .attr('id', d => 'clip-' + d.id)
    .append('circle')
    .attr('r', d => d.radius - 1);

  // 팀 로고 이미지
  nodes.append('image')
    .attr('xlink:href', d => d.logo)
    .attr('x', d => -d.radius)
    .attr('y', d => -d.radius)
    .attr('width', d => d.radius * 2)
    .attr('height', d => d.radius * 2)
    .attr('clip-path', d => 'url(#clip-' + d.id + ')')
    .attr('preserveAspectRatio', 'xMidYMid meet');

  nodes.append('title')
    .text(d => `${d.id} — score: ${d.score}`);

  // 노드 페이드인 애니메이션
  nodes.transition()
    .delay((d, i) => i * 50)
    .duration(500)
    .style('opacity', 1);
}

// 데이터 로드 함수
async function loadData() {
  const loadingEl = document.querySelector('.loading');
  loadingEl.style.display = 'block';

  try {
    // 캐시 방지를 위해 타임스탬프 추가
    const response = await fetch(`kbo-food-chain-data.json?t=${Date.now()}`);
    const data = await response.json();

    // 차트 그리기
    drawChart(data);

    // 업데이트 시간 표시
    if (data.lastUpdate) {
      const date = new Date(data.lastUpdate);
      const dateStr = date.toLocaleDateString('ko-KR') + ' ' + date.toLocaleTimeString('ko-KR');
      document.getElementById('lastUpdate').textContent = dateStr;
    }

  } catch (error) {
    console.error('데이터 로드 실패:', error);
    alert('데이터를 불러올 수 없습니다.');
  } finally {
    loadingEl.style.display = 'none';
  }
}

// 자동 새로고침 토글
function toggleAutoRefresh() {
  autoRefreshEnabled = !autoRefreshEnabled;
  document.getElementById('autoRefreshStatus').textContent = autoRefreshEnabled ? '켜짐' : '꺼짐';

  if (autoRefreshEnabled) {
    startAutoRefresh();
  } else {
    stopAutoRefresh();
  }
}

// 자동 새로고침 시작
function startAutoRefresh() {
  stopAutoRefresh(); // 기존 인터벌 제거
  autoRefreshInterval = setInterval(() => {
    if (autoRefreshEnabled) {
      loadData();
    }
  }, REFRESH_INTERVAL);
}

// 자동 새로고침 중지
function stopAutoRefresh() {
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
}

// 이벤트 리스너 등록
document.getElementById('refreshBtn').addEventListener('click', loadData);
document.getElementById('toggleAutoRefresh').addEventListener('click', toggleAutoRefresh);

// 페이지 로드시 초기화
window.addEventListener('load', () => {
  loadData();
  startAutoRefresh();
});

// 페이지 떠날 때 인터벌 정리
window.addEventListener('beforeunload', () => {
  stopAutoRefresh();
});
</script>
</body>
</html>
