const fs = require('fs');
const path = require('path');

class EnhancedDashboardGenerator {
    constructor() {
        this.games = [];
        this.teams = ['KIA', 'LG', 'ÏÇºÏÑ±', 'ÎëêÏÇ∞', 'KT', 'SSG', 'Î°ØÎç∞', 'ÌïúÌôî', 'NC', 'ÌÇ§ÏõÄ'];
        this.stadiums = {
            'KIA': 'Í¥ëÏ£º Ï±îÌîºÏñ∏Ïä§ÌïÑÎìú',
            'LG': 'ÏÑúÏö∏ Ïû†Ïã§ÏïºÍµ¨Ïû•',
            'ÎëêÏÇ∞': 'ÏÑúÏö∏ Ïû†Ïã§ÏïºÍµ¨Ïû•',
            'ÏÇºÏÑ±': 'ÎåÄÍµ¨ ÏÇºÏÑ±ÎùºÏù¥Ïò®Ï¶àÌååÌÅ¨',
            'SSG': 'Ïù∏Ï≤ú SSGÎûúÎçîÏä§ÌïÑÎìú',
            'KT': 'ÏàòÏõê KTÏúÑÏ¶àÌååÌÅ¨',
            'NC': 'Ï∞ΩÏõê NCÌååÌÅ¨',
            'Î°ØÎç∞': 'Î∂ÄÏÇ∞ ÏÇ¨ÏßÅÏïºÍµ¨Ïû•',
            'ÌïúÌôî': 'ÎåÄÏ†Ñ ÌïúÌôîÏÉùÎ™ÖÏù¥Í∏ÄÏä§ÌååÌÅ¨',
            'ÌÇ§ÏõÄ': 'ÏÑúÏö∏ Í≥†Ï≤ôÏä§Ïπ¥Ïù¥Îèî'
        };
    }

    async loadGames() {
        try {
            // 2025-season-games.json ÌååÏùº Î°úÎìú
            const gamesPath = path.join(__dirname, '../data/2025-season-games.json');
            if (!fs.existsSync(gamesPath)) {
                // ÌååÏùºÏù¥ ÏóÜÏúºÎ©¥ season-data-parserÎ°ú ÏÉùÏÑ±
                const { parseSeasonData } = require('./03_season-data-parser');
                parseSeasonData();
            }
            const gamesData = fs.readFileSync(gamesPath, 'utf-8');
            const allGames = JSON.parse(gamesData);

            // ÌéòÎÑåÌä∏Î†àÏù¥Ïä§Ïù¥Î©¥ÏÑú ÏôÑÎ£åÎêú Í≤ΩÍ∏∞Îßå ÌïÑÌÑ∞ÎßÅ
            this.games = allGames.filter(game =>
                game.category && game.category.includes('ÌéòÎÑåÌä∏Î†àÏù¥Ïä§') &&
                game.state && game.state === 'Ï¢ÖÎ£å'
            );

            console.log(`‚úÖ Ï†ÑÏ≤¥ ${allGames.length}Í∞ú Ï§ë ÌéòÎÑåÌä∏Î†àÏù¥Ïä§ ${this.games.length}Í∞ú Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å`);
        } catch (error) {
            console.error('‚ùå Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
            throw error;
        }
    }

    getDayOfWeek(date) {
        const days = ['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'];
        const d = new Date(date);
        return days[d.getDay()];
    }

    getStadium(homeTeam) {
        return this.stadiums[homeTeam] || 'ÎØ∏ÏÉÅ';
    }

    async generateComprehensiveDashboard() {
        // Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        await this.loadGames();
        
        const dashboard = {
            updateTime: new Date().toISOString(),
            updateDate: new Date().toLocaleDateString('ko-KR', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                timeZone: 'Asia/Seoul'
            }),
            
            // 1. Ï¢ÖÌï© ÏàúÏúÑ
            standings: this.getStandings(),
            
            // 2. ÌîºÌÉÄÍ≥†Î¶¨Ïïà Í∏∞ÎåÄÏäπÎ•† & Ïö¥ ÏßÄÏàò
            pythagoreanAnalysis: this.getPythagoreanAnalysis(),
            
            // 3. 1Ï†êÏ∞® Í≤ΩÍ∏∞ ÏäπÎ•†
            oneRunGames: this.getOneRunGames(),
            
            // 4. Ìôà/ÏõêÏ†ï ÏÑ±Ï†Å
            homeAwayStats: this.getHomeAwayStats(),
            
            // 5. ÏõîÎ≥Ñ ÏäπÎ•† (NEW)
            monthlyPerformance: this.getMonthlyPerformance(),
            
            // 6. ÏöîÏùºÎ≥Ñ ÏäπÎ•† (NEW)
            weekdayPerformance: this.getWeekdayPerformance(),
            
            // 7. Í≤ΩÍ∏∞Ïû•Î≥Ñ ÏÑ±Ï†Å (NEW)
            stadiumRecords: this.getStadiumRecords(),
            
            // 8. ÏãúÎ¶¨Ï¶à Í∏∞Î°ù (NEW)
            seriesRecords: this.getSeriesRecords(),
            
            // 9. ÏÉÅÎåÄÏ†ÑÏ†Å Îß§Ìä∏Î¶≠Ïä§
            headToHeadMatrix: this.getHeadToHeadMatrix(),
            
            // 10. Ïó∞Ïäπ/Ïó∞Ìå® ÌòÑÌô©
            streakAnalysis: this.getStreakAnalysis(),
            
            // 11. ÎìùÏã§Ï†ê Î∂ÑÏÑù
            runAnalysis: this.getRunAnalysis(),
            
            // 12. ÏÉÅÏúÑÍ∂å/ÌïòÏúÑÍ∂å ÏÉÅÎåÄ ÏäπÎ•†
            vsLevelAnalysis: this.getVsLevelAnalysis(),
            
            // 13. ÌäπÏàò ÏÉÅÌô© ÌÜµÍ≥Ñ
            specialSituations: this.getSpecialSituations(),
            
            // 14. ÌåÄÎ≥Ñ Ï£ºÏöî ÏßÄÌëú ÏöîÏïΩ
            teamSummaries: this.getTeamSummaries()
        };
        
        // JSON ÌååÏùºÎ°ú Ï†ÄÏû•
        const outputPath = path.join(__dirname, '../data/stats-comprehensive.json');
        fs.writeFileSync(outputPath, JSON.stringify(dashboard, null, 2));
        console.log(`üìä Enhanced ÎåÄÏãúÎ≥¥Îìú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±: ${outputPath}`);
        
        return dashboard;
    }

    calculateCurrentStreak(teamName) {
        // ÏµúÍ∑º Í≤ΩÍ∏∞Îì§ Í∞ÄÏ†∏Ïò§Í∏∞ (ÎÇ†Ïßú Ïó≠Ïàú)
        const recentGames = this.games
            .filter(g => g.home_team === teamName || g.away_team === teamName)
            .sort((a, b) => new Date(b.date) - new Date(a.date));
        
        let streak = 0;
        let streakType = null;
        
        for (const game of recentGames) {
            if (game.winner === 'draw') continue; // Î¨¥ÏäπÎ∂ÄÎäî Í±¥ÎÑàÎõ∞Í∏∞
            
            const isWin = game.winner === teamName;
            
            if (streakType === null) {
                streakType = isWin ? 'W' : 'L';
                streak = 1;
            } else if ((streakType === 'W' && isWin) || (streakType === 'L' && !isWin)) {
                streak++;
            } else {
                break; // Ïó∞Ïäπ/Ïó∞Ìå® Ï¢ÖÎ£å
            }
        }
        
        return streak > 0 ? `${streak}${streakType}` : '0';
    }

    getStandings() {
        const teamStats = {};
        
        // ÌåÄ Ï¥àÍ∏∞Ìôî
        this.teams.forEach(team => {
            teamStats[team] = {
                team_name: team,
                games_played: 0,
                wins: 0,
                losses: 0,
                draws: 0,
                runs_scored: 0,
                runs_allowed: 0
            };
        });
        
        // Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞Î°ú ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        this.games.forEach(game => {
            const { home_team, away_team, home_score, away_score, winner } = game;
            
            // ÌôàÌåÄ Ï≤òÎ¶¨
            if (teamStats[home_team]) {
                teamStats[home_team].games_played++;
                teamStats[home_team].runs_scored += home_score;
                teamStats[home_team].runs_allowed += away_score;
                
                if (winner === home_team) teamStats[home_team].wins++;
                else if (winner === away_team) teamStats[home_team].losses++;
                else teamStats[home_team].draws++;
            }
            
            // ÏõêÏ†ïÌåÄ Ï≤òÎ¶¨
            if (teamStats[away_team]) {
                teamStats[away_team].games_played++;
                teamStats[away_team].runs_scored += away_score;
                teamStats[away_team].runs_allowed += home_score;
                
                if (winner === away_team) teamStats[away_team].wins++;
                else if (winner === home_team) teamStats[away_team].losses++;
                else teamStats[away_team].draws++;
            }
        });
        
        // ÏäπÎ•† Î∞è Îü∞ ÎîîÌçºÎü∞ÏÖú Í≥ÑÏÇ∞
        const standings = Object.values(teamStats).map(team => {
            const winRate = team.wins + team.losses > 0 ? team.wins / (team.wins + team.losses) : 0;
            const currentStreak = this.calculateCurrentStreak(team.team_name);
            
            return {
                ...team,
                win_rate: winRate.toFixed(3),
                run_differential: team.runs_scored - team.runs_allowed,
                current_streak: currentStreak
            };
        });
        
        // ÏäπÎ•† Ïàú Ï†ïÎ†¨
        standings.sort((a, b) => {
            const aRate = parseFloat(a.win_rate);
            const bRate = parseFloat(b.win_rate);
            if (aRate !== bRate) return bRate - aRate;
            return b.wins - a.wins;
        });
        
        // Í≤åÏûÑÏ∞® Í≥ÑÏÇ∞
        const leader = standings[0];
        return standings.map((team, index) => ({
            rank: index + 1,
            ...team,
            games_behind: index === 0 ? '-' : 
                ((leader.wins - team.wins) + (team.losses - leader.losses)) / 2
        }));
    }

    calculatePythagorean(runsScored, runsAllowed) {
        if (runsAllowed === 0) return 1;
        return Math.pow(runsScored, 2) / (Math.pow(runsScored, 2) + Math.pow(runsAllowed, 2));
    }
    
    getPythagoreanAnalysis() {
        const standings = this.getStandings();
        
        return standings.map(team => {
            const expectedWinRate = this.calculatePythagorean(team.runs_scored, team.runs_allowed);
            const actualWinRate = parseFloat(team.win_rate);
            const luckFactor = actualWinRate - expectedWinRate;
            
            let luckStatus;
            if (luckFactor > 0.05) luckStatus = 'Ïö¥Ïù¥ Ï¢ãÏùå';
            else if (luckFactor < -0.05) luckStatus = 'Ïö¥Ïù¥ ÎÇòÏÅ®';
            else luckStatus = 'ÌèâÍ∑†Ï†Å';
            
            return {
                team_name: team.team_name,
                actual_win_rate: team.win_rate,
                expected_win_rate: expectedWinRate.toFixed(3),
                luck_factor: (luckFactor >= 0 ? '+' : '') + luckFactor.toFixed(3),
                luck_status: luckStatus
            };
        });
    }

    getOneRunGames() {
        const oneRunStats = {};
        
        // ÌåÄ Ï¥àÍ∏∞Ìôî
        this.teams.forEach(team => {
            oneRunStats[team] = { wins: 0, losses: 0 };
        });
        
        // 1Ï†êÏ∞® Í≤ΩÍ∏∞ Ï∞æÍ∏∞
        this.games.forEach(game => {
            const scoreDiff = Math.abs(game.home_score - game.away_score);
            if (scoreDiff === 1 && game.winner !== 'draw') {
                if (game.winner === game.home_team) {
                    oneRunStats[game.home_team].wins++;
                    oneRunStats[game.away_team].losses++;
                } else {
                    oneRunStats[game.away_team].wins++;
                    oneRunStats[game.home_team].losses++;
                }
            }
        });
        
        // Í≤∞Í≥º Ï†ïÎ¶¨
        const results = [];
        for (const [team, stats] of Object.entries(oneRunStats)) {
            const totalGames = stats.wins + stats.losses;
            if (totalGames > 0) {
                results.push({
                    team_name: team,
                    wins: stats.wins,
                    losses: stats.losses,
                    total_games: totalGames,
                    win_rate: (stats.wins / totalGames).toFixed(3)
                });
            }
        }
        
        return results.sort((a, b) => parseFloat(b.win_rate) - parseFloat(a.win_rate));
    }

    getHomeAwayStats() {
        const homeAwayStats = {};

        // Ïã§Ï†ú Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÌåÄ Ïù¥Î¶Ñ ÏàòÏßë
        const actualTeams = new Set();
        this.games.forEach(game => {
            actualTeams.add(game.home_team);
            actualTeams.add(game.away_team);
        });

        // ÌåÄ Ï¥àÍ∏∞Ìôî (Ïã§Ï†ú ÌåÄ Ïù¥Î¶Ñ ÏÇ¨Ïö©)
        Array.from(actualTeams).forEach(team => {
            homeAwayStats[team] = {
                home_wins: 0, home_losses: 0,
                away_wins: 0, away_losses: 0
            };
        });

        // Ìôà/ÏõêÏ†ï ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        this.games.forEach(game => {
            if (game.winner === 'draw') return;

            // ÌåÄÏù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏ ÌõÑ Ï≤òÎ¶¨
            if (homeAwayStats[game.home_team] && homeAwayStats[game.away_team]) {
                if (game.winner === game.home_team) {
                    homeAwayStats[game.home_team].home_wins++;
                    homeAwayStats[game.away_team].away_losses++;
                } else {
                    homeAwayStats[game.away_team].away_wins++;
                    homeAwayStats[game.home_team].home_losses++;
                }
            }
        });
        
        // Í≤∞Í≥º Ï†ïÎ¶¨
        const standings = this.getStandings();
        return standings.map(team => {
            const stats = homeAwayStats[team.team_name];
            const homeWinRate = stats.home_wins + stats.home_losses > 0 ? 
                stats.home_wins / (stats.home_wins + stats.home_losses) : 0;
            const awayWinRate = stats.away_wins + stats.away_losses > 0 ? 
                stats.away_wins / (stats.away_wins + stats.away_losses) : 0;
            const homeAdvantage = homeWinRate - awayWinRate;
            
            return {
                team_name: team.team_name,
                home_wins: stats.home_wins,
                home_losses: stats.home_losses,
                home_win_rate: homeWinRate.toFixed(3),
                away_wins: stats.away_wins,
                away_losses: stats.away_losses,
                away_win_rate: awayWinRate.toFixed(3),
                home_advantage: (homeAdvantage >= 0 ? '+' : '') + homeAdvantage.toFixed(3)
            };
        });
    }

    getMonthlyPerformance() {
        const monthlyStats = {};

        // Ïã§Ï†ú Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÌåÄ Ïù¥Î¶Ñ ÏàòÏßë
        const actualTeams = new Set();
        this.games.forEach(game => {
            actualTeams.add(game.home_team);
            actualTeams.add(game.away_team);
        });

        // ÌåÄ/Ïõî Îã®ÏúÑÎ°ú Ï¥àÍ∏∞Ìôî
        Array.from(actualTeams).forEach(team => {
            monthlyStats[team] = {};
        });
        
        // Í∞Å Í≤ΩÍ∏∞ ÏõîÎ≥Ñ Ï≤òÎ¶¨
        this.games.forEach(game => {
            const date = new Date(game.date);
            const month = date.getMonth() + 1; // 1-12Ïõî
            
            // ÌôàÌåÄ Ï≤òÎ¶¨
            if (monthlyStats[game.home_team]) {
                if (!monthlyStats[game.home_team][month]) {
                    monthlyStats[game.home_team][month] = {
                        wins: 0, losses: 0, draws: 0,
                        runs_scored: 0, runs_allowed: 0
                    };
                }
                const homeStats = monthlyStats[game.home_team][month];
                homeStats.runs_scored += game.home_score;
                homeStats.runs_allowed += game.away_score;

                if (game.winner === game.home_team) homeStats.wins++;
                else if (game.winner === game.away_team) homeStats.losses++;
                else homeStats.draws++;
            }

            // ÏõêÏ†ïÌåÄ Ï≤òÎ¶¨
            if (monthlyStats[game.away_team]) {
                if (!monthlyStats[game.away_team][month]) {
                    monthlyStats[game.away_team][month] = {
                        wins: 0, losses: 0, draws: 0,
                        runs_scored: 0, runs_allowed: 0
                    };
                }
                const awayStats = monthlyStats[game.away_team][month];
                awayStats.runs_scored += game.away_score;
                awayStats.runs_allowed += game.home_score;

                if (game.winner === game.away_team) awayStats.wins++;
                else if (game.winner === game.home_team) awayStats.losses++;
                else awayStats.draws++;
            }
        });
        
        // Í≤∞Í≥º Ï†ïÎ¶¨ - JSON Íµ¨Ï°∞Ïóê ÎßûÏ∂ò
        const result = {};
        this.teams.forEach(team => {
            result[team] = [];
            
            for (let month = 1; month <= 12; month++) {
                if (monthlyStats[team][month]) {
                    const stats = monthlyStats[team][month];
                    const games = stats.wins + stats.losses + stats.draws;
                    const winRate = stats.wins + stats.losses > 0 ? 
                        (stats.wins / (stats.wins + stats.losses)).toFixed(3) : '0.000';
                    
                    result[team].push({
                        month,
                        wins: stats.wins,
                        losses: stats.losses,
                        draws: stats.draws,
                        games,
                        win_rate: winRate,
                        runs_scored: stats.runs_scored,
                        runs_allowed: stats.runs_allowed
                    });
                }
            }
        });
        
        return result;
    }

    getWeekdayPerformance() {
        const weekdayStats = {};

        // Ïã§Ï†ú Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÌåÄ Ïù¥Î¶Ñ ÏàòÏßë
        const actualTeams = new Set();
        this.games.forEach(game => {
            actualTeams.add(game.home_team);
            actualTeams.add(game.away_team);
        });

        // ÌåÄ/ÏöîÏùº Îã®ÏúÑÎ°ú Ï¥àÍ∏∞Ìôî
        Array.from(actualTeams).forEach(team => {
            weekdayStats[team] = {};
            ['Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†', 'Ïùº'].forEach(day => {
                weekdayStats[team][day] = { wins: 0, losses: 0, draws: 0 };
            });
        });
        
        // Í∞Å Í≤ΩÍ∏∞ ÏöîÏùºÎ≥Ñ Ï≤òÎ¶¨
        this.games.forEach(game => {
            const dayOfWeek = this.getDayOfWeek(game.date);
            
            // ÌôàÌåÄ Ï≤òÎ¶¨
            if (weekdayStats[game.home_team] && weekdayStats[game.home_team][dayOfWeek]) {
                if (game.winner === game.home_team) {
                    weekdayStats[game.home_team][dayOfWeek].wins++;
                } else if (game.winner === game.away_team) {
                    weekdayStats[game.home_team][dayOfWeek].losses++;
                } else {
                    weekdayStats[game.home_team][dayOfWeek].draws++;
                }
            }

            // ÏõêÏ†ïÌåÄ Ï≤òÎ¶¨
            if (weekdayStats[game.away_team] && weekdayStats[game.away_team][dayOfWeek]) {
                if (game.winner === game.away_team) {
                    weekdayStats[game.away_team][dayOfWeek].wins++;
                } else if (game.winner === game.home_team) {
                    weekdayStats[game.away_team][dayOfWeek].losses++;
                } else {
                    weekdayStats[game.away_team][dayOfWeek].draws++;
                }
            }
        });
        
        // ÏäπÎ•† Í≥ÑÏÇ∞ - JSON Íµ¨Ï°∞Ïóê ÎßûÏ∂ò
        const result = {};
        this.teams.forEach(team => {
            result[team] = {};
            ['Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†', 'Ïùº'].forEach(day => {
                const stats = weekdayStats[team][day];
                if (stats.wins + stats.losses + stats.draws > 0) {
                    const winRate = stats.wins + stats.losses > 0 ?
                        (stats.wins / (stats.wins + stats.losses)).toFixed(3) : '0.000';
                    
                    result[team][day] = {
                        wins: stats.wins,
                        losses: stats.losses,
                        draws: stats.draws,
                        win_rate: winRate
                    };
                }
            });
        });
        
        return result;
    }
    
    getStadiumRecords() {
        const stadiumStats = {};

        // Ïã§Ï†ú Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÌåÄ Ïù¥Î¶Ñ ÏàòÏßë
        const actualTeams = new Set();
        this.games.forEach(game => {
            actualTeams.add(game.home_team);
            actualTeams.add(game.away_team);
        });

        // ÌåÄ/Í≤ΩÍ∏∞Ïû• Îã®ÏúÑÎ°ú Ï¥àÍ∏∞Ìôî
        actualTeams.forEach(team => {
            stadiumStats[team] = {};
        });

        // Í∞Å Í≤ΩÍ∏∞ Í≤ΩÍ∏∞Ïû•Î≥Ñ Ï≤òÎ¶¨
        this.games.forEach(game => {
            const stadium = this.getStadium(game.home_team);

            // ÌôàÌåÄ Ï≤òÎ¶¨
            if (stadiumStats[game.home_team] && !stadiumStats[game.home_team][stadium]) {
                stadiumStats[game.home_team][stadium] = { wins: 0, losses: 0, draws: 0 };
            }
            
            if (stadiumStats[game.home_team] && stadiumStats[game.home_team][stadium]) {
                if (game.winner === game.home_team) {
                    stadiumStats[game.home_team][stadium].wins++;
                } else if (game.winner === game.away_team) {
                    stadiumStats[game.home_team][stadium].losses++;
                } else {
                    stadiumStats[game.home_team][stadium].draws++;
                }
            }

            // ÏõêÏ†ïÌåÄ Ï≤òÎ¶¨
            if (stadiumStats[game.away_team] && !stadiumStats[game.away_team][stadium]) {
                stadiumStats[game.away_team][stadium] = { wins: 0, losses: 0, draws: 0 };
            }

            if (stadiumStats[game.away_team] && stadiumStats[game.away_team][stadium]) {
                if (game.winner === game.away_team) {
                    stadiumStats[game.away_team][stadium].wins++;
                } else if (game.winner === game.home_team) {
                    stadiumStats[game.away_team][stadium].losses++;
                } else {
                    stadiumStats[game.away_team][stadium].draws++;
                }
            }
        });
        
        // Í≤∞Í≥º Ï†ïÎ¶¨ - JSON Íµ¨Ï°∞Ïóê ÎßûÏ∂§
        const result = {};
        actualTeams.forEach(team => {
            result[team] = [];

            if (stadiumStats[team]) {
                Object.entries(stadiumStats[team]).forEach(([stadium, stats]) => {
                    if (stats.wins + stats.losses + stats.draws > 0) {
                        const winRate = stats.wins + stats.losses > 0 ?
                            (stats.wins / (stats.wins + stats.losses)).toFixed(3) : '0.000';

                        result[team].push({
                            stadium,
                            wins: stats.wins,
                            losses: stats.losses,
                            draws: stats.draws,
                            win_rate: winRate
                        });
                    }
                });
            }
        });
        
        return result;
    }

    getHeadToHeadMatrix() {
        const teams = ['KIA', 'LG', 'ÏÇºÏÑ±', 'ÎëêÏÇ∞', 'KT', 'SSG', 'Î°ØÎç∞', 'ÌïúÌôî', 'NC', 'ÌÇ§ÏõÄ'];
        const matrix = {};
        
        teams.forEach(team => {
            matrix[team] = {};
            teams.forEach(opponent => {
                if (team === opponent) {
                    matrix[team][opponent] = '-';
                    return;
                }
                
                let wins = 0, losses = 0;
                this.games.forEach(game => {
                    if ((game.home_team === team && game.away_team === opponent) ||
                        (game.away_team === team && game.home_team === opponent)) {
                        if (game.winner === team) wins++;
                        else if (game.winner === opponent) losses++;
                    }
                });
                
                matrix[team][opponent] = {
                    record: `${wins}-${losses}`,
                    win_rate: wins + losses > 0 ? (wins / (wins + losses)).toFixed(3) : '0.000'
                };
            });
        });
        
        return matrix;
    }

    getStreakAnalysis() {
        try {
            // raw-game-records.jsonÏóêÏÑú ÏßÅÏ†ë Ïó∞Ïäπ/Ïó∞Ìå® Í≥ÑÏÇ∞
            const rawPath = path.join(__dirname, '../data/raw-game-records.json');
            if (fs.existsSync(rawPath)) {
                const rawData = JSON.parse(fs.readFileSync(rawPath, 'utf8'));
                
                return this.teams.map(teamName => {
                    const teamGames = rawData[teamName]?.games || [];
                    
                    // ÎÇ†ÏßúÏàúÏúºÎ°ú Ï†ïÎ†¨
                    const sortedGames = teamGames
                        .filter(g => g.date && (g.result === 'W' || g.result === 'L'))
                        .sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    let maxWinStreak = 0;
                    let maxLoseStreak = 0;
                    let currentStreak = 0;
                    let currentType = null;
                    let lastResult = null;
                    
                    // ÏµúÎåÄ Ïó∞Ïäπ/Ïó∞Ìå® Í≥ÑÏÇ∞
                    sortedGames.forEach(game => {
                        if (game.result === lastResult) {
                            currentStreak++;
                        } else {
                            // Ïó∞ÏÜç Í∏∞Î°ù Ï¢ÖÎ£å, ÏµúÎåÄÍ∞í ÏóÖÎç∞Ïù¥Ìä∏
                            if (lastResult === 'W') {
                                maxWinStreak = Math.max(maxWinStreak, currentStreak);
                            } else if (lastResult === 'L') {
                                maxLoseStreak = Math.max(maxLoseStreak, currentStreak);
                            }
                            
                            // ÏÉàÎ°úÏö¥ Ïó∞ÏÜç ÏãúÏûë
                            currentStreak = 1;
                            lastResult = game.result;
                        }
                    });
                    
                    // ÎßàÏßÄÎßâ Ïó∞ÏÜç Í∏∞Î°ù Ï≤òÎ¶¨
                    if (lastResult === 'W') {
                        maxWinStreak = Math.max(maxWinStreak, currentStreak);
                    } else if (lastResult === 'L') {
                        maxLoseStreak = Math.max(maxLoseStreak, currentStreak);
                    }
                    
                    // ÌòÑÏû¨ Ïó∞ÏÜç ÏÉÅÌÉú Í≥ÑÏÇ∞
                    let currentStreakDisplay = '-';
                    if (sortedGames.length > 0) {
                        const recentGames = sortedGames.slice(-10); // ÏµúÍ∑º 10Í≤ΩÍ∏∞
                        let recentStreak = 0;
                        let recentType = null;
                        
                        // Îí§ÏóêÏÑúÎ∂ÄÌÑ∞ Í∞ôÏùÄ Í≤∞Í≥º Ïπ¥Ïö¥Ìä∏
                        for (let i = recentGames.length - 1; i >= 0; i--) {
                            if (recentType === null) {
                                recentType = recentGames[i].result;
                                recentStreak = 1;
                            } else if (recentGames[i].result === recentType) {
                                recentStreak++;
                            } else {
                                break;
                            }
                        }
                        
                        if (recentType) {
                            currentStreakDisplay = `${recentStreak}${recentType}`;
                        }
                    }
                    
                    console.log(`‚úÖ ${teamName} Ïó∞ÏÜçÍ∏∞Î°ù Í≥ÑÏÇ∞: ÏµúÎåÄÏó∞Ïäπ ${maxWinStreak}, ÏµúÎåÄÏó∞Ìå® ${maxLoseStreak}, ÌòÑÏû¨ ${currentStreakDisplay}`);
                    
                    return {
                        team_name: teamName,
                        current_streak: currentStreakDisplay,
                        max_win_streak: maxWinStreak,
                        max_lose_streak: maxLoseStreak,
                        streak_status: currentStreakDisplay.includes('W') ? 'Ïó∞Ïäπ Ï§ë' : 
                                     currentStreakDisplay.includes('L') ? 'Ïó∞Ìå® Ï§ë' : '-'
                    };
                });
            }
        } catch (e) {
            console.error('Ïó∞Ïäπ/Ïó∞Ìå® Îç∞Ïù¥ÌÑ∞ Í≥ÑÏÇ∞ Ïò§Î•ò:', e.message);
        }
        
        // fallback: Îπà Îç∞Ïù¥ÌÑ∞ Î∞òÌôò
        return this.teams.map(teamName => ({
            team_name: teamName,
            current_streak: '-',
            max_win_streak: 0,
            max_lose_streak: 0,
            streak_status: '-'
        }));
    }

    getRunAnalysis() {
        try {
            const statsPath = path.join(__dirname, '../data/2025-team-stats.json');
            if (fs.existsSync(statsPath)) {
                const stats = JSON.parse(fs.readFileSync(statsPath, 'utf8'));
                return Object.values(stats)
                    .map(team => ({
                        team_name: team.team_name,
                        runs_scored: team.runs_scored || 0,
                        runs_allowed: team.runs_allowed || 0,
                        run_differential: team.run_differential || 0,
                        avg_runs_scored: team.games_played ? (team.runs_scored / team.games_played).toFixed(2) : '0.00',
                        avg_runs_allowed: team.games_played ? (team.runs_allowed / team.games_played).toFixed(2) : '0.00',
                        avg_run_diff: team.games_played ? (team.run_differential / team.games_played).toFixed(2) : '0.00'
                    }))
                    .sort((a, b) => b.run_differential - a.run_differential);
            }
        } catch (e) {
            console.log('ÎìùÏã§Ï†ê Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
        }
        return [];
    }

    getVsLevelAnalysis() {
        // 2025-team-stats.jsonÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
        try {
            const statsPath = path.join(__dirname, '../data/2025-team-stats.json');
            if (fs.existsSync(statsPath)) {
                const stats = JSON.parse(fs.readFileSync(statsPath, 'utf8'));
                return Object.values(stats).map(team => ({
                    team_name: team.team_name,
                    vs_above_wins: team.vs_above_500_wins || 0,
                    vs_above_losses: team.vs_above_500_losses || 0,
                    vs_above_win_rate: team.vs_above_500_win_rate || '0.000',
                    vs_below_wins: team.vs_below_500_wins || 0,
                    vs_below_losses: team.vs_below_500_losses || 0,
                    vs_below_win_rate: team.vs_below_500_win_rate || '0.000'
                }));
            }
        } catch (e) {
            console.log('ÌåÄ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
        }
        return [];
    }

    getSpecialSituations() {
        try {
            const statsPath = path.join(__dirname, '../data/2025-team-stats.json');
            if (fs.existsSync(statsPath)) {
                const stats = JSON.parse(fs.readFileSync(statsPath, 'utf8'));
                return Object.values(stats).map(team => ({
                    team_name: team.team_name,
                    blowout_wins: team.blowout_wins || 0,
                    blowout_losses: team.blowout_losses || 0,
                    shutout_wins: team.shutout_wins || 0,
                    shutout_losses: team.shutout_losses || 0,
                    close_games: (team.one_run_games_won || 0) + (team.one_run_games_lost || 0),
                    blowout_games: (team.blowout_wins || 0) + (team.blowout_losses || 0),
                    shutout_games: (team.shutout_wins || 0) + (team.shutout_losses || 0)
                }));
            }
        } catch (e) {
            console.log('ÌäπÏàò ÏÉÅÌô© Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
        }
        return [];
    }

    getSeriesRecords() {
        // series_recordsÎäî analysis-series.jsonÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
        try {
            const seriesPath = path.join(__dirname, '../data/analysis-series.json');
            if (fs.existsSync(seriesPath)) {
                const seriesData = JSON.parse(fs.readFileSync(seriesPath, 'utf8'));
                return seriesData.teamStats || {};
            }
        } catch (e) {
            console.log('ÏãúÎ¶¨Ï¶à Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå, Îπà Í∞ùÏ≤¥ Î∞òÌôò');
        }
        return {};
    }

    getTeamSummaries() {
        try {
            const statsPath = path.join(__dirname, '../data/2025-team-stats.json');
            if (fs.existsSync(statsPath)) {
                const teams = JSON.parse(fs.readFileSync(statsPath, 'utf8'));
                const sortedTeams = Object.values(teams).sort((a, b) => parseFloat(b.win_rate) - parseFloat(a.win_rate));
                
                return sortedTeams.map(team => ({
            team_name: team.team_name,
            overall: {
                record: `${team.wins}Ïäπ ${team.draws}Î¨¥ ${team.losses}Ìå®`,
                win_rate: team.win_rate.toFixed(3),
                games_behind: 0 // Í≥ÑÏÇ∞ ÌïÑÏöî
            },
            pythagorean: {
                expected: team.pythagorean_expectation.toFixed(3),
                actual: team.win_rate.toFixed(3),
                luck_factor: team.luck_factor.toFixed(3)
            },
            situational: {
                one_run: `${team.one_run_games_won}-${team.one_run_games_lost}`,
                one_run_rate: team.one_run_win_rate.toFixed(3),
                blowout: `${team.blowout_wins}-${team.blowout_losses}`,
                shutout: `${team.shutout_wins}-${team.shutout_losses}`
            },
            home_away: {
                home: `${team.home_wins}-${team.home_losses} (${team.home_win_rate.toFixed(3)})`,
                away: `${team.away_wins}-${team.away_losses} (${team.away_win_rate.toFixed(3)})`,
                advantage: team.home_advantage_index.toFixed(3)
            },
            vs_level: {
                above_500: `${team.vs_above_500_wins}-${team.vs_above_500_losses}`,
                below_500: `${team.vs_below_500_wins}-${team.vs_below_500_losses}`
            },
            streaks: {
                current: team.current_streak,
                max_win: team.max_win_streak,
                max_lose: team.max_lose_streak
            },
            runs: {
                scored: team.runs_scored,
                allowed: team.runs_allowed,
                differential: team.run_differential,
                avg_scored: (team.runs_scored / team.games_played).toFixed(2),
                avg_allowed: (team.runs_allowed / team.games_played).toFixed(2)
            }
        }));
            }
        } catch (e) {
            console.log('ÌåÄ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
        }
        return [];
    }
}

// Î©îÏù∏ Ïã§Ìñâ
async function main() {
    const generator = new EnhancedDashboardGenerator();
    
    try {
        const dashboard = await generator.generateComprehensiveDashboard();
        
        console.log('\n‚úÖ Enhanced ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± ÏôÑÎ£å!');
        console.log('\nüìä Ï£ºÏöî ÏßÄÌëú ÏöîÏïΩ:');
        console.log('1. ÌîºÌÉÄÍ≥†Î¶¨Ïïà Î∂ÑÏÑù - Ïö¥Ïù¥ Ï¢ãÏùÄ ÌåÄ:');
        dashboard.pythagoreanAnalysis
            .filter(t => t.luck_factor > 0.03)
            .forEach(t => console.log(`   ${t.team_name}: ${t.luck_factor}`));
        
        console.log('\n2. 1Ï†êÏ∞® Í≤ΩÍ∏∞ Í∞ïÌåÄ:');
        dashboard.oneRunGames
            .slice(0, 3)
            .forEach(t => console.log(`   ${t.team_name}: ${t.win_rate} (${t.wins}Ïäπ ${t.losses}Ìå®)`));
        
        console.log('\n3. Ìôà Ïñ¥ÎìúÎ∞¥Ìã∞ÏßÄ TOP 3:');
        dashboard.homeAwayStats
            .sort((a, b) => parseFloat(b.home_advantage) - parseFloat(a.home_advantage))
            .slice(0, 3)
            .forEach(t => console.log(`   ${t.team_name}: ${t.home_advantage}`));
    } catch (error) {
        console.error('‚ùå Ïò§Î•ò Î∞úÏÉù:', error);
    }
}

if (require.main === module) {
    main();
}

module.exports = { EnhancedDashboardGenerator };