[{"filePath":"/Users/sanghunbruceham/Documents/GitHub/kbo/magic-number/scripts/script.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'isChartAvailable' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"isChartAvailable"},"fix":{"range":[312,401],"text":""},"desc":"Remove unused variable 'isChartAvailable'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":74,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":74,"endColumn":31},{"ruleId":"no-unused-vars","severity":2,"message":"'year' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":153,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":153,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"year"},"fix":{"range":[8173,8177],"text":""},"desc":"Remove unused variable 'year'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'latestDateFormatted' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":154,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":154,"endColumn":38,"suggestions":[{"messageId":"removeVar","data":{"varName":"latestDateFormatted"},"fix":{"range":[8232,8278],"text":""},"desc":"Remove unused variable 'latestDateFormatted'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'showNotification' is defined but never used. Allowed unused vars must match /^_/u.","line":410,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":410,"endColumn":34,"suggestions":[{"messageId":"removeVar","data":{"varName":"showNotification"},"fix":{"range":[19263,19440],"text":""},"desc":"Remove unused variable 'showNotification'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'duration' is assigned a value but never used. Allowed unused args must match /^_/u.","line":410,"column":60,"nodeType":"Identifier","messageId":"unusedVar","endLine":410,"endColumn":68,"suggestions":[{"messageId":"removeVar","data":{"varName":"duration"},"fix":{"range":[19312,19329],"text":""},"desc":"Remove unused variable 'duration'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'dataDate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":435,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":435,"endColumn":31,"suggestions":[{"messageId":"removeVar","data":{"varName":"dataDate"},"fix":{"range":[20245,20288],"text":""},"desc":"Remove unused variable 'dataDate'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'updateDate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":436,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":436,"endColumn":33,"suggestions":[{"messageId":"removeVar","data":{"varName":"updateDate"},"fix":{"range":[20305,20383],"text":""},"desc":"Remove unused variable 'updateDate'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'wins' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":648,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":648,"endColumn":43,"suggestions":[{"messageId":"removeVar","data":{"varName":"wins"},"fix":{"range":[29218,29248],"text":""},"desc":"Remove unused variable 'wins'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'losses' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":649,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":649,"endColumn":45,"suggestions":[{"messageId":"removeVar","data":{"varName":"losses"},"fix":{"range":[29281,29315],"text":""},"desc":"Remove unused variable 'losses'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'draws' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":650,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":650,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"draws"},"fix":{"range":[29348,29380],"text":""},"desc":"Remove unused variable 'draws'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'draws' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":816,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":816,"endColumn":36,"suggestions":[{"messageId":"removeVar","data":{"varName":"draws"},"fix":{"range":[38187,38242],"text":""},"desc":"Remove unused variable 'draws'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'winRate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":839,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":839,"endColumn":34,"suggestions":[{"messageId":"removeVar","data":{"varName":"winRate"},"fix":{"range":[39363,39419],"text":""},"desc":"Remove unused variable 'winRate'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'sortTable' is defined but never used. Allowed unused vars must match /^_/u.","line":869,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":869,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"sortTable"},"fix":{"range":[40656,42126],"text":""},"desc":"Remove unused variable 'sortTable'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'maxPossibleWinsByChaser' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1139,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":1139,"endColumn":46},{"ruleId":"no-unused-vars","severity":2,"message":"'getStatusIndicator' is defined but never used. Allowed unused vars must match /^_/u.","line":1352,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":1352,"endColumn":36,"suggestions":[{"messageId":"removeVar","data":{"varName":"getStatusIndicator"},"fix":{"range":[63861,64215],"text":""},"desc":"Remove unused variable 'getStatusIndicator'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'secondPlace' is defined but never used. Allowed unused args must match /^_/u.","line":1361,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":1361,"endColumn":62,"suggestions":[{"messageId":"removeVar","data":{"varName":"secondPlace"},"fix":{"range":[64265,64278],"text":""},"desc":"Remove unused variable 'secondPlace'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'championshipProbability' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1581,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1581,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'probabilityDetail' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1582,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1582,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'worstScenario' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1603,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":1603,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'worstScenarioDetail' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1604,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":1604,"endColumn":36},{"ruleId":"no-unused-vars","severity":2,"message":"'isAugustMid' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1609,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":1609,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"isAugustMid"},"fix":{"range":[76650,76730],"text":""},"desc":"Remove unused variable 'isAugustMid'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'historicalAugustWinRate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1614,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":1614,"endColumn":42,"suggestions":[{"messageId":"removeVar","data":{"varName":"historicalAugustWinRate"},"fix":{"range":[76999,77037],"text":""},"desc":"Remove unused variable 'historicalAugustWinRate'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'historicalComparison' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1624,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":1624,"endColumn":37},{"ruleId":"no-unused-vars","severity":2,"message":"'championComparison' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1633,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":1633,"endColumn":35},{"ruleId":"no-unused-vars","severity":2,"message":"'firstPlaceRemaining' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1659,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":1659,"endColumn":42,"suggestions":[{"messageId":"removeVar","data":{"varName":"firstPlaceRemaining"},"fix":{"range":[78870,78921],"text":""},"desc":"Remove unused variable 'firstPlaceRemaining'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'teamData' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1864,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":1864,"endColumn":31,"suggestions":[{"messageId":"removeVar","data":{"varName":"teamData"},"fix":{"range":[90238,90275],"text":""},"desc":"Remove unused variable 'teamData'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'fifthPlaceMaxWins' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1883,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":1883,"endColumn":40,"suggestions":[{"messageId":"removeVar","data":{"varName":"fifthPlaceMaxWins"},"fix":{"range":[91074,91163],"text":""},"desc":"Remove unused variable 'fifthPlaceMaxWins'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'statusColor' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":2014,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":2014,"endColumn":36},{"ruleId":"no-unused-vars","severity":2,"message":"'requiredWinPctColor' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":2030,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":2030,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'determineCellData' is defined but never used. Allowed unused vars must match /^_/u.","line":2121,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2121,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"determineCellData"},"fix":{"range":[103322,106136],"text":""},"desc":"Remove unused variable 'determineCellData'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'calculateMaintainRankMagic' is defined but never used. Allowed unused vars must match /^_/u.","line":2224,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2224,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"calculateMaintainRankMagic"},"fix":{"range":[107908,108336],"text":""},"desc":"Remove unused variable 'calculateMaintainRankMagic'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'calculateChampionshipMagic' is defined but never used. Allowed unused vars must match /^_/u.","line":2254,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2254,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"calculateChampionshipMagic"},"fix":{"range":[109160,109980],"text":""},"desc":"Remove unused variable 'calculateChampionshipMagic'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'calculatePlayoffMagic' is defined but never used. Allowed unused vars must match /^_/u.","line":2273,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2273,"endColumn":39,"suggestions":[{"messageId":"removeVar","data":{"varName":"calculatePlayoffMagic"},"fix":{"range":[109990,110860],"text":""},"desc":"Remove unused variable 'calculatePlayoffMagic'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'calculateTragicNumber' is defined but never used. Allowed unused vars must match /^_/u.","line":2293,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2293,"endColumn":39,"suggestions":[{"messageId":"removeVar","data":{"varName":"calculateTragicNumber"},"fix":{"range":[110870,111890],"text":""},"desc":"Remove unused variable 'calculateTragicNumber'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":2318,"column":66,"nodeType":"Identifier","messageId":"unusedVar","endLine":2318,"endColumn":71,"suggestions":[{"messageId":"removeVar","data":{"varName":"index"},"fix":{"range":[112000,112007],"text":""},"desc":"Remove unused variable 'index'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'determineTeamStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":2361,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2361,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"determineTeamStatus"},"fix":{"range":[113860,115739],"text":""},"desc":"Remove unused variable 'determineTeamStatus'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'today' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":2697,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":2697,"endColumn":28,"suggestions":[{"messageId":"removeVar","data":{"varName":"today"},"fix":{"range":[128963,129016],"text":""},"desc":"Remove unused variable 'today'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'headToHeadData' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":2700,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":2700,"endColumn":47,"suggestions":[{"messageId":"removeVar","data":{"varName":"headToHeadData"},"fix":{"range":[129110,129126],"text":""},"desc":"Remove unused variable 'headToHeadData'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'scrollToWeeklyAnalysis' is defined but never used. Allowed unused vars must match /^_/u.","line":3128,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":3128,"endColumn":40,"suggestions":[{"messageId":"removeVar","data":{"varName":"scrollToWeeklyAnalysis"},"fix":{"range":[144511,144604],"text":""},"desc":"Remove unused variable 'scrollToWeeklyAnalysis'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'toggleMobileMenu' is defined but never used. Allowed unused vars must match /^_/u.","line":3141,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":3141,"endColumn":34,"suggestions":[{"messageId":"removeVar","data":{"varName":"toggleMobileMenu"},"fix":{"range":[144691,144843],"text":""},"desc":"Remove unused variable 'toggleMobileMenu'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'smoothScrollTo' is defined but never used. Allowed unused vars must match /^_/u.","line":3242,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":3242,"endColumn":32,"suggestions":[{"messageId":"removeVar","data":{"varName":"smoothScrollTo"},"fix":{"range":[149294,149746],"text":""},"desc":"Remove unused variable 'smoothScrollTo'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'header' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":3331,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":3331,"endColumn":25,"suggestions":[{"messageId":"removeVar","data":{"varName":"header"},"fix":{"range":[152669,152718],"text":""},"desc":"Remove unused variable 'header'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'canReachTop5' is defined but never used. Allowed unused vars must match /^_/u.","line":3650,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":3650,"endColumn":34,"suggestions":[{"messageId":"removeVar","data":{"varName":"canReachTop5"},"fix":{"range":[165723,169547],"text":""},"desc":"Remove unused variable 'canReachTop5'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":3702,"column":72,"nodeType":"Identifier","messageId":"unusedVar","endLine":3702,"endColumn":77,"suggestions":[{"messageId":"removeVar","data":{"varName":"index"},"fix":{"range":[168423,168430],"text":""},"desc":"Remove unused variable 'index'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":3722,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":3722,"endColumn":57,"suggestions":[{"messageId":"removeVar","data":{"varName":"index"},"fix":{"range":[169330,169337],"text":""},"desc":"Remove unused variable 'index'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'marker' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":3723,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":3723,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"marker"},"fix":{"range":[169368,169414],"text":""},"desc":"Remove unused variable 'marker'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'columnWidth' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":3812,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":3812,"endColumn":34,"suggestions":[{"messageId":"removeVar","data":{"varName":"columnWidth"},"fix":{"range":[173417,173467],"text":""},"desc":"Remove unused variable 'columnWidth'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'finalGames' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":3949,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":3949,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"finalGames"},"fix":{"range":[180148,180211],"text":""},"desc":"Remove unused variable 'finalGames'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'sortedRates' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":3973,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":3973,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"sortedRates"},"fix":{"range":[181065,181158],"text":""},"desc":"Remove unused variable 'sortedRates'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'greenValue' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":4139,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":4139,"endColumn":33,"suggestions":[{"messageId":"removeVar","data":{"varName":"greenValue"},"fix":{"range":[190365,190417],"text":""},"desc":"Remove unused variable 'greenValue'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'intensity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":4143,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":4143,"endColumn":32,"suggestions":[{"messageId":"removeVar","data":{"varName":"intensity"},"fix":{"range":[190599,190650],"text":""},"desc":"Remove unused variable 'intensity'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'winRate' is defined but never used. Allowed unused args must match /^_/u.","line":4152,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":4152,"endColumn":45,"suggestions":[{"messageId":"removeVar","data":{"varName":"winRate"},"fix":{"range":[190973,190980],"text":""},"desc":"Remove unused variable 'winRate'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'getWinRateClass' is defined but never used. Allowed unused vars must match /^_/u.","line":4157,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":4157,"endColumn":33,"suggestions":[{"messageId":"removeVar","data":{"varName":"getWinRateClass"},"fix":{"range":[191085,191563],"text":""},"desc":"Remove unused variable 'getWinRateClass'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'title' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":4214,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":4214,"endColumn":32,"suggestions":[{"messageId":"removeVar","data":{"varName":"title"},"fix":{"range":[193384,193421],"text":""},"desc":"Remove unused variable 'title'."}]}],"suppressedMessages":[],"errorCount":55,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// KBO 매직넘버 계산기 - JavaScript\n\n// 개발/프로덕션 환경 감지 및 로깅 제어\nconst DEBUG_MODE = false;\n\n// 프로덕션 환경에서는 logger.log 비활성화\nconst logger = {\n    log: DEBUG_MODE ? console.log.bind(console) : () => {},\n    warn: DEBUG_MODE ? console.warn.bind(console) : () => {},\n    error: () => {} // 에러 로그도 비활성화\n};\n\n// Chart.js 안전성 검사 함수\nfunction isChartAvailable() {\n    return typeof Chart !== 'undefined' && Chart.version;\n}\n\n// KBO 팀 데이터 (2025 시즌 기준)\nconst kboTeams = {\n    \"한화\": { fullName: \"한화 이글스\", color: \"#FF6600\", logo: '<img src=\"images/teams/hanwha.png\" class=\"team-logo\" alt=\"한화\">' },\n    \"LG\": { fullName: \"LG 트윈스\", color: \"#C50E2E\", logo: '<img src=\"images/teams/lg.png\" class=\"team-logo\" alt=\"LG\">' },\n    \"두산\": { fullName: \"두산 베어스\", color: \"#131230\", logo: '<img src=\"images/teams/doosan.png\" class=\"team-logo\" alt=\"두산\">' },\n    \"삼성\": { fullName: \"삼성 라이온즈\", color: \"#1F4E8C\", logo: '<img src=\"images/teams/samsung.png\" class=\"team-logo\" alt=\"삼성\">' },\n    \"KIA\": { fullName: \"KIA 타이거즈\", color: \"#EA0029\", logo: '<img src=\"images/teams/kia.png\" class=\"team-logo\" alt=\"KIA\">' },\n    \"SSG\": { fullName: \"SSG 랜더스\", color: \"#CE0E2D\", logo: '<img src=\"images/teams/ssg.png\" class=\"team-logo\" alt=\"SSG\">' },\n    \"롯데\": { fullName: \"롯데 자이언츠\", color: \"#041E42\", logo: '<img src=\"images/teams/lotte.png\" class=\"team-logo\" alt=\"롯데\">' },\n    \"NC\": { fullName: \"NC 다이노스\", color: \"#315288\", logo: '<img src=\"images/teams/nc.png\" class=\"team-logo\" alt=\"NC\">' },\n    \"키움\": { fullName: \"키움 히어로즈\", color: \"#570514\", logo: '<img src=\"images/teams/kiwoom.png\" class=\"team-logo\" alt=\"키움\">' },\n    \"KT\": { fullName: \"KT 위즈\", color: \"#333333\", logo: '<img src=\"images/teams/kt.png\" class=\"team-logo\" alt=\"KT\">' }\n};\n\n        // KBO 순위 데이터 (동적 로딩)\n        let currentStandings = [];\n        let currentKBOData = null;\n        \n        // 메모리 관리를 위한 이벤트 리스너 관리자\n        class EventManager {\n            constructor() {\n                this.listeners = new Map();\n                this.boundCleanup = this.cleanup.bind(this);\n                \n                // 페이지 언로드 시 정리\n                window.addEventListener('beforeunload', this.boundCleanup);\n                window.addEventListener('pagehide', this.boundCleanup);\n            }\n            \n            add(element, event, handler, options = {}) {\n                const key = `${element.constructor.name}_${event}_${Date.now()}`;\n                element.addEventListener(event, handler, options);\n                \n                this.listeners.set(key, {\n                    element,\n                    event,\n                    handler,\n                    options\n                });\n                \n                return key; // 나중에 개별 제거할 때 사용\n            }\n            \n            remove(key) {\n                if (this.listeners.has(key)) {\n                    const { element, event, handler } = this.listeners.get(key);\n                    element.removeEventListener(event, handler);\n                    this.listeners.delete(key);\n                }\n            }\n            \n            cleanup() {\n                // 메모리 정리 (프로덕션에서는 로그 비활성화)\n                this.listeners.forEach(({ element, event, handler }) => {\n                    try {\n                        element.removeEventListener(event, handler);\n                    } catch (e) {\n                        // 이벤트 리스너 제거 실패 (프로덕션에서는 로그 비활성화)\n                    }\n                });\n                this.listeners.clear();\n                \n            }\n        }\n        \n        // 전역 이벤트 관리자 인스턴스\n        const eventManager = new EventManager();\n        \n        // 잔여경기 일정 데이터 - 자동 필터링 (현재 날짜 이후만 표시)\n        const allScheduleData = [\n            { date: '08.21', teams: ['SSG', 'KIA', '한화', 'LG', 'KT', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '08.22', teams: ['SSG', 'KIA', '한화', 'KT', 'LG', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '08.23', teams: ['SSG', 'KIA', '한화', 'KT', 'LG', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '08.24', teams: ['SSG', 'KIA', '한화', 'KT', 'LG', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '08.26', teams: ['SSG', '한화', 'KT', 'LG', '키움', '삼성', '두산', 'KIA', '롯데', 'NC'] },\n            { date: '08.27', teams: ['SSG', '한화', 'KT', 'LG', '키움', '삼성', '두산', 'KIA', '롯데', 'NC'] },\n            { date: '08.28', teams: ['SSG', '한화', 'KT', 'LG', '키움', '삼성', '두산', 'KIA', '롯데', 'NC'] },\n            { date: '08.29', teams: ['SSG', 'KIA', '한화', 'LG', 'KT', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '08.30', teams: ['SSG', 'KIA', '한화', 'LG', 'KT', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '08.31', teams: ['SSG', 'KIA', '한화', 'LG', 'KT', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '09.02', teams: ['한화', 'KIA', 'SSG', 'LG', 'KT', '키움', 'NC', '롯데'] },\n            { date: '09.03', teams: ['한화', 'SSG', 'KIA', 'KT', '키움', '삼성', 'NC', '롯데'] },\n            { date: '09.04', teams: ['SSG', 'KIA', 'LG', 'KT', '키움', '삼성', '두산', 'NC'] },\n            { date: '09.05', teams: ['SSG', 'KT', '키움', '삼성', '두산', 'KIA', '롯데', 'NC'] },\n            { date: '09.06', teams: ['한화', 'KIA', 'SSG', 'LG', '삼성', '두산', 'NC', '롯데'] },\n            { date: '09.07', teams: ['한화', 'SSG', 'KIA', 'LG', '삼성', 'NC'] },\n            { date: '09.09', teams: ['한화', 'SSG', 'KIA', 'LG', 'KT', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '09.10', teams: ['한화', 'SSG', 'KIA', '삼성', 'NC', '롯데'] },\n            { date: '09.11', teams: ['SSG', 'KIA', 'KT', 'LG', '키움', '삼성', 'NC', '롯데'] },\n            { date: '09.12', teams: ['한화', 'LG', '키움', '두산', 'KIA', 'NC'] },\n            { date: '09.13', teams: ['SSG', '한화', 'LG', 'KT', '키움', '삼성', '두산', 'KIA', '롯데', 'NC'] },\n            { date: '09.14', teams: ['한화', 'LG', 'KT', '키움', '삼성', '두산', 'KIA', 'NC'] },\n            { date: '09.16', teams: ['한화', 'SSG', 'LG', 'KT', '키움', '삼성', '두산', 'KIA', '롯데', 'NC'] },\n            { date: '09.17', teams: ['한화', 'SSG', 'LG', 'KT', '키움', '삼성', '두산', 'KIA', '롯데', 'NC'] },\n            { date: '09.18', teams: ['한화', 'LG', 'KT', '키움', '삼성', '두산', 'KIA', 'NC'] },\n            { date: '09.19', teams: ['한화', 'SSG', 'KT', '두산', 'NC', '롯데'] },\n            { date: '09.20', teams: ['한화', 'SSG', 'KT', 'LG', '키움', '삼성', '두산', 'KIA', '롯데', 'NC'] },\n            { date: '09.21', teams: ['SSG', 'KT', '삼성', '두산', 'KIA', 'NC'] },\n            { date: '09.23', teams: ['SSG', 'KIA', 'KT', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '09.24', teams: ['한화', 'SSG', 'LG', '키움', 'KIA', 'NC'] },\n            { date: '09.25', teams: ['한화', 'SSG', 'KT', 'LG', '두산', '롯데'] },\n            { date: '09.26', teams: ['SSG', '한화', 'KT', 'LG', '삼성', '두산', 'NC', '롯데'] },\n            { date: '09.27', teams: ['한화', 'SSG', 'LG', '두산', 'KIA', 'NC'] },\n            { date: '09.28', teams: ['한화', 'KIA', 'LG', '키움', '삼성', '두산', 'NC', '롯데'] },\n            { date: '09.30', teams: ['한화', 'KIA', 'SSG', 'KT', 'LG', '키움', '삼성', '두산', 'NC', '롯데'] }\n        ];\n        \n        // 수집된 경기 데이터를 확인하여 미래 경기만 필터링하는 함수\n        function getFilteredRemainingSchedule(serviceData = null) {\n            if (!serviceData) {\n                // 서비스 데이터가 없으면 현재 날짜 기준으로 fallback\n                const today = new Date();\n                const currentMonth = String(today.getMonth() + 1).padStart(2, '0');\n                const currentDay = String(today.getDate()).padStart(2, '0');\n                \n                return allScheduleData.filter(game => {\n                    const gameMonth = parseInt(game.date.split('.')[0]);\n                    const gameDay = parseInt(game.date.split('.')[1]);\n                    const currentMonthInt = parseInt(currentMonth);\n                    const currentDayInt = parseInt(currentDay);\n                    \n                    return (gameMonth > currentMonthInt) || \n                           (gameMonth === currentMonthInt && gameDay > currentDayInt);\n                });\n            }\n\n            // 수집된 경기 데이터에서 최신 경기 날짜 확인\n            const latestDataDate = serviceData.dataDate;\n            if (!latestDataDate) {\n                logger.log('데이터 날짜 정보가 없습니다');\n                return allScheduleData;\n            }\n            \n            \n            // YYYY-MM-DD 형식을 MM.DD 형식으로 변환\n            const [year, month, day] = latestDataDate.split('-');\n            const latestDateFormatted = `${month}.${day}`;\n            \n            \n            const filteredGames = allScheduleData.filter(game => {\n                // 수집된 최신 날짜 이후의 경기만 포함\n                const gameMonth = parseInt(game.date.split('.')[0]);\n                const gameDay = parseInt(game.date.split('.')[1]);\n                const latestMonth = parseInt(month);\n                const latestDay = parseInt(day);\n                \n                const isFuture = (gameMonth > latestMonth) || \n                               (gameMonth === latestMonth && gameDay > latestDay);\n                \n                \n                \n                return isFuture;\n            });\n            \n            return filteredGames;\n        }\n        \n        // 초기 잔여경기 일정 (데이터 로드 전 임시)\n        let remainingSchedule = getFilteredRemainingSchedule();\n        \n        // 우승 확정일 계산 함수\n        function calculateClinchDate(teamName, magicNumber) {\n            try {\n                let gamesPlayed = 0;\n                \n                for (const gameDay of remainingSchedule) {\n                    if (gameDay.teams.includes(teamName)) {\n                        gamesPlayed++;\n                        \n                        if (gamesPlayed >= magicNumber) {\n                            // 날짜 포맷팅 (08.19 -> 8월 19일)\n                            const [month, day] = gameDay.date.split('.');\n                            return `${parseInt(month)}월 ${parseInt(day)}일`;\n                        }\n                    }\n                }\n                \n                return null; // 시즌 내 확정 불가\n            } catch (error) {\n                logger.error('우승 확정일 계산 오류:', error);\n                return null;\n            }\n        }\n        \n        // 공통 유틸리티 함수들\n        const Utils = {\n            // 팀명과 로고를 조합한 HTML 생성 (테이블 친화적)\n            getTeamNameWithLogo(team, includeRank = false) {\n                const teamData = kboTeams[team.team || team];\n                if (!teamData) return team.team || team;\n                \n                const teamName = team.team || team;\n                const logoAndName = `${teamData.logo}<span style=\"color: ${teamData.color};\">${teamName}</span>`;\n                \n                if (includeRank && team.displayRank) {\n                    return `${logoAndName} <span style=\"color: #666;\">(${team.displayRank}위)</span>`;\n                }\n                \n                return logoAndName;\n            },\n            \n            // 홈/어웨이 기록 표시 HTML 생성\n            getHomeAwayDisplay(teamName) {\n                // 동적 데이터에서 홈/어웨이 기록 가져오기\n                const team = currentStandings.find(t => t.team === teamName);\n                \n                const teamHomeAway = team ? {\n                    home: team.homeRecord || \"0-0-0\",\n                    away: team.awayRecord || \"0-0-0\"\n                } : { home: \"0-0-0\", away: \"0-0-0\" };\n                \n                // 홈/방문 승률 계산\n                const parseRecord = (record) => {\n                    const [wins, losses, draws] = record.split('-').map(Number);\n                    const totalGames = wins + losses; // 무승부 제외한 승률 계산\n                    const winRate = totalGames > 0 ? (wins / totalGames) : 0;\n                    return { wins, losses, draws, winRate };\n                };\n                \n                const homeStats = parseRecord(teamHomeAway.home);\n                const awayStats = parseRecord(teamHomeAway.away);\n                \n                return `\n                    <div style=\"\n                        line-height: 1.3;\n                        text-align: center;\n                        color: #555;\n                    \">\n                        <div style=\"margin-bottom: 3px; \">\n                            ${teamHomeAway.home} / ${teamHomeAway.away}\n                        </div>\n                        <div style=\"color: #666;\">\n                            🏠 ${homeStats.winRate.toFixed(3)} / ✈️ ${awayStats.winRate.toFixed(3)}\n                        </div>\n                    </div>\n                `;\n            },\n            \n            // 매직넘버 표시 HTML 생성\n            getMagicNumberDisplay(team) {\n                const magicNumbers = currentKBOData?.magicNumbers || {};\n                \n                let magicNumber = 0;\n                if (team.rank === 1) {\n                    // 1위팀: 우승 매직넘버\n                    const firstPlaceMagic = magicNumbers[team.team];\n                    magicNumber = firstPlaceMagic ? firstPlaceMagic.championship : 0;\n                } else {\n                    // 나머지 팀: 승수 기준 PO 진출 매직넘버 사용\n                    magicNumber = this.getWinsBasedMagicNumber(team);\n                }\n                \n                if (magicNumber === 0 && !this.isTeamEliminated(team)) {\n                    return team.rank === 1 ? \n                        '<span style=\"color: #FFD700; \">우승확정</span>' :\n                        '<span style=\"color: #4CAF50; \">PO확정</span>';\n                }\n                \n                // 수학적으로 불가능한 경우\n                if (magicNumber >= 999) {\n                    return '<span style=\"color: #999; \">-</span>';\n                }\n                \n                // 매직넘버 색상 결정\n                let color = '#666';\n                if (magicNumber <= 3) color = '#4CAF50';      // 초록\n                else if (magicNumber <= 10) color = '#FF9800'; // 주황\n                else if (magicNumber <= 20) color = '#FF5722'; // 빨강\n                else color = '#9E9E9E';                        // 회색\n                \n                return `<span style=\"color: ${color}; \">${magicNumber}</span>`;\n            },\n            \n            // 탈락 확정 팀 체크 (magic-matrix-data.json의 status 필드 확인)\n            isTeamEliminated(team) {\n                try {\n                    if (window.magicMatrixData && window.magicMatrixData.results) {\n                        const teamResult = window.magicMatrixData.results.find(t => t.team === team.team);\n                        if (teamResult && teamResult.status && teamResult.status.includes('탈락')) {\n                            return true;\n                        }\n                    }\n                    return false;\n                } catch (error) {\n                    logger.error('탈락 확정 팀 체크 실패:', error);\n                    return false;\n                }\n            },\n            \n            // 승수 기준 매직넘버 가져오기 (magic-matrix-data.json에서)\n            getWinsBasedMagicNumber(team) {\n                try {\n                    // magic-matrix-data.json에서 해당 팀의 매직넘버 찾기\n                    if (window.magicMatrixData && window.magicMatrixData.results) {\n                        const teamResult = window.magicMatrixData.results.find(t => t.team === team.team);\n                        if (teamResult) {\n                            return teamResult.magicNumber || 0;\n                        }\n                    }\n                    // 폴백으로 기존 계산 방식 사용\n                    return this.calculatePlayoffMagicNumber(team, currentStandings);\n                } catch (error) {\n                    logger.error('승수 기준 매직넘버 가져오기 실패:', error);\n                    return this.calculatePlayoffMagicNumber(team, currentStandings);\n                }\n            },\n            \n            // 5위까지 플레이오프 진출을 위한 매직넘버 계산 (승수 기준)\n            // calculate-magic-numbers.js와 동일한 로직 사용\n            calculatePlayoffMagicNumber(team, standings) {\n                try {\n                    // 1. 모든 팀의 최대가능 승수 계산\n                    const teamMaxStats = standings.map(t => {\n                        const remainingGames = 144 - t.games;\n                        const maxWins = t.wins + remainingGames;\n                        const maxLosses = t.losses;\n                        const maxWinRate = maxWins / (maxWins + maxLosses);\n                        \n                        return {\n                            team: t.team,\n                            currentWins: t.wins,\n                            currentLosses: t.losses,\n                            remainingGames: remainingGames,\n                            maxWins: maxWins,\n                            maxLosses: maxLosses,\n                            maxWinRate: maxWinRate\n                        };\n                    });\n                    \n                    // 2. 최대가능 승률 순으로 정렬\n                    teamMaxStats.sort((a, b) => {\n                        if (Math.abs(a.maxWinRate - b.maxWinRate) > 0.001) {\n                            return b.maxWinRate - a.maxWinRate;\n                        }\n                        const aWinLossMargin = a.maxWins - a.maxLosses;\n                        const bWinLossMargin = b.maxWins - b.maxLosses;\n                        if (aWinLossMargin !== bWinLossMargin) {\n                            return bWinLossMargin - aWinLossMargin;\n                        }\n                        return b.remainingGames - a.remainingGames;\n                    });\n                    \n                    // 3. 플레이오프 진출 기준선 결정 (5위 기준)\n                    let playoffThresholdTeam = teamMaxStats[4];\n                    \n                    // 4. PO 매직넘버 계산: 5위 팀의 최대가능 승수를 넘는데 필요한 승수\n                    let requiredWins;\n                    if (team.team === playoffThresholdTeam.team) {\n                        // 자신이 5위 기준팀이면 자신의 최대가능 승수 달성하면 됨\n                        requiredWins = playoffThresholdTeam.maxWins;\n                    } else {\n                        // 다른 팀은 5위 기준팀을 넘어야 하므로 +1\n                        requiredWins = playoffThresholdTeam.maxWins + 1;\n                    }\n                    \n                    // 현재 승수와의 차이가 매직넘버\n                    const winsNeeded = Math.max(0, requiredWins - team.wins);\n                    \n                    return winsNeeded;\n                } catch (error) {\n                    logger.error('플레이오프 매직넘버 계산 중 오류:', error);\n                    return Math.max(0, 72 - team.wins); // 폴백으로 기존 로직 사용\n                }\n            },\n            \n            // 최대가능 승수 기준 매직넘버 계산 (개선된 플레이오프 매직넘버)\n            calculateMaxWinsMagicNumber(team, standings) {\n                try {\n                    // 개선된 플레이오프 매직넘버 로직 사용\n                    return this.calculatePlayoffMagicNumber(team, standings);\n                } catch (error) {\n                    logger.error('최대승수 기준 매직넘버 계산 중 오류:', error);\n                    return Math.max(0, 72 - team.wins); // 폴백으로 기존 로직 사용\n                }\n            },\n            \n            // 테이블 행 HTML 생성 (공통 스타일 적용)\n            createTableRow(cells, teamColor = null, additionalClasses = '') {\n                const row = document.createElement('tr');\n                if (teamColor) {\n                    row.style.borderLeft = `4px solid ${teamColor}`;\n                }\n                if (additionalClasses) {\n                    row.className = additionalClasses;\n                }\n                \n                row.innerHTML = cells.map(cell => `<td>${cell}</td>`).join('');\n                return row;\n            }\n        };\n        \n        // 에러 처리 및 사용자 알림 함수들 (비활성화)\n        function showNotification(message, type = 'error', duration = 5000) {\n            // 알림 표시 비활성화 - 콘솔에만 로그\n            logger.log(`[${type.toUpperCase()}] ${message}`);\n        }\n        \n        function handleError(error, context = '알 수 없는 오류') {\n            logger.error(`❌ ${context}:`, error);\n            \n            let userMessage = '';\n            if (error.name === 'TypeError' && error.message.includes('fetch')) {\n                userMessage = '네트워크 연결을 확인해주세요. 잠시 후 다시 시도합니다.';\n            } else if (error.name === 'SyntaxError') {\n                userMessage = '데이터 형식에 문제가 있습니다. 백업 데이터를 사용합니다.';\n            } else {\n                userMessage = `${context} 발생. 백업 데이터를 사용하여 서비스를 계속 제공합니다.`;\n            }\n            \n            // 팝업 대신 콘솔에만 로그\n            logger.warn(`[ERROR] ${userMessage}`);\n        }\n        \n        // 데이터 정보 업데이트 함수\n        function updateLoadingTime(data) {\n            try {\n                // 데이터 날짜 표시 (실제 경기 데이터 날짜)\n                const dataDate = data?.dataDate || '날짜 없음';\n                const updateDate = data?.updateDate || new Date().toLocaleDateString('ko-KR');\n                \n                // 실제 크롤링 시간 사용 (lastUpdated 필드에서)\n                let crawlTime = '';\n                if (data?.lastUpdated) {\n                    const lastUpdated = new Date(data.lastUpdated);\n                    crawlTime = lastUpdated.toLocaleString('ko-KR', { \n                        year: 'numeric',\n                        month: 'numeric', \n                        day: 'numeric',\n                        hour: '2-digit',\n                        minute: '2-digit'\n                    }).replace(/\\. /g, '. ').replace(/\\.$/, '');\n                } else {\n                    // 백업: 현재 시간 사용\n                    const now = new Date();\n                    crawlTime = now.toLocaleString('ko-KR', { \n                        year: 'numeric',\n                        month: 'numeric', \n                        day: 'numeric',\n                        hour: '2-digit',\n                        minute: '2-digit'\n                    }).replace(/\\. /g, '. ').replace(/\\.$/, '');\n                }\n                \n                // 헤더 업데이트 정보 표시 (메인 인덱스와 동일한 형식)\n                const updateInfoElement = document.getElementById('updateInfo');\n                if (updateInfoElement) {\n                    updateInfoElement.textContent = `📅 ${crawlTime} 데이터 사용중`;\n                }\n                \n                // 푸터 업데이트 정보 표시 (헤더와 동일한 형식)\n                const dataInfoElement = document.querySelector('.data-info');\n                if (dataInfoElement) {\n                    dataInfoElement.textContent = `${crawlTime} 데이터 사용중`;\n                }\n                \n                // 표시 텍스트 구성 - 마지막 크롤링 시간 표시\n                const displayText = `${crawlTime} KBO 공식`;\n                \n                // 모든 데이터 정보 표시 업데이트\n                const loadTimeElements = document.querySelectorAll('.data-load-time');\n                loadTimeElements.forEach(element => {\n                    if (element) {\n                        element.textContent = displayText;\n                    }\n                });\n                \n            } catch (error) {\n                logger.error('❌ 데이터 로딩 시간 업데이트 실패:', error);\n            }\n        }\n\n        // 승률과 상대전적 기준으로 순위 정렬\n        async function sortStandingsByWinRateAndHeadToHead(standings) {\n            try {\n                // 상대전적 데이터 로드\n                let recordsData = null;\n                try {\n                    const response = await fetch(`data/kbo-records.json?v=${Date.now()}`);\n                    recordsData = await response.json();\n                } catch (error) {\n                    logger.warn('⚠️ 상대전적 데이터 로드 실패, 승률만으로 정렬:', error);\n                }\n\n                // 승률과 상대전적 기준으로 정렬\n                standings.sort((a, b) => {\n                    const aWinRate = parseFloat(a.winRate || a.winPct || 0);\n                    const bWinRate = parseFloat(b.winRate || b.winPct || 0);\n                    \n                    // 1차: 승률 비교 (내림차순)\n                    if (aWinRate !== bWinRate) {\n                        return bWinRate - aWinRate;\n                    }\n                    \n                    // 2차: 승률이 같을 때 상대전적 비교\n                    if (recordsData && recordsData.totalData) {\n                        const aVsB = recordsData.totalData[a.team]?.[b.team];\n                        const bVsA = recordsData.totalData[b.team]?.[a.team];\n                        \n                        if (aVsB && bVsA) {\n                            const aWins = aVsB.wins || 0;\n                            const bWins = bVsA.wins || 0;\n                            \n                            // 상대전적 승수가 다르면 많이 이긴 팀을 앞에\n                            if (aWins !== bWins) {\n                                return bWins - aWins;\n                            }\n                        }\n                    }\n                    \n                    // 3차: 팀명 알파벳 순 (일관성을 위해)\n                    return (a.team || '').localeCompare(b.team || '');\n                });\n                \n                \n            } catch (error) {\n                logger.error('❌ 매직넘버 순위 정렬 실패:', error);\n            }\n        }\n\n        // 데이터 로딩 함수\n        async function loadKBOData() {\n            try {\n                const dataUrl = `data/service-data.json?v=${Date.now()}`;\n                // service-data.json 하나만 사용 (중복 제거)\n                const response = await fetch(dataUrl, {\n                    cache: 'no-cache',\n                    headers: {\n                        'Cache-Control': 'no-cache, no-store, must-revalidate',\n                        'Pragma': 'no-cache',\n                        'Expires': '0'\n                    }\n                });\n                \n                if (response.ok) {\n                    const data = await response.json();\n                    \n                    // 승률과 상대전적 기준으로 정렬\n                    await sortStandingsByWinRateAndHeadToHead(data.standings || []);\n                    \n                    // JSON 데이터 구조를 JavaScript 코드가 기대하는 형태로 변환\n                    // 승률이 같은 팀에게 같은 순위 부여\n                    let currentRank = 1;\n                    let previousWinRate = null;\n                    \n                    currentStandings = (data.standings || []).map((team, index) => {\n                        const winPct = team.winRate || team.winPct || 0;\n                        \n                        // 이전 팀과 승률이 다르면 실제 순위로 업데이트\n                        if (previousWinRate !== null && winPct !== previousWinRate) {\n                            currentRank = index + 1;\n                        }\n                        \n                        const displayRank = currentRank;\n                        previousWinRate = winPct;\n                        \n                        return {\n                            ...team,\n                            winPct: winPct, // winRate를 winPct로 변환\n                            displayRank: displayRank, // 동률 순위 처리\n                            recent10: team.recent10 || \"5승 0무 5패\",\n                            streak: team.streak || \"1승\",\n                            homeAway: { \n                                home: team.homeRecord || \"0-0-0\", \n                                away: team.awayRecord || \"0-0-0\" \n                            } // 실제 홈/원정 기록 사용\n                        };\n                    });\n                    \n                    // currentKBOData에 전체 데이터 저장\n                    currentKBOData = data;\n                    \n                    // 수집된 데이터를 기반으로 잔여경기 일정 업데이트\n                    remainingSchedule = getFilteredRemainingSchedule(data);\n                    \n                    // 데이터 로딩 시간 업데이트\n                    updateLoadingTime(data);\n                    \n                    return data;\n                } else {\n                    logger.error('❌ 응답 실패:', response.status, response.statusText);\n                    throw new Error(`데이터 로딩 실패: ${response.status} ${response.statusText}`);\n                }\n            } catch (error) {\n                logger.error('❌ loadKBOData 에러 상세:', error);\n                \n                // 에러 모니터링 로깅\n                if (window.logDataError) {\n                    window.logDataError('service-data', error.message, {\n                        url: dataUrl,\n                        status: error.status || 'unknown'\n                    });\n                }\n                \n                handleError(error, 'KBO 데이터 로딩 실패');\n                // 백업 데이터 사용 - 서버에서 데이터를 받지 못했을 때만 사용\n                currentStandings = [];\n                // 백업 데이터도 JSON 형식으로 반환\n                const backupData = {\n                    rankings: currentStandings,\n                    magicNumbers: {},\n                    lastUpdated: new Date().toISOString(),\n                    updateDate: new Date().toLocaleDateString('ko-KR')\n                };\n                \n                // 백업 데이터 사용시에도 로딩 시간 업데이트\n                updateLoadingTime(backupData);\n                \n                return backupData;\n            }\n        }\n\n        // 팀간 상대전적 데이터 (동적 로딩)\n        let headToHeadData = {};\n\n        // 상대전적 데이터 로딩 함수\n        async function loadHeadToHeadData() {\n            try {\n                const response = await fetch(`data/kbo-records.json?v=${Date.now()}`);\n                \n                if (response.ok) {\n                    const data = await response.json();\n                    \n                    if (data && data.totalData) {\n                        // kbo-records.json 형식을 headToHeadData 형식으로 변환\n                        headToHeadData = {};\n                        \n                        for (const [team1, opponents] of Object.entries(data.totalData)) {\n                            headToHeadData[team1] = {};\n                            \n                            for (const [team2, record] of Object.entries(opponents)) {\n                                const wins = record.wins || 0;\n                                const losses = record.losses || 0;\n                                const draws = record.draws || 0;\n                                \n                                // 전체 데이터를 보존하여 실제 홈/원정 기록 사용 가능\n                                headToHeadData[team1][team2] = record;\n                            }\n                        }\n                        \n                        return headToHeadData;\n                    } else {\n                        throw new Error('상대전적 데이터 형식 오류');\n                    }\n                } else {\n                    throw new Error(`상대전적 데이터 로딩 실패: ${response.status}`);\n                }\n            } catch (error) {\n                logger.error('❌ 상대전적 데이터 로딩 실패:', error);\n                \n                // 에러 모니터링 로깅\n                if (window.logDataError) {\n                    window.logDataError('kbo-records', error.message, {\n                        status: error.status || 'unknown'\n                    });\n                }\n                \n                // 백업 데이터 사용\n                headToHeadData = {\n                    \"LG\": { \"한화\": \"5-4-1\", \"롯데\": \"6-4-1\", \"KT\": \"4-6-0\", \"KIA\": \"6-7-0\", \"삼성\": \"7-3-0\", \"SSG\": \"7-4-0\", \"NC\": \"6-5-0\", \"두산\": \"7-5-0\", \"키움\": \"9-3-1\" },\n                    \"한화\": { \"LG\": \"4-5-1\", \"롯데\": \"6-6-0\", \"KT\": \"8-4-0\", \"KIA\": \"8-4-0\", \"삼성\": \"6-5-0\", \"SSG\": \"6-6-0\", \"NC\": \"7-4-1\", \"두산\": \"5-7-0\", \"키움\": \"8-4-0\" },\n                    \"롯데\": { \"한화\": \"6-4-0\", \"LG\": \"4-6-1\", \"KT\": \"6-4-2\", \"KIA\": \"6-6-0\", \"삼성\": \"7-3-0\", \"SSG\": \"5-6-0\", \"NC\": \"4-4-0\", \"두산\": \"6-6-0\", \"키움\": \"10-4-0\" },\n                    \"KT\": { \"한화\": \"3-8-0\", \"LG\": \"4-5-0\", \"롯데\": \"4-6-2\", \"KIA\": \"5-7-0\", \"삼성\": \"7-3-0\", \"SSG\": \"5-6-0\", \"NC\": \"6-5-0\", \"두산\": \"7-5-1\", \"키움\": \"9-3-0\" },\n                    \"KIA\": { \"한화\": \"3-8-0\", \"LG\": \"4-7-0\", \"롯데\": \"6-6-0\", \"KT\": \"7-5-0\", \"삼성\": \"3-7-0\", \"SSG\": \"5-4-1\", \"NC\": \"5-3-0\", \"두산\": \"7-2-0\", \"키움\": \"6-5-3\" },\n                    \"삼성\": { \"한화\": \"4-6-0\", \"LG\": \"6-6-0\", \"롯데\": \"3-7-0\", \"KT\": \"3-7-0\", \"KIA\": \"7-3-0\", \"SSG\": \"6-5-1\", \"NC\": \"6-6-0\", \"두산\": \"7-6-0\", \"키움\": \"6-3-0\" },\n                    \"SSG\": { \"한화\": \"6-6-0\", \"LG\": \"4-8-0\", \"롯데\": \"6-5-0\", \"KT\": \"6-5-0\", \"KIA\": \"4-5-1\", \"삼성\": \"5-6-1\", \"NC\": \"7-2-2\", \"두산\": \"5-4-1\", \"키움\": \"4-5-0\" },\n                    \"NC\": { \"한화\": \"4-7-1\", \"LG\": \"5-6-0\", \"롯데\": \"4-4-0\", \"KT\": \"5-6-0\", \"KIA\": \"3-5-0\", \"삼성\": \"6-6-0\", \"SSG\": \"2-7-2\", \"두산\": \"5-3-2\", \"키움\": \"10-2-1\" },\n                    \"두산\": { \"한화\": \"5-6-1\", \"LG\": \"5-6-0\", \"롯데\": \"6-6-0\", \"KT\": \"5-7-1\", \"KIA\": \"2-7-0\", \"삼성\": \"6-7-0\", \"SSG\": \"4-5-1\", \"NC\": \"3-5-2\", \"키움\": \"5-3-3\" },\n                    \"키움\": { \"한화\": \"1-10-0\", \"LG\": \"4-9-0\", \"롯데\": \"4-10-0\", \"KT\": \"3-9-0\", \"KIA\": \"5-6-3\", \"삼성\": \"3-6-0\", \"SSG\": \"5-4-0\", \"NC\": \"2-10-1\", \"두산\": \"3-5-3\" }\n                };\n                \n                return headToHeadData;\n            }\n        }\n\n\n        // 요약 대시보드 업데이트\n        function updateSummaryDashboard() {\n            const firstPlace = currentStandings[0];\n            const secondPlace = currentStandings[1];\n            \n            // 1위 팀 정보\n            const firstTeamData = kboTeams[firstPlace.team];\n            document.getElementById('first-place-team').innerHTML = `\n                <div style=\"display: flex; align-items: center; gap: 4px; justify-content: center;\">\n                    ${firstTeamData.logo}\n                    <span style=\"color: ${firstTeamData.color}; \">${firstPlace.team}</span>\n                </div>\n            `;\n            const magicNumber = calculateMagicNumber(firstPlace, secondPlace);\n            document.getElementById('first-place-magic').textContent = `매직넘버: ${magicNumber > 0 ? magicNumber : '확정'}`;\n\n            // 플레이오프 확정 팀 수 (PO 매직넘버 0이지만 탈락 확정이 아닌 팀들)\n            const confirmedTeamsList = [];\n            currentStandings.forEach(team => {\n                const poMagicNumber = Utils.getWinsBasedMagicNumber(team);\n                // 매직넘버가 0이면서 탈락 확정이 아닌 팀만 플레이오프 확정으로 간주\n                if (poMagicNumber === 0 && !Utils.isTeamEliminated(team)) {\n                    confirmedTeamsList.push(team);\n                }\n            });\n            \n            const confirmedTeams = confirmedTeamsList.length;\n            document.getElementById('playoff-confirmed-teams').textContent = `${confirmedTeams}개 팀`;\n            \n            // 플레이오프 확정 팀이 있으면 첫 번째 확정 팀 정보 표시\n            if (confirmedTeams > 0) {\n                const firstConfirmedTeam = confirmedTeamsList[0];\n                if (firstConfirmedTeam) {\n                    const teamData = kboTeams[firstConfirmedTeam.team];\n                    document.getElementById('playoff-confirmed-desc').innerHTML = `<span style=\"color: ${teamData.color}; \">${firstConfirmedTeam.team}</span> 외 ${confirmedTeams - 1}팀`;\n                }\n            } else {\n                document.getElementById('playoff-confirmed-desc').textContent = 'PO 매직넘버 0 달성';\n            }\n\n            // 최고 연승팀 (동점 시 2팀 표기)\n            let bestStreakTeams = [];\n            let maxWinStreak = 0;\n            currentStandings.forEach(team => {\n                if (team.streak.includes('승')) {\n                    const count = parseInt(team.streak);\n                    if (count > maxWinStreak) {\n                        maxWinStreak = count;\n                        bestStreakTeams = [team.team];\n                    } else if (count === maxWinStreak && count > 0) {\n                        bestStreakTeams.push(team.team);\n                    }\n                }\n            });\n            if (bestStreakTeams.length > 0) {\n                const teamsToShow = bestStreakTeams.slice(0, 2); // 최대 2팀까지\n                const teamLogos = teamsToShow.map(teamName => {\n                    const teamData = kboTeams[teamName];\n                    return `<div style=\"display: flex; align-items: center; gap: 2px;\">\n                        ${teamData.logo}\n                        <span style=\"color: ${teamData.color};  \">${teamName}</span>\n                    </div>`;\n                }).join('');\n                \n                document.getElementById('best-streak-team').innerHTML = `\n                    <div style=\"display: flex; gap: 8px; align-items: center; justify-content: center; flex-wrap: wrap;\">\n                        ${teamLogos}\n                    </div>\n                `;\n                document.getElementById('best-streak-count').textContent = `${maxWinStreak}연승 중`;\n            } else {\n                document.getElementById('best-streak-team').textContent = '없음';\n                document.getElementById('best-streak-count').textContent = '-';\n            }\n\n            // 최고 연패팀 (동점 시 2팀 표기)\n            let worstStreakTeams = [];\n            let maxLossStreak = 0;\n            currentStandings.forEach(team => {\n                if (team.streak.includes('패')) {\n                    const count = parseInt(team.streak);\n                    if (count > maxLossStreak) {\n                        maxLossStreak = count;\n                        worstStreakTeams = [team.team];\n                    } else if (count === maxLossStreak && count > 0) {\n                        worstStreakTeams.push(team.team);\n                    }\n                }\n            });\n            if (worstStreakTeams.length > 0) {\n                const teamsToShow = worstStreakTeams.slice(0, 2); // 최대 2팀까지\n                const teamLogos = teamsToShow.map(teamName => {\n                    const teamData = kboTeams[teamName];\n                    return `<div style=\"display: flex; align-items: center; gap: 2px;\">\n                        ${teamData.logo}\n                        <span style=\"color: ${teamData.color};  \">${teamName}</span>\n                    </div>`;\n                }).join('');\n                \n                document.getElementById('worst-streak-team').innerHTML = `\n                    <div style=\"display: flex; gap: 8px; align-items: center; justify-content: center; flex-wrap: wrap;\">\n                        ${teamLogos}\n                    </div>\n                `;\n                document.getElementById('worst-streak-count').textContent = `${maxLossStreak}연패 중`;\n            } else {\n                document.getElementById('worst-streak-team').textContent = '없음';\n                document.getElementById('worst-streak-count').textContent = '-';\n            }\n\n            // 최근 10경기 성적이 가장 좋은 팀 찾기 (10경기 승률 기준)\n            let bestRecentTeams = [];\n            let maxRecentWinRate = -1;\n            \n            currentStandings.forEach(team => {\n                if (team.recent10) {\n                    // \"7승1무2패\" 형태에서 승, 무, 패 추출\n                    const winsMatch = team.recent10.match(/(\\d+)승/);\n                    const drawsMatch = team.recent10.match(/(\\d+)무/);\n                    const lossesMatch = team.recent10.match(/(\\d+)패/);\n                    \n                    if (winsMatch) {\n                        const wins = parseInt(winsMatch[1]);\n                        const draws = drawsMatch ? parseInt(drawsMatch[1]) : 0;\n                        const losses = lossesMatch ? parseInt(lossesMatch[1]) : 0;\n                        \n                        // 최근 10경기 승률 계산 (무승부 제외)\n                        const recentWinRate = (wins + losses) > 0 ? wins / (wins + losses) : 0;\n                        \n                        // 팀 정보에 10경기 승률 추가\n                        team.recent10WinRate = recentWinRate;\n                        \n                        if (recentWinRate > maxRecentWinRate) {\n                            maxRecentWinRate = recentWinRate;\n                            bestRecentTeams = [team];\n                        } else if (recentWinRate === maxRecentWinRate && recentWinRate > 0) {\n                            bestRecentTeams.push(team);\n                        }\n                    }\n                }\n            });\n            \n            if (bestRecentTeams.length > 0 && maxRecentWinRate >= 0) {\n                const teamsToShow = bestRecentTeams.slice(0, 3); // 최대 3팀까지\n                const teamLogos = teamsToShow.map(team => {\n                    const teamData = kboTeams[team.team];\n                    const winRate = (team.recent10WinRate * 100).toFixed(1);\n                    return `<div style=\"display: flex; align-items: center; gap: 2px;\">\n                        ${teamData.logo}\n                        <span style=\"color: ${teamData.color};\">${team.team}</span>\n                    </div>`;\n                }).join(' ');\n                \n                document.getElementById('recent-best-team').innerHTML = `\n                    <div style=\"display: flex; gap: 8px; align-items: center; justify-content: center; flex-wrap: wrap;\">\n                        ${teamLogos}\n                    </div>\n                `;\n                \n                // 성적 표시 (10경기 승률 포함)\n                const winRateText = bestRecentTeams[0].recent10WinRate.toFixed(3);\n                document.getElementById('recent-best-record').textContent = `${bestRecentTeams[0].recent10} (승률 ${winRateText})`;\n            } else {\n                document.getElementById('recent-best-team').textContent = '-';\n                document.getElementById('recent-best-record').textContent = '-';\n            }\n\n        }\n\n        // 테이블 정렬 상태\n        let sortState = {\n            standings: { column: '', direction: '' },\n            playoff: { column: '', direction: '' }\n        };\n\n        // 테이블 정렬 함수\n        function sortTable(tableType, column) {\n            const currentSort = sortState[tableType];\n            \n            // 정렬 방향 결정\n            let direction = 'asc';\n            if (currentSort.column === column) {\n                direction = currentSort.direction === 'asc' ? 'desc' : 'asc';\n            }\n            \n            // 이전 헤더의 정렬 표시 제거\n            document.querySelectorAll(`#${tableType}-table .sortable-header`).forEach(header => {\n                header.classList.remove('sort-asc', 'sort-desc');\n                const arrow = header.querySelector('.sort-arrow');\n                if (arrow) arrow.textContent = '↕';\n            });\n            \n            // 현재 헤더에 정렬 표시 추가\n            const currentHeader = document.querySelector(`#${tableType}-table .sortable-header[data-sort=\"${column}\"]`);\n            if (currentHeader) {\n                currentHeader.classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');\n                const arrow = currentHeader.querySelector('.sort-arrow');\n                if (arrow) arrow.textContent = direction === 'asc' ? '↑' : '↓';\n            }\n            \n            // 정렬 상태 업데이트\n            sortState[tableType] = { column, direction };\n            \n            // 테이블 정렬 실행\n            if (tableType === 'standings') {\n                sortStandingsTable(column, direction);\n            } else if (tableType === 'playoff') {\n                sortPlayoffTable(column, direction);\n            }\n        }\n\n        // 순위표 정렬\n        function sortStandingsTable(column, direction) {\n            const table = document.getElementById('standings-table');\n            const tbody = table.querySelector('tbody');\n            const rows = Array.from(tbody.querySelectorAll('tr'));\n            \n            // 테이블에 정렬 중 표시\n            table.classList.add('sorting');\n            \n            rows.sort((a, b) => {\n                let aValue, bValue;\n                \n                switch(column) {\n                    case 'rank':\n                        aValue = parseInt(a.cells[0].textContent);\n                        bValue = parseInt(b.cells[0].textContent);\n                        break;\n                    case 'games':\n                        aValue = parseInt(a.cells[2].textContent);\n                        bValue = parseInt(b.cells[2].textContent);\n                        break;\n                    case 'wins':\n                        aValue = parseInt(a.cells[3].textContent);\n                        bValue = parseInt(b.cells[3].textContent);\n                        break;\n                    case 'losses':\n                        aValue = parseInt(a.cells[4].textContent);\n                        bValue = parseInt(b.cells[4].textContent);\n                        break;\n                    case 'draws':\n                        aValue = parseInt(a.cells[5].textContent);\n                        bValue = parseInt(b.cells[5].textContent);\n                        break;\n                    case 'winLossMargin':\n                        aValue = parseInt(a.cells[6].textContent.replace('+', ''));\n                        bValue = parseInt(b.cells[6].textContent.replace('+', ''));\n                        break;\n                    case 'winPct':\n                        aValue = parseFloat(a.cells[7].textContent);\n                        bValue = parseFloat(b.cells[7].textContent);\n                        break;\n                    case 'gamesBehind':\n                        aValue = a.cells[8].textContent === '-' ? 0 : parseFloat(a.cells[8].textContent);\n                        bValue = b.cells[8].textContent === '-' ? 0 : parseFloat(b.cells[8].textContent);\n                        break;\n                    case 'remainingGames':\n                        aValue = parseInt(a.cells[9].textContent);\n                        bValue = parseInt(b.cells[9].textContent);\n                        break;\n                    case 'recent10':\n                        // \"7승1무2패\" 형태에서 승률 계산\n                        const aRecord = a.cells[10].textContent;\n                        const bRecord = b.cells[10].textContent;\n                        \n                        const aWins = parseInt(aRecord.match(/(\\d+)승/)?.[1] || 0);\n                        const aLosses = parseInt(aRecord.match(/(\\d+)패/)?.[1] || 0);\n                        const bWins = parseInt(bRecord.match(/(\\d+)승/)?.[1] || 0);\n                        const bLosses = parseInt(bRecord.match(/(\\d+)패/)?.[1] || 0);\n                        \n                        // 승률 계산 (무승부 제외)\n                        aValue = (aWins + aLosses) > 0 ? aWins / (aWins + aLosses) : 0;\n                        bValue = (bWins + bLosses) > 0 ? bWins / (bWins + bLosses) : 0;\n                        break;\n                    case 'streak':\n                        const aStreak = a.cells[11].textContent;\n                        const bStreak = b.cells[11].textContent;\n                        // 연속 승리는 양수, 연속 패배는 음수로 처리\n                        aValue = aStreak.includes('승') ? parseInt(aStreak.match(/\\d+/)?.[0] || 0) : -parseInt(aStreak.match(/\\d+/)?.[0] || 0);\n                        bValue = bStreak.includes('승') ? parseInt(bStreak.match(/\\d+/)?.[0] || 0) : -parseInt(bStreak.match(/\\d+/)?.[0] || 0);\n                        break;\n                    case 'home':\n                        // 홈 성적에서 승률 계산\n                        const aHome = a.cells[12].textContent;\n                        const bHome = b.cells[12].textContent;\n                        const aHomeWins = parseInt(aHome.match(/(\\d+)-/)?.[1] || 0);\n                        const aHomeLosses = parseInt(aHome.match(/-(\\d+)/)?.[1] || 0);\n                        const bHomeWins = parseInt(bHome.match(/(\\d+)-/)?.[1] || 0);\n                        const bHomeLosses = parseInt(bHome.match(/-(\\d+)/)?.[1] || 0);\n                        aValue = (aHomeWins + aHomeLosses) > 0 ? aHomeWins / (aHomeWins + aHomeLosses) : 0;\n                        bValue = (bHomeWins + bHomeLosses) > 0 ? bHomeWins / (bHomeWins + bHomeLosses) : 0;\n                        break;\n                    case 'away':\n                        // 방문 성적에서 승률 계산\n                        const aAway = a.cells[13].textContent;\n                        const bAway = b.cells[13].textContent;\n                        const aAwayWins = parseInt(aAway.match(/(\\d+)-/)?.[1] || 0);\n                        const aAwayLosses = parseInt(aAway.match(/-(\\d+)/)?.[1] || 0);\n                        const bAwayWins = parseInt(bAway.match(/(\\d+)-/)?.[1] || 0);\n                        const bAwayLosses = parseInt(bAway.match(/-(\\d+)/)?.[1] || 0);\n                        aValue = (aAwayWins + aAwayLosses) > 0 ? aAwayWins / (aAwayWins + aAwayLosses) : 0;\n                        bValue = (bAwayWins + bAwayLosses) > 0 ? bAwayWins / (bAwayWins + bAwayLosses) : 0;\n                        break;\n                    case 'maxRank':\n                        aValue = parseInt(a.cells[14].textContent);\n                        bValue = parseInt(b.cells[14].textContent);\n                        break;\n                    case 'minRank':\n                        aValue = parseInt(a.cells[15].textContent);\n                        bValue = parseInt(b.cells[15].textContent);\n                        break;\n                    default:\n                        return 0;\n                }\n                \n                if (direction === 'asc') {\n                    return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;\n                } else {\n                    return aValue < bValue ? 1 : aValue > bValue ? -1 : 0;\n                }\n            });\n            \n            // 정렬된 행들을 다시 추가\n            tbody.innerHTML = '';\n            rows.forEach((row, index) => {\n                row.style.animationDelay = `${index * 0.05}s`;\n                tbody.appendChild(row);\n            });\n            \n            // 정렬 완료 후 표시 제거\n            setTimeout(() => {\n                table.classList.remove('sorting');\n            }, 300);\n        }\n\n        // 플레이오프 테이블 정렬\n        function sortPlayoffTable(column, direction) {\n            const table = document.getElementById('playoff-table');\n            const tbody = table.querySelector('tbody');\n            const rows = Array.from(tbody.querySelectorAll('tr'));\n            \n            table.classList.add('sorting');\n            \n            rows.sort((a, b) => {\n                let aValue, bValue;\n                \n                switch(column) {\n                    case 'rank':\n                        aValue = parseInt(a.cells[0].textContent);\n                        bValue = parseInt(b.cells[0].textContent);\n                        break;\n                    case 'wins':\n                        aValue = parseInt(a.cells[2].textContent);\n                        bValue = parseInt(b.cells[2].textContent);\n                        break;\n                    case 'remaining':\n                        aValue = parseInt(a.cells[3].textContent);\n                        bValue = parseInt(b.cells[3].textContent);\n                        break;\n                    case 'maxWins':\n                        aValue = parseInt(a.cells[4].textContent);\n                        bValue = parseInt(b.cells[4].textContent);\n                        break;\n                    case 'poMagic':\n                        const aPoMagic = a.cells[5].textContent;\n                        const bPoMagic = b.cells[5].textContent;\n                        aValue = getMagicNumberSortValue(aPoMagic);\n                        bValue = getMagicNumberSortValue(bPoMagic);\n                        break;\n                    case 'poTragic':\n                        const aPoTragic = a.cells[6].textContent;\n                        const bPoTragic = b.cells[6].textContent;\n                        aValue = getMagicNumberSortValue(aPoTragic);\n                        bValue = getMagicNumberSortValue(bPoTragic);\n                        break;\n                    case 'poRequiredWinPct':\n                        const aPoReq = a.cells[7].textContent;\n                        const bPoReq = b.cells[7].textContent;\n                        aValue = aPoReq === '-' || aPoReq === '확정' || aPoReq === '탈락' || aPoReq === '자력불가' ? -1 : parseFloat(aPoReq);\n                        bValue = bPoReq === '-' || bPoReq === '확정' || bPoReq === '탈락' || bPoReq === '자력불가' ? -1 : parseFloat(bPoReq);\n                        break;\n                    case 'magic':\n                        const aMagic = a.cells[9].textContent;\n                        const bMagic = b.cells[9].textContent;\n                        aValue = getMagicNumberSortValue(aMagic);\n                        bValue = getMagicNumberSortValue(bMagic);\n                        break;\n                    case 'tragic':\n                        const aTragic = a.cells[10].textContent;\n                        const bTragic = b.cells[10].textContent;\n                        aValue = getMagicNumberSortValue(aTragic);\n                        bValue = getMagicNumberSortValue(bTragic);\n                        break;\n                    case 'requiredWinPct':\n                        const aReq = a.cells[11].textContent;\n                        const bReq = b.cells[11].textContent;\n                        aValue = aReq === '-' || aReq === '달성' ? -1 : parseFloat(aReq);\n                        bValue = bReq === '-' || bReq === '달성' ? -1 : parseFloat(bReq);\n                        break;\n                    default:\n                        return 0;\n                }\n                \n                if (direction === 'asc') {\n                    return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;\n                } else {\n                    return aValue < bValue ? 1 : aValue > bValue ? -1 : 0;\n                }\n            });\n            \n            tbody.innerHTML = '';\n            rows.forEach((row, index) => {\n                row.style.animationDelay = `${index * 0.05}s`;\n                tbody.appendChild(row);\n            });\n            \n            setTimeout(() => {\n                table.classList.remove('sorting');\n            }, 300);\n        }\n\n        // 매직넘버 정렬 값 변환\n        function getMagicNumberSortValue(magic) {\n            if (magic === '확정' || magic === 'PO확정') return -1;\n            if (magic === '불가능' || magic === '탈락') return 9999;\n            return parseInt(magic) || 0;\n        }\n\n        function renderStandingsTable() {\n            try {\n                // 성능 모니터링 시작\n                const startTime = performance.now();\n                \n                \n                const tbody = document.querySelector('#standings-table tbody');\n                \n                if (!tbody) {\n                    throw new Error('순위표 테이블을 찾을 수 없습니다');\n                }\n                tbody.innerHTML = '';\n\n                if (!currentStandings || currentStandings.length === 0) {\n                    throw new Error('순위 데이터가 없습니다');\n                }\n\n                // 모든 추격팀의 최대가능승수 중 최고값 찾기\n                const maxPossibleWinsByChaser = Math.max(...currentStandings.slice(1).map(team => \n                    team.wins + (144 - team.games)\n                ));\n\n                // 승률이 같은 팀에게 같은 순위 부여\n                let currentRank = 1;\n                let previousWinRate = null;\n                \n                currentStandings.forEach((team, index) => {\n                // 이전 팀과 승률이 다르면 실제 순위로 업데이트\n                if (previousWinRate !== null && team.winPct !== previousWinRate) {\n                    currentRank = index + 1;\n                }\n                // 동률일 경우 같은 순위 유지\n                team.displayRank = currentRank;\n                previousWinRate = team.winPct;\n                const row = document.createElement('tr');\n                const totalGames = 144;\n                const remainingGames = totalGames - team.games;\n                const teamData = kboTeams[team.team];\n                \n                // 데이터 검증\n                if (!teamData) {\n                    logger.error('❌ 팀 데이터 없음:', team.team);\n                    return;\n                }\n                \n                let rankClass = '';\n                if (team.displayRank === 1) rankClass = 'rank-1';\n                else if (team.displayRank === 2) rankClass = 'rank-2';\n                else if (team.displayRank === 3) rankClass = 'rank-3';\n                else if (team.displayRank >= 4 && team.displayRank <= 5) rankClass = 'playoff';\n                \n                row.className = rankClass;\n                row.style.borderLeft = `4px solid ${teamData.color}`;\n\n                // 가능한 순위 계산\n                const maxPossibleWins = team.wins + remainingGames; // 전승시\n                const minPossibleWins = team.wins; // 전패시\n                \n                // 최대 가능 순위 (가장 좋은 순위, 숫자가 작음) - 전승했을 때\n                let maxRank = 1;\n                const myMaxLosses = team.losses; // 내 전승시 패수는 그대로\n                const myMaxWinRate = maxPossibleWins / (maxPossibleWins + myMaxLosses); // 내 최고 승률 (무승부 제외)\n                \n                for (let i = 0; i < currentStandings.length; i++) {\n                    const otherTeam = currentStandings[i];\n                    if (otherTeam.team === team.team) continue;\n                    \n                    const otherMinWins = otherTeam.wins; // 상대팀 전패시\n                    const otherMinLosses = otherTeam.losses + (144 - otherTeam.games); // 상대팀 전패시 패수\n                    const otherMinWinRate = otherMinWins / (otherMinWins + otherMinLosses); // 상대팀 최저 승률 (무승부 제외)\n                    \n                    // KBO 동률 처리 규칙 적용 (승률 → 승패차 → 상대전적)\n                    if (myMaxWinRate < otherMinWinRate) {\n                        maxRank++;\n                    } else if (Math.abs(myMaxWinRate - otherMinWinRate) < 0.0001) {\n                        // 승률이 같을 때 승패차 비교\n                        const myMaxMargin = maxPossibleWins - team.losses; // 내 전승시 승패차\n                        const otherMinMargin = otherTeam.wins - (otherTeam.losses + (144 - otherTeam.games)); // 상대 전패시 승패차\n                        \n                        if (myMaxMargin < otherMinMargin) {\n                            maxRank++;\n                        }\n                        // 승률과 승패차가 모두 같을 경우는 상대전적 고려 필요하지만 복잡하므로 보수적으로 동순위 처리\n                    }\n                }\n                \n                // 최소 가능 순위 (가장 나쁜 순위, 숫자가 큼) - 전패했을 때\n                let minRank = 1;\n                const myMinLosses = team.losses + (144 - team.games); // 내 전패시 패수\n                const myMinWinRate = minPossibleWins / (minPossibleWins + myMinLosses); // 내 최저 승률 (무승부 제외)\n                \n                for (let i = 0; i < currentStandings.length; i++) {\n                    const otherTeam = currentStandings[i];\n                    if (otherTeam.team === team.team) continue;\n                    \n                    const otherMaxWins = otherTeam.wins + (144 - otherTeam.games); // 상대팀 전승시\n                    const otherMaxLosses = otherTeam.losses; // 상대팀 전승시 패수는 그대로\n                    const otherMaxWinRate = otherMaxWins / (otherMaxWins + otherMaxLosses); // 상대팀 최고 승률 (무승부 제외)\n                    \n                    // KBO 동률 처리 규칙 적용 (승률 → 승패차 → 상대전적)\n                    if (myMinWinRate < otherMaxWinRate) {\n                        minRank++;\n                    } else if (Math.abs(myMinWinRate - otherMaxWinRate) < 0.0001) {\n                        // 승률이 같을 때 승패차 비교\n                        const myMinMargin = minPossibleWins - (team.losses + (144 - team.games)); // 내 전패시 승패차\n                        const otherMaxMargin = otherMaxWins - otherTeam.losses; // 상대 전승시 승패차\n                        \n                        if (myMinMargin < otherMaxMargin) {\n                            minRank++;\n                        } else if (Math.abs(myMinMargin - otherMaxMargin) < 0.0001) {\n                            // 승률과 승패차가 모두 같을 경우, 상대전적으로 결정되므로 최악의 경우 가정\n                            minRank++; // 보수적으로 상대방이 위에 있다고 가정 (최소순위는 가장 나쁜 경우)\n                        }\n                    }\n                }\n                \n                // 순위는 10위를 넘을 수 없음\n                maxRank = Math.min(maxRank, 10);\n                minRank = Math.min(minRank, 10);\n\n                // 연속 기록 강조\n                const streakFormatted = formatStreak(team.streak);\n                \n                // 최근 10경기 강조\n                const recent10Formatted = formatRecent10(team.recent10);\n                \n                // 팀명 로고 추가\n                const teamNameWithLogo = Utils.getTeamNameWithLogo(team);\n\n                // 홈/방문 성적 - JSON 데이터에서 실제 값 사용 (분리)\n                const homeRecord = team.homeRecord || \"0-0-0\";\n                const awayRecord = team.awayRecord || \"0-0-0\";\n                const homeDisplay = `<span style=\"color: #2563eb;\">${homeRecord}</span>`;\n                const awayDisplay = `<span style=\"color: #dc2626;\">${awayRecord}</span>`;\n\n                const winLossMargin = team.wins - team.losses;\n                const marginColor = winLossMargin > 0 ? '#27ae60' : winLossMargin < 0 ? '#e74c3c' : '#666';\n                const marginDisplay = winLossMargin > 0 ? `+${winLossMargin}` : winLossMargin.toString();\n                \n                row.innerHTML = `\n                    <td style=\"color: ${teamData.color};\">${team.displayRank}</td>\n                    <td class=\"team-name\">${teamNameWithLogo}</td>\n                    <td>${team.games}</td>\n                    <td>${team.wins}</td>\n                    <td>${team.losses}</td>\n                    <td>${team.draws}</td>\n                    <td style=\"color: ${marginColor};\">${marginDisplay}</td>\n                    <td>${team.winPct.toFixed(3)}</td>\n                    <td>${team.gamesBehind === 0 ? '-' : team.gamesBehind}</td>\n                    <td>${remainingGames}</td>\n                    <td>${recent10Formatted}</td>\n                    <td>${streakFormatted}</td>\n                    <td>${homeDisplay}</td>\n                    <td>${awayDisplay}</td>\n                    <td>${maxRank}</td>\n                    <td>${minRank}</td>\n                `;\n\n                tbody.appendChild(row);\n            });\n            \n            // 성능 모니터링 완료\n            const renderTime = performance.now() - startTime;\n            if (renderTime > 100 && window.logPerformanceIssue) {\n                window.logPerformanceIssue({\n                    function: 'renderStandingsTable',\n                    duration: renderTime,\n                    message: `순위표 렌더링이 ${renderTime.toFixed(2)}ms 소요되었습니다`\n                });\n            }\n            \n            } catch (error) {\n                // 에러 모니터링 로깅\n                if (window.logUserError) {\n                    window.logUserError('standings_render', error.message);\n                }\n                handleError(error, '순위표 렌더링 실패');\n                // 에러가 발생하면 기본 메시지 표시\n                const tbody = document.querySelector('#standings-table tbody');\n                if (tbody) {\n                    tbody.innerHTML = '<tr><td colspan=\"16\" style=\"text-align: center; color: #999; padding: 20px;\">데이터를 불러오는 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.</td></tr>';\n                }\n            }\n        }\n\n        function formatStreak(streak) {\n            if (streak.includes('승')) {\n                const winCount = parseInt(streak);\n                if (winCount >= 5) {\n                    return `<span style=\"color: var(--success-color); \">${streak}</span>`;\n                }\n                return `<span style=\"color: var(--success-color);\">${streak}</span>`;\n            } else if (streak.includes('패')) {\n                const lossCount = parseInt(streak);\n                if (lossCount >= 5) {\n                    return `<span style=\"color: var(--danger-color); \">${streak}</span>`;\n                }\n                return `<span style=\"color: var(--danger-color);\">${streak}</span>`;\n            }\n            return streak;\n        }\n\n        function formatRecent10(recent10) {\n            // \"6승1무3패\" 형태 파싱\n            const winMatch = recent10.match(/(\\d+)승/);\n            const lossMatch = recent10.match(/(\\d+)패/);\n            const drawMatch = recent10.match(/(\\d+)무/);\n            \n            const wins = winMatch ? parseInt(winMatch[1]) : 0;\n            const losses = lossMatch ? parseInt(lossMatch[1]) : 0;\n            const draws = drawMatch ? parseInt(drawMatch[1]) : 0;\n            \n            // 승 패 무 형태로 변환 (띄어쓰기 포함)\n            const formattedRecord = `${wins}승 ${losses}패 ${draws}무`;\n            \n            // 색상 기준: 승수에 따른 색상 적용\n            if (wins >= 8) {\n                // 8승 이상 - 매우 뜨거운 상승세\n                return `<span style=\"color: var(--success-color); font-weight: 600;\">${formattedRecord}</span>`;\n            } else if (wins >= 6) {\n                // 6-7승 - 상승세\n                return `<span style=\"color: var(--success-color);\">${formattedRecord}</span>`;\n            } else if (wins >= 4) {\n                // 4-5승 - 보통\n                return `<span style=\"color: var(--warning-color);\">${formattedRecord}</span>`;\n            } else {\n                // 3승 이하 - 부진\n                return `<span style=\"color: var(--danger-color);\">${formattedRecord}</span>`;\n            }\n        }\n\n        function getStatusIndicator(team) {\n            if (team.displayRank === 1 && team.magicNumber <= 10) {\n                return '<span class=\"status-indicator clinched\">우승권</span>';\n            } else if (team.displayRank <= 5) {\n                return '<span class=\"status-indicator contending\">PO권</span>';\n            }\n            return '';\n        }\n\n        function calculateMagicNumber(firstPlace, secondPlace) {\n            // service-data.json의 매직넘버 사용\n            const magicNumbers = currentKBOData?.magicNumbers || {};\n            const teamMagicData = magicNumbers[firstPlace.team];\n            return teamMagicData ? teamMagicData.championship : 0;\n        }\n\n\n        // 1위팀 컬러로 우승 조건 섹션 꾸미기\n        function applyChampionshipTeamColors(teamData) {\n            const championshipSection = document.querySelector('.championship-section');\n            const bgAccent = document.querySelector('.championship-bg-accent');\n            const mainDisplay = document.querySelector('.championship-main-display');\n            const title = championshipSection?.querySelector('h2');\n            \n            if (!teamData || !championshipSection) return;\n            \n            // 팀 컬러를 CSS 변수로 설정\n            const teamColor = teamData.color || '#1a237e';\n            const teamColorRgb = hexToRgb(teamColor);\n            const secondaryColor = lightenColor(teamColor, 20);\n            \n            championshipSection.style.setProperty('--team-color', teamColor);\n            championshipSection.style.setProperty('--team-secondary-color', secondaryColor);\n            championshipSection.style.setProperty('--team-color-rgb', teamColorRgb);\n            \n            // 상단 액센트 바 색상\n            if (bgAccent) {\n                bgAccent.style.background = `linear-gradient(90deg, ${teamColor}, ${secondaryColor})`;\n            }\n            \n            // 메인 디스플레이 영역 색상\n            if (mainDisplay) {\n                mainDisplay.style.background = `linear-gradient(135deg, \n                    ${teamColor}08 0%, \n                    ${teamColor}15 50%, \n                    ${teamColor}08 100%)`;\n                mainDisplay.style.borderColor = `${teamColor}40`;\n                mainDisplay.style.boxShadow = `0 4px 12px ${teamColor}20, inset 0 1px 3px rgba(255, 255, 255, 0.5)`;\n            }\n            \n            // 제목 색상\n            if (title) {\n                title.style.color = teamColor;\n                title.style.textShadow = `0 1px 2px ${teamColor}20`;\n            }\n            \n            // 통계 카드들 색상\n            const statCards = championshipSection.querySelectorAll('.stat-card');\n            statCards.forEach(card => {\n                card.style.background = `linear-gradient(135deg, ${teamColor}04 0%, ${teamColor}10 100%)`;\n                card.style.borderColor = `${teamColor}25`;\n                card.style.borderTopColor = `${teamColor}60`;\n                \n                const statValue = card.querySelector('.stat-value');\n                if (statValue) {\n                    statValue.style.color = teamColor;\n                    statValue.style.textShadow = `0 1px 2px ${teamColor}15`;\n                }\n            });\n            \n            // 우승확정일 박스 색상\n            const clinchDateBox = championshipSection.querySelector('.clinch-date-box');\n            const clinchDateValue = document.getElementById('clinch-date');\n            if (clinchDateBox) {\n                clinchDateBox.style.background = `linear-gradient(135deg, ${teamColor}08 0%, ${teamColor}15 100%)`;\n                clinchDateBox.style.borderColor = `${teamColor}35`;\n                clinchDateBox.style.boxShadow = `0 4px 12px ${teamColor}20`;\n                \n                // 상단 액센트 라인\n                const topAccent = clinchDateBox.querySelector('div[style*=\"position: absolute\"]');\n                if (topAccent) {\n                    topAccent.style.background = `linear-gradient(90deg, ${teamColor}, ${secondaryColor})`;\n                }\n            }\n            \n            if (clinchDateValue) {\n                clinchDateValue.style.color = teamColor;\n                clinchDateValue.style.textShadow = `0 1px 2px ${teamColor}20`;\n            }\n        }\n        \n        // 색상 유틸리티 함수들\n        function hexToRgb(hex) {\n            const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n            return result ? \n                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : \n                '26, 35, 126';\n        }\n        \n        function lightenColor(hex, percent) {\n            const num = parseInt(hex.replace('#', ''), 16);\n            const amt = Math.round(2.55 * percent);\n            const R = (num >> 16) + amt;\n            const G = (num >> 8 & 0x00FF) + amt;\n            const B = (num & 0x0000FF) + amt;\n            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +\n                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +\n                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);\n        }\n\n        function renderChampionshipCondition() {\n            \n            if (!currentStandings || currentStandings.length === 0) {\n                logger.error('❌ currentStandings 데이터가 없습니다');\n                return;\n            }\n            \n            const firstPlace = currentStandings[0];\n            const secondPlace = currentStandings[1];\n            const teamData = kboTeams[firstPlace.team];\n            \n            \n            const totalGames = 144;\n            const remainingGames = totalGames - firstPlace.games;\n            const maxPossibleWins = firstPlace.wins + remainingGames;\n            const magicNumber = calculateMagicNumber(firstPlace, secondPlace);\n            \n            // 우승 가능 최소 승수 계산 (service-data.json의 정확한 계산 사용)\n            const magicNumbers = currentKBOData?.magicNumbers || {};\n            const teamMagicData = magicNumbers[firstPlace.team];\n            const minWinsNeeded = firstPlace.wins + (teamMagicData ? teamMagicData.championship : 0);\n            \n            // 우승 가능 최소 승수를 달성하기 위한 필요 승률 계산\n            const neededWinsForMinWins = teamMagicData ? teamMagicData.championship : 0;\n            const requiredWinPct = remainingGames > 0 ? (neededWinsForMinWins / remainingGames) : 0;\n            \n            // 144경기 체제 역대 1위 평균 기준 필요 승률 계산 (2015-2024: 86.9승)\n            const historicalFirstPlaceWins = 87; // 2015-2024년 1위팀 평균 승수\n            const neededWinsForHistorical = Math.max(0, historicalFirstPlaceWins - firstPlace.wins);\n            const historicalRequiredWinPct = remainingGames > 0 ? (neededWinsForHistorical / remainingGames) : 0;\n            \n            // 예상 우승확정일 계산\n            let clinchDateText = '';\n            \n            if (magicNumber > 0) {\n                // 매직넘버는 지금부터 필요한 승수 - 현재 경기수 + 매직넘버 = 우승확정 경기\n                const targetGameNumber = firstPlace.games + magicNumber;\n                \n                if (targetGameNumber <= totalGames) {\n                    // 잔여경기 일정에서 날짜 계산\n                    const expectedDate = calculateClinchDate(firstPlace.team, magicNumber);\n                    if (expectedDate) {\n                        clinchDateText = `${expectedDate} (${targetGameNumber}번째 경기)`;\n                    } else {\n                        clinchDateText = `${targetGameNumber}번째 경기에서 확정 가능`;\n                    }\n                } else {\n                    clinchDateText = `시즌 종료 후 (${targetGameNumber}번째 경기 필요)`;\n                }\n            } else {\n                clinchDateText = '이미 우승 확정';\n            }\n            \n            // 팀 로고와 이름 업데이트\n            document.getElementById('first-place-logo').innerHTML = teamData.logo;\n            document.getElementById('first-place-team-name').textContent = `${firstPlace.team} 1위`;\n            document.getElementById('first-place-team-name').style.color = teamData.color;\n            \n            // 1위팀 컬러로 우승 조건 섹션 꾸미기\n            applyChampionshipTeamColors(teamData);\n            \n            // 매직넘버 라인 옆 정보 업데이트\n            document.getElementById('remaining-games-top-display').textContent = `${remainingGames}경기`;\n            document.getElementById('min-wins-top-display').textContent = `${minWinsNeeded}승`;\n            \n            // 각 카드 정보 업데이트\n            document.getElementById('first-place-record').textContent = `${firstPlace.wins}승 ${firstPlace.losses}패 ${firstPlace.draws}무`;\n            document.getElementById('first-place-winpct').textContent = `${(firstPlace.winPct || firstPlace.winRate).toFixed(3)}`;\n            document.getElementById('first-place-max-wins').textContent = `${maxPossibleWins}승`;\n            const championshipMagicElement = document.getElementById('championship-magic');\n            championshipMagicElement.textContent = `매직넘버: ${magicNumber > 0 ? magicNumber : '우승확정'}`;\n            \n            // 1위 팀의 색상으로 매직넘버 스타일 설정\n            const teamColor = teamData?.color || '#FF6B35';\n            championshipMagicElement.style.color = teamColor;\n            championshipMagicElement.style.textShadow = `0 2px 8px ${teamColor}40`;\n            document.getElementById('required-winpct').textContent = neededWinsForMinWins > 0 ? `${requiredWinPct.toFixed(3)}` : '달성';\n            document.getElementById('historical-required-winpct').textContent = neededWinsForHistorical > 0 ? `${historicalRequiredWinPct.toFixed(3)}` : '달성';\n            // 모바일에서 줄바꿈을 위해 개행문자 추가 (한 줄만)\n            let formattedClinchDate = clinchDateText;\n            \n            // 각 패턴별로 줄바꿈 처리 - 한 곳에서만 줄바꿈\n            if (clinchDateText.includes('번째 경기에서 확정 가능')) {\n                formattedClinchDate = clinchDateText.replace('확정 가능 (일정', '확정 가능\\n(일정');\n            } else if (clinchDateText.includes('시즌 종료 후')) {\n                formattedClinchDate = clinchDateText.replace('시즌 종료 후', '\\n시즌 종료 후');\n            } else if (clinchDateText === '이미 우승 확정') {\n                formattedClinchDate = '이미\\n우승 확정';\n            }\n            \n            document.getElementById('clinch-date').textContent = formattedClinchDate;\n            \n            // ===========================================\n            // 새로운 확률 정보 및 역사적 비교 계산\n            // ===========================================\n            \n            // 1. 현재 승률 유지시 우승 확률 계산\n            const currentWinRate = firstPlace.winPct || firstPlace.winRate;\n            const projectedTotalWins = Math.round(currentWinRate * totalGames);\n            const secondPlaceMaxWins = (secondPlace?.wins || 0) + (totalGames - (secondPlace?.games || 0));\n            \n            let championshipProbability = 0;\n            let probabilityDetail = '';\n            \n            if (projectedTotalWins > secondPlaceMaxWins) {\n                championshipProbability = 98; // 거의 확실\n                probabilityDetail = `예상 ${projectedTotalWins}승으로 2위 최대가능승수(${secondPlaceMaxWins}승) 초과`;\n            } else if (projectedTotalWins === secondPlaceMaxWins) {\n                championshipProbability = 75; // 높은 확률\n                probabilityDetail = `예상 ${projectedTotalWins}승으로 2위와 동일 (직접대결 등 변수)`;\n            } else {\n                const gap = secondPlaceMaxWins - projectedTotalWins;\n                if (gap <= 2) {\n                    championshipProbability = 60;\n                    probabilityDetail = `예상 ${projectedTotalWins}승 (2위보다 ${gap}승 적음, 변수 존재)`;\n                } else if (gap <= 5) {\n                    championshipProbability = 35;\n                    probabilityDetail = `예상 ${projectedTotalWins}승 (2위보다 ${gap}승 적음, 어려움)`;\n                } else {\n                    championshipProbability = 10;\n                    probabilityDetail = `예상 ${projectedTotalWins}승 (2위보다 ${gap}승 적음, 매우 어려움)`;\n                }\n            }\n            \n            // 2. 최악 시나리오 계산 (연패 가능 경기수)\n            const safeWins = secondPlaceMaxWins + 1; // 안전한 승수\n            const maxConsecutiveLosses = Math.max(0, maxPossibleWins - safeWins);\n            \n            let worstScenario = '';\n            let worstScenarioDetail = '';\n            \n            if (firstPlace.wins >= safeWins) {\n                worstScenario = '이미 안전권';\n                worstScenarioDetail = `${safeWins}승 달성으로 우승 확정`;\n            } else if (maxConsecutiveLosses >= remainingGames) {\n                worstScenario = '모든 경기 패배 가능';\n                worstScenarioDetail = `${remainingGames}경기 모두 져도 우승 가능`;\n            } else if (maxConsecutiveLosses > 0) {\n                worstScenario = `최대 ${maxConsecutiveLosses}연패 가능`;\n                worstScenarioDetail = `${maxConsecutiveLosses + 1}연패시 우승 위험`;\n            } else {\n                worstScenario = '모든 경기 승리 필요';\n                worstScenarioDetail = '한 경기라도 지면 우승 어려움';\n            }\n            \n            // 3. 역사적 비교 계산\n            const currentDate = new Date();\n            const isAugustMid = currentDate.getMonth() === 7 && currentDate.getDate() >= 15; // 8월 중순\n            \n            // 8월 중순 기준 역대 1위팀 평균 (대략적 계산)\n            const gamesPlayedByAugust = Math.min(firstPlace.games, 100); // 8월 중순까지 대략 100경기\n            const historicalAugustWins = Math.round(gamesPlayedByAugust * 0.620); // 역대 1위팀 평균 승률\n            const historicalAugustWinRate = 0.620;\n            \n            // 현재 팀과 역대 평균 비교\n            const currentVsHistorical = firstPlace.wins - historicalAugustWins;\n            let historicalComparison = '';\n            if (currentVsHistorical > 0) {\n                historicalComparison = `${currentVsHistorical}승 앞서는 중`;\n            } else if (currentVsHistorical < 0) {\n                historicalComparison = `${Math.abs(currentVsHistorical)}승 뒤처진 상황`;\n            } else {\n                historicalComparison = '역대 평균과 동일';\n            }\n            \n            // 현재 페이스로 시즌 종료시 예상 승수\n            const currentPaceWins = Math.round(currentWinRate * totalGames);\n            let championComparison = '';\n            if (currentPaceWins >= 87) {\n                championComparison = `역대 평균(86.9승)보다 ${currentPaceWins - 87}승 많음`;\n            } else {\n                championComparison = `역대 평균(86.9승)보다 ${87 - currentPaceWins}승 적음`;\n            }\n            \n        }\n\n        function renderChaseAnalysis() {\n            try {\n                const tbody = document.querySelector('#chase-table tbody');\n                if (!tbody) {\n                    throw new Error('1위 탈환 가능성 테이블을 찾을 수 없습니다');\n                }\n                tbody.innerHTML = '';\n\n                if (!currentStandings || currentStandings.length === 0) {\n                    throw new Error('순위 데이터가 없습니다');\n                }\n\n                const firstPlace = currentStandings[0];\n                \n                // 144경기 체제 역대 1위 평균 승수 (2015-2024: 86.9승)\n                const historicalFirstPlaceWins = 87; // 2015-2024년 1위팀 평균 승수\n\n                currentStandings.forEach((team, index) => {\n                const teamData = kboTeams[team.team];\n                const remainingGames = 144 - team.games;\n                const maxPossibleWins = team.wins + remainingGames;\n                const firstPlaceRemaining = 144 - firstPlace.games;\n                \n                // 1위 탈환 트래직넘버 계산\n                const firstPlaceTragic = calculateFirstPlaceTragicNumber(team, currentStandings, index);\n                \n                // 1위팀과 2위 이하 팀별로 다른 로직 적용\n                let requiredFirstPlaceWins, canCatch, winPctColor, winPctDisplay, canReachHistoricalAverage;\n                \n                if (team.displayRank === 1) {\n                    // 1위팀: 현재 우승 상황 표시\n                    requiredFirstPlaceWins = '-';\n                    canCatch = '현재 1위';\n                    \n                    // 역대 1위 평균 달성 가능성\n                    canReachHistoricalAverage = maxPossibleWins >= historicalFirstPlaceWins;\n                    \n                    // 87승까지 필요한 승률\n                    const neededWinsForHistoricalAverage = Math.max(0, historicalFirstPlaceWins - team.wins);\n                    const requiredWinPctForAverage = remainingGames > 0 ? \n                        neededWinsForHistoricalAverage / remainingGames : 0;\n                    \n                    // 역대 1위 기준 필요 승률 표시 로직 (1위팀용)\n                    if (maxPossibleWins < historicalFirstPlaceWins || requiredWinPctForAverage > 1.0) {\n                        // 최대가능 승수가 87 미만이거나 필요 승률이 1.0 초과하면 불가능\n                        winPctColor = '#c0392b';\n                        winPctDisplay = '불가능';\n                    } else if (neededWinsForHistoricalAverage === 0) {\n                        winPctColor = '#27ae60';\n                        winPctDisplay = '달성';\n                    } else {\n                        winPctColor = '#3498db';\n                        winPctDisplay = requiredWinPctForAverage.toFixed(3);\n                    }\n                } else {\n                    // 2위 이하팀: 기존 로직\n                    requiredFirstPlaceWins = maxPossibleWins - 1;\n                    // canCatch는 나중에 트래직넘버 기준으로 결정\n                    \n                    // 역대 1위 평균 기준으로 필요 승률 계산\n                    const neededWinsForHistoricalAverage = Math.max(0, historicalFirstPlaceWins - team.wins);\n                    const requiredWinPctForAverage = remainingGames > 0 ? \n                        neededWinsForHistoricalAverage / remainingGames : 0;\n                    \n                    // 144경기 체제 역대 1위 성적 달성 가능성 (87승 달성 가능한지)\n                    canReachHistoricalAverage = maxPossibleWins >= historicalFirstPlaceWins;\n                    \n                    // 역대 1위 기준 필요 승률 표시 로직\n                    if (maxPossibleWins < historicalFirstPlaceWins || requiredWinPctForAverage > 1.0) {\n                        // 최대가능 승수가 87 미만이거나 필요 승률이 1.0 초과하면 불가능\n                        winPctColor = '#c0392b';\n                        winPctDisplay = '불가능';\n                    } else if (neededWinsForHistoricalAverage === 0) {\n                        winPctColor = '#27ae60';\n                        winPctDisplay = '달성';\n                    } else if (requiredWinPctForAverage > 0.700) {\n                        winPctColor = '#2c3e50';\n                        winPctDisplay = requiredWinPctForAverage.toFixed(3);\n                    } else if (requiredWinPctForAverage > 0.650) {\n                        winPctColor = '#e74c3c';\n                        winPctDisplay = requiredWinPctForAverage.toFixed(3);\n                    } else if (requiredWinPctForAverage > 0.550) {\n                        winPctColor = '#e67e22';\n                        winPctDisplay = requiredWinPctForAverage.toFixed(3);\n                    } else if (requiredWinPctForAverage > 0.450) {\n                        winPctColor = '#f1c40f';\n                        winPctDisplay = requiredWinPctForAverage.toFixed(3);\n                    } else {\n                        winPctColor = '#27ae60';\n                        winPctDisplay = requiredWinPctForAverage.toFixed(3);\n                    }\n                }\n                \n                const row = document.createElement('tr');\n                row.style.borderLeft = `4px solid ${teamData.color}`;\n                \n                // 순위별 클래스 적용\n                let rankClass = '';\n                if (team.displayRank === 1) {\n                    rankClass = 'rank-1 first-place-row';\n                    // 1위팀에 팀 컬러 테두리와 배경 적용\n                    row.style.border = `3px solid ${teamData.color}`;\n                    row.style.boxShadow = `0 0 12px ${teamData.color}30`;\n                    row.style.background = `linear-gradient(135deg, ${teamData.color}08 0%, ${teamData.color}15 100%)`;\n                    row.style.borderRadius = '8px';\n                } else if (team.displayRank === 2) rankClass = 'rank-2';\n                else if (team.displayRank === 3) rankClass = 'rank-3';\n                else if (team.displayRank >= 4 && team.displayRank <= 5) rankClass = 'playoff';\n                row.className = rankClass;\n                \n                // 팀명에 로고 추가\n                const teamNameWithLogo = Utils.getTeamNameWithLogo(team);\n                \n                // 1위팀인 경우 특별 스타일링\n                const isFirstPlace = team.displayRank === 1;\n                const textColor = isFirstPlace ? teamData.color : '#666';\n                \n                // 1위 탈환 트래직넘버 표시 텍스트 생성\n                let tragicDisplay, tragicColor;\n                if (team.displayRank === 1) {\n                    tragicDisplay = '-';\n                    tragicColor = teamData.color;\n                } else if (firstPlaceTragic === 999) {\n                    tragicDisplay = '불가능';\n                    tragicColor = '#e74c3c';\n                    // 트래직넘버가 불가능이면 탈환도 불가능\n                    canCatch = '불가능';\n                } else if (firstPlaceTragic === 0) {\n                    tragicDisplay = '0';\n                    tragicColor = '#f39c12'; // 주황색 - 임계점\n                    // 트래직넘버가 0이면 아직 탈환 가능하지만 임계 상황\n                    canCatch = '가능';\n                } else {\n                    tragicDisplay = firstPlaceTragic;\n                    tragicColor = textColor; // 기본 텍스트 색상 사용\n                    // 트래직넘버가 양수면 아직 탈환 가능\n                    canCatch = '가능';\n                }\n                \n                // 탈환 가능 여부에 따른 색상 결정 (canCatch 값 결정 후)\n                const catchColor = isFirstPlace ? teamData.color : \n                    (canCatch === '가능' ? '#27ae60' : \n                     canCatch === '불가능' ? '#e74c3c' : '#3498db');\n                \n                row.innerHTML = `\n                    <td style=\"color: ${teamData.color}; font-weight: ${isFirstPlace ? '700' : '600'};\">${team.displayRank}</td>\n                    <td class=\"team-name\" style=\"font-weight: ${isFirstPlace ? '600' : 'normal'};\">${teamNameWithLogo}</td>\n                    <td style=\"color: ${textColor}; font-weight: ${isFirstPlace ? '600' : 'normal'};\">${team.wins}</td>\n                    <td style=\"color: ${textColor}; font-weight: ${isFirstPlace ? '600' : 'normal'};\">${team.gamesBehind === 0 ? '-' : team.gamesBehind}</td>\n                    <td style=\"color: ${textColor}; font-weight: ${isFirstPlace ? '600' : 'normal'};\">${remainingGames}</td>\n                    <td style=\"color: ${textColor}; font-weight: ${isFirstPlace ? '600' : 'normal'};\">${maxPossibleWins}</td>\n                    <td style=\"color: ${textColor}; font-weight: ${isFirstPlace ? '600' : 'normal'};\">${typeof requiredFirstPlaceWins === 'string' ? requiredFirstPlaceWins : requiredFirstPlaceWins + '승 이하'}</td>\n                    <td style=\"color: ${tragicColor}; font-weight: ${isFirstPlace ? '700' : '600'}; text-shadow: ${isFirstPlace ? `0 1px 2px ${teamData.color}20` : 'none'};\">\n                        ${tragicDisplay}\n                    </td>\n                    <td style=\"color: ${catchColor}; font-weight: ${isFirstPlace ? '700' : '600'}; text-shadow: ${isFirstPlace ? `0 1px 2px ${teamData.color}20` : 'none'};\">\n                        ${typeof canCatch === 'string' ? canCatch : (canCatch ? '가능' : '불가능')}\n                    </td>\n                    <td style=\"color: ${isFirstPlace ? teamData.color : winPctColor}; font-weight: ${isFirstPlace ? '600' : 'normal'};\">${winPctDisplay}</td>\n                    <td style=\"color: ${canReachHistoricalAverage ? '#27ae60' : '#e74c3c'}; font-weight: ${isFirstPlace ? '600' : 'normal'};\">\n                        ${canReachHistoricalAverage ? '가능' : '불가능'}\n                    </td>\n                `;\n                tbody.appendChild(row);\n            });\n            } catch (error) {\n                handleError(error, '1위 탈환 가능성 렌더링 실패');\n                const tbody = document.querySelector('#chase-table tbody');\n                if (tbody) {\n                    tbody.innerHTML = '<tr><td colspan=\"11\" style=\"text-align: center; color: #999; padding: 20px;\">데이터를 불러오는 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.</td></tr>';\n                }\n            }\n        }\n\n        \n        // 🏟️ 플레이오프 진출 조건 테이블 렌더링 함수\n        // HTML의 #playoff-table에 데이터를 표시하는 함수\n        function renderPlayoffCondition() {\n            try {\n                const tbody = document.querySelector('#playoff-table tbody');\n                if (!tbody) {\n                    throw new Error('플레이오프 진출 조건 테이블을 찾을 수 없습니다');\n                }\n                tbody.innerHTML = '';\n\n                // currentStandings로 직접 계산\n                if (!currentStandings || currentStandings.length === 0) {\n                    tbody.innerHTML = '<tr><td colspan=\"11\">데이터 로딩 중...</td></tr>';\n                    return;\n                }\n                \n                // 플레이오프 확정 팀 찾기 및 표시\n                const confirmedTeams = [];\n                currentStandings.forEach(team => {\n                    const poMagicNumber = Utils.getWinsBasedMagicNumber(team);\n                    if (poMagicNumber === 0 && !Utils.isTeamEliminated(team)) {\n                        confirmedTeams.push({\n                            name: team.team,\n                            rank: team.rank || team.displayRank\n                        });\n                    }\n                });\n                \n                // 플레이오프 확정 팀 배너 업데이트 (배너가 존재하는 경우에만)\n                const banner = document.getElementById('playoff-confirmed-banner');\n                const teamsContainer = document.getElementById('playoff-confirmed-teams');\n                \n                if (banner && teamsContainer && confirmedTeams.length > 0) {\n                    banner.style.display = 'block';\n                    teamsContainer.innerHTML = confirmedTeams\n                        .sort((a, b) => a.rank - b.rank)\n                        .map(team => {\n                            const teamData = kboTeams[team.name];\n                            const bgColor = teamData ? teamData.bg : '#f0f0f0';\n                            const textColor = teamData ? teamData.color : '#333';\n                            return `\n                                <div style=\"padding: 8px 12px; background: ${bgColor}; color: ${textColor}; border-radius: 6px; font-weight: 600; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);\">\n                                    ${team.rank}위 ${team.name}\n                                </div>\n                            `;\n                        }).join('');\n                } else if (banner) {\n                    banner.style.display = 'none';\n                }\n                \n                currentStandings.forEach((team, index) => {\n                const teamData = kboTeams[team.team];\n                \n                // displayRank 설정\n                if (!team.displayRank && !team.rank) {\n                    team.displayRank = index + 1;\n                } else {\n                    team.displayRank = team.displayRank || team.rank;\n                }\n                \n                const remainingGames = 144 - team.games;\n                const maxPossibleWins = team.wins + remainingGames;\n                \n                // 최대가능승수 기준으로 순위를 매겨서 5위 팀 찾기\n                const teamsWithMaxWins = currentStandings.map(t => ({\n                    ...t,\n                    maxPossibleWins: t.wins + (144 - t.games)\n                })).sort((a, b) => b.maxPossibleWins - a.maxPossibleWins);\n                \n                // 최대가능승수 기준 5위 팀의 최대가능승수가 \"최종 5위 예상 승수\"\n                const fifthPlaceMaxWins = teamsWithMaxWins[4] ? teamsWithMaxWins[4].maxPossibleWins : 72;\n                \n                // Utils.calculatePlayoffMagicNumber 사용하여 통일된 로직 적용\n                const poMagicNumber = Utils.getWinsBasedMagicNumber(team);\n                \n                // 탈락 여부 먼저 확인 (현재 5위 팀 승률 vs 내 최대 가능 승률)\n                const currentFifthPlace = currentStandings.find(t => t.rank === 5) || currentStandings.find(t => t.rank === 4);\n                const currentFifthWinRate = currentFifthPlace ? currentFifthPlace.wins / (currentFifthPlace.wins + currentFifthPlace.losses) : 0;\n                const myMaxWinRate = maxPossibleWins / (maxPossibleWins + team.losses);\n                \n                // PO 트래직넘버 미리 계산하여 탈락 여부 확인\n                let tragicFifthPlace = null;\n                if (currentStandings.length >= 5) {\n                    tragicFifthPlace = currentStandings[4]; // 5위 팀\n                } else if (currentStandings.length >= 4) {\n                    tragicFifthPlace = currentStandings[3]; // 4위 팀\n                }\n                \n                let poTragicNumber = 0;\n                if (tragicFifthPlace) {\n                    poTragicNumber = maxPossibleWins - (tragicFifthPlace.wins - 1);\n                }\n                \n                // 표시 형식 결정\n                let maxWinsMagicDisplay = '';\n                if (currentFifthWinRate > myMaxWinRate || poTragicNumber <= 0) {\n                    // 현재 5위 팀 승률보다 내 최대 가능 승률이 낮거나 트래직넘버가 0 이하면 탈락\n                    maxWinsMagicDisplay = '<span style=\"color: #c0392b;\">탈락</span>';\n                } else if (poMagicNumber === 0 && !Utils.isTeamEliminated(team)) {\n                    maxWinsMagicDisplay = '0';\n                } else if (poMagicNumber > remainingGames) {\n                    maxWinsMagicDisplay = `${poMagicNumber} <span style=\"color: #c0392b;\">(자력불가)</span>`;\n                } else {\n                    maxWinsMagicDisplay = poMagicNumber;\n                }\n                \n                // PO 진출 상황 결정\n                let poStatus = '';\n                \n                // 5개 팀이 진출 확정되었는지 확인 (매직넘버 0인 팀 수)\n                const confirmedTeams = currentStandings.filter(t => {\n                    const teamPoMagicNumber = Utils.getWinsBasedMagicNumber(t);\n                    return teamPoMagicNumber === 0;\n                }).length;\n                \n                if (currentFifthWinRate > myMaxWinRate || poTragicNumber <= 0) {\n                    // 현재 5위 팀 승률보다 최대 가능 승률이 낮거나 트래직넘버가 0 이하면 탈락\n                    poStatus = '<span style=\"color: #c0392b;\">탈락</span>';\n                } else if (poMagicNumber === 0 && !Utils.isTeamEliminated(team)) {\n                    // 매직넘버가 0이고 탈락이 아니면 진출 확정\n                    poStatus = '<span style=\"color: #2ecc71;\">진출</span>';\n                } else if (confirmedTeams >= 5 && poMagicNumber > 0) {\n                    // 5개팀이 이미 확정되고 본인은 확정이 아니면 탈락\n                    poStatus = '<span style=\"color: #c0392b;\">탈락</span>';\n                } else {\n                    // 그 외의 경우는 -\n                    poStatus = '-';\n                }\n                \n                // PO 트래직넘버 표시 (이미 위에서 계산됨)\n                let poTragicDisplay = '';\n                \n                if (!tragicFifthPlace) {\n                    poTragicDisplay = '0';\n                } else {\n                    if (poTragicNumber <= 0) {\n                        poTragicDisplay = '<span style=\"color: #c0392b;\">탈락</span>';\n                    } else {\n                        poTragicDisplay = poTragicNumber;\n                    }\n                }\n                \n                // 역대 기준 매직넘버 계산 (72승 기준)\n                const playoffThreshold = 72;\n                const historicMagic = Math.max(0, playoffThreshold - team.wins);\n                let magicDisplay = '';\n                \n                if (historicMagic === 0) {\n                    magicDisplay = '<span style=\"color: #2ecc71; font-weight: bold;\">달성</span>';\n                } else if (historicMagic > remainingGames) {\n                    // 잔여경기를 모두 이겨도 72승 불가능\n                    magicDisplay = '<span style=\"color: #c0392b; font-weight: bold;\">탈락</span>';\n                } else if (historicMagic <= 3) {\n                    magicDisplay = `<span style=\"color: #2ecc71; font-weight: bold;\">${historicMagic}</span>`;\n                } else if (historicMagic <= 6) {\n                    magicDisplay = `<span style=\"color: #27ae60;\">${historicMagic}</span>`;\n                } else if (historicMagic <= 10) {\n                    magicDisplay = `<span style=\"color: #f39c12;\">${historicMagic}</span>`;\n                } else if (historicMagic <= 15) {\n                    magicDisplay = `<span style=\"color: #e67e22;\">${historicMagic}</span>`;\n                } else if (historicMagic <= 25) {\n                    magicDisplay = `<span style=\"color: #e74c3c;\">${historicMagic}</span>`;\n                } else {\n                    magicDisplay = `<span style=\"color: #c0392b;\">${historicMagic}</span>`;\n                }\n                \n                // 진출상황을 72승 기준으로 명확하게 정의\n                let displayStatus = '';\n                let statusColor = '';\n                \n                // 72승 기준으로 진출/탈락 확정 여부 판단\n                if (team.wins >= 72) {\n                    // 이미 72승 달성\n                    displayStatus = '진출 확정';\n                    statusColor = '#2ecc71'; // 밝은 녹색\n                } else if (maxPossibleWins < 72) {\n                    // 전승해도 72승 불가능\n                    displayStatus = '탈락 확정';\n                    statusColor = '#95a5a6'; // 회색\n                } else {\n                    // 72승 가능하지만 미달성 - 필요 승률에 따라 구분\n                    const neededWins = 72 - team.wins;\n                    const actualRequiredRate = neededWins / remainingGames;\n                    \n                    if (actualRequiredRate > 0.9) {\n                        displayStatus = '극히 어려움';\n                        statusColor = '#c0392b'; // 진한 빨간색\n                    } else if (actualRequiredRate > 0.75) {\n                        displayStatus = '매우 어려움';\n                        statusColor = '#e74c3c'; // 빨간색\n                    } else if (actualRequiredRate > 0.6) {\n                        displayStatus = '어려움';\n                        statusColor = '#e67e22'; // 진한 주황색\n                    } else if (actualRequiredRate > 0.45) {\n                        displayStatus = '경합중';\n                        statusColor = '#f39c12'; // 주황색\n                    } else if (actualRequiredRate > 0.3) {\n                        displayStatus = '유력';\n                        statusColor = '#f1c40f'; // 노란색\n                    } else {\n                        displayStatus = '매우 유력';\n                        statusColor = '#27ae60'; // 녹색\n                    }\n                }\n                \n                // 필요 승률 색상 (그라데이션 구분)\n                let requiredWinPctColor = '#666';\n                if (team.requiredWinRate > 0) {\n                    if (team.requiredWinRate <= 0.3) {\n                        requiredWinPctColor = '#2ecc71'; // 밝은 녹색 (매우 쉬움)\n                    } else if (team.requiredWinRate <= 0.5) {\n                        requiredWinPctColor = '#f39c12'; // 주황색 (보통)\n                    } else if (team.requiredWinRate <= 0.7) {\n                        requiredWinPctColor = '#e67e22'; // 진한 주황색 (어려움)\n                    } else if (team.requiredWinRate <= 0.85) {\n                        requiredWinPctColor = '#e74c3c'; // 빨간색 (매우 어려움)\n                    } else {\n                        requiredWinPctColor = '#c0392b'; // 진한 빨간색 (거의 불가능)\n                    }\n                }\n\n                const row = document.createElement('tr');\n                \n                // 팀명에 로고 추가\n                const teamNameWithLogo = Utils.getTeamNameWithLogo(team);\n                \n                // 역대 기준 트래직넘버 계산 (71승 기준)\n                const tragicThreshold = 71;\n                const historicTragicNumber = maxPossibleWins < tragicThreshold ? 0 : tragicThreshold - maxPossibleWins;\n                let historicTragicDisplay = '';\n                \n                if (historicTragicNumber === 0) {\n                    if (maxPossibleWins < tragicThreshold) {\n                        historicTragicDisplay = '<span style=\"color: #c0392b; font-weight: bold;\">탈락</span>';\n                    } else {\n                        historicTragicDisplay = '<span style=\"color: #2ecc71; font-weight: bold;\">안전</span>';\n                    }\n                } else {\n                    const absNumber = Math.abs(historicTragicNumber);\n                    if (absNumber <= 3) {\n                        historicTragicDisplay = `<span style=\"color: #c0392b; font-weight: bold;\">-${absNumber}</span>`;\n                    } else if (absNumber <= 6) {\n                        historicTragicDisplay = `<span style=\"color: #e74c3c;\">-${absNumber}</span>`;\n                    } else if (absNumber <= 10) {\n                        historicTragicDisplay = `<span style=\"color: #e67e22;\">-${absNumber}</span>`;\n                    } else if (absNumber <= 15) {\n                        historicTragicDisplay = `<span style=\"color: #f39c12;\">-${absNumber}</span>`;\n                    } else if (absNumber <= 25) {\n                        historicTragicDisplay = `<span style=\"color: #27ae60;\">-${absNumber}</span>`;\n                    } else {\n                        historicTragicDisplay = `<span style=\"color: #2ecc71;\">-${absNumber}</span>`;\n                    }\n                }\n                \n                // PO 진출을 위한 필요 승률 계산\n                let poRequiredWinPct = '';\n                if (currentFifthWinRate > myMaxWinRate || poTragicNumber <= 0) {\n                    poRequiredWinPct = '<span style=\"color: #c0392b;\">탈락</span>';\n                } else if (poMagicNumber === 0 && !Utils.isTeamEliminated(team)) {\n                    poRequiredWinPct = '<span style=\"color: #2ecc71;\">확정</span>';\n                } else if (remainingGames > 0) {\n                    const poRequiredRate = poMagicNumber / remainingGames;\n                    if (poRequiredRate > 1.0) {\n                        poRequiredWinPct = '<span style=\"color: #c0392b;\">자력불가</span>';\n                    } else {\n                        poRequiredWinPct = poRequiredRate.toFixed(3);\n                    }\n                } else {\n                    poRequiredWinPct = '-';\n                }\n                \n                // 역대 기준 필요 승률 계산 및 표시 (72승 기준)\n                let requiredWinPct = '';\n                const requiredRate = remainingGames > 0 ? historicMagic / remainingGames : 0;\n                \n                if (requiredRate === 0) {\n                    requiredWinPct = '<span style=\"color: #2ecc71;\">달성</span>';\n                } else if (requiredRate > 1.0) {\n                    requiredWinPct = '<span style=\"color: #c0392b;\">탈락</span>';\n                } else {\n                    requiredWinPct = requiredRate.toFixed(3);\n                }\n                \n                row.innerHTML = `\n                    <td>${team.displayRank}위</td>\n                    <td class=\"team-name\">${teamNameWithLogo}</td>\n                    <td>${team.wins}</td>\n                    <td>${remainingGames}</td>\n                    <td>${maxPossibleWins}</td>\n                    <td class=\"po-magic\" style=\"text-align: center;\">${maxWinsMagicDisplay}</td>\n                    <td class=\"po-tragic\" style=\"text-align: center;\">${poTragicDisplay}</td>\n                    <td class=\"po-required-winpct\" style=\"text-align: center;\">${poRequiredWinPct}</td>\n                    <td class=\"po-status\" style=\"text-align: center;\">${poStatus}</td>\n                    <td class=\"historic-magic\" style=\"text-align: center;\">${magicDisplay}</td>\n                    <td class=\"historic-tragic\" style=\"text-align: center;\">${historicTragicDisplay}</td>\n                    <td class=\"required-rate\">${requiredWinPct}</td>\n                    <td class=\"status-text\">${displayStatus}</td>\n                `;\n                tbody.appendChild(row);\n            });\n            \n            \n            } catch (error) {\n                logger.error('❌ 플레이오프 진출 조건 렌더링 실패:', error);\n            }\n        }\n\n\n        function determineCellData(team, rankPosition, championshipMagic, playoffMagic, tragicNumber, teamIndex) {\n            // 나무위키 스타일 매직넘버 차트 색상 결정 로직\n            const currentRank = teamIndex + 1; // 1-based rank\n            \n            // 1위 열: 우승 매직넘버\n            if (rankPosition === 1) {\n                if (championshipMagic > 0 && championshipMagic <= 50) {\n                    // 확정 상황 체크\n                    if (championshipMagic === 0 || (currentRank === 1 && championshipMagic <= 3)) {\n                        return { display: '우승확정', cssClass: 'namu-clinched-blue' };\n                    }\n                    \n                    // 나무위키 스타일 색상 결정\n                    const cssClass = getColorByNamuWikiLogic(currentRank, rankPosition, championshipMagic);\n                    return { display: championshipMagic.toString(), cssClass: cssClass };\n                }\n                return { display: '', cssClass: '' };\n            }\n            \n            // 2-5위 열: 해당 순위 달성 매직넘버\n            if (rankPosition >= 2 && rankPosition <= 5) {\n                const targetMagic = calculateRankMagic(team, currentStandings, rankPosition - 1);\n                if (targetMagic > 0 && targetMagic <= 50) {\n                    // 확정 상황 체크\n                    if (targetMagic === 0 || (currentRank <= rankPosition && targetMagic <= 3)) {\n                        const confirmText = rankPosition === 2 ? '2위확정' : \n                                          rankPosition === 3 ? '3위확정' : \n                                          rankPosition === 4 ? '4위확정' : '5위확정';\n                        return { display: confirmText, cssClass: 'namu-clinched-blue' };\n                    }\n                    \n                    // 나무위키 스타일 색상 결정\n                    const cssClass = getColorByNamuWikiLogic(currentRank, rankPosition, targetMagic);\n                    return { display: targetMagic.toString(), cssClass: cssClass };\n                }\n            }\n            \n            // 6-9위 열: 해당 순위까지 떨어질 트래직넘버\n            if (rankPosition >= 6 && rankPosition <= 9) {\n                const dropMagic = calculateDropRankMagic(team, currentStandings, rankPosition - 1);\n                if (dropMagic > 0 && dropMagic <= 50) {\n                    // 탈락 확정 상황 체크\n                    if (dropMagic === 0 || (currentRank >= rankPosition && dropMagic <= 3)) {\n                        return { display: '탈락확정', cssClass: 'namu-eliminated' };\n                    }\n                    \n                    // 나무위키 스타일 색상 결정\n                    const cssClass = getColorByNamuWikiLogic(currentRank, rankPosition, dropMagic);\n                    return { display: dropMagic.toString(), cssClass: cssClass };\n                }\n            }\n\n            // 빈 셀 (최소화)\n            return { display: '', cssClass: '' };\n        }\n\n        // 나무위키 스타일 색상 결정 로직\n        function getColorByNamuWikiLogic(currentRank, targetRank, magicNumber) {\n            // 40 이상이면 대부분 경합(노란색)\n            if (magicNumber >= 40) {\n                return 'namu-competitive';\n            }\n            \n            // 현재 순위와 목표 순위 비교\n            if (currentRank >= targetRank) {\n                // 현재 순위 >= 목표 순위: 매직넘버 가능성 (초록색)\n                // 단, 매직넘버가 너무 크면 경합(노란색)\n                if (magicNumber >= 25) {\n                    return 'namu-competitive';\n                } else {\n                    return 'namu-magic';\n                }\n            } else {\n                // 현재 순위 < 목표 순위: 트래직넘버 가능성 (빨간색)\n                // 단, 매직넘버가 크면 경합(노란색)으로 완화\n                if (magicNumber >= 30) {\n                    return 'namu-competitive';\n                } else {\n                    return 'namu-tragic';\n                }\n            }\n        }\n\n        // 특정 순위 도달을 위한 매직넘버 계산\n        function calculateRankMagic(team, standings, targetRank) {\n            const totalGames = 144;\n            const remainingGames = totalGames - team.games;\n            \n            if (targetRank >= 0 && targetRank < standings.length) {\n                const targetTeam = standings[targetRank];\n                const targetMaxWins = targetTeam.wins + (totalGames - targetTeam.games);\n                const magicNumber = Math.max(0, targetMaxWins - team.wins + 1);\n                \n                // 이미 목표 달성했거나 불가능한 경우 처리\n                if (team.wins > targetMaxWins) return 0;\n                if (team.wins + remainingGames < targetTeam.wins) return 999;\n                \n                return Math.min(magicNumber, remainingGames);\n            }\n            return 0;\n        }\n\n        // 현재 순위 유지를 위한 매직넘버 계산  \n        function calculateMaintainRankMagic(team, standings, currentIndex) {\n            const totalGames = 144;\n            \n            if (currentIndex + 1 < standings.length) {\n                const nextTeam = standings[currentIndex + 1];\n                const nextMaxWins = nextTeam.wins + (totalGames - nextTeam.games);\n                return Math.max(0, nextMaxWins - team.wins + 1);\n            }\n            return 0;\n        }\n\n        // 특정 순위로 떨어질 위험을 나타내는 트래직넘버 계산\n        function calculateDropRankMagic(team, standings, dropToRank) {\n            const totalGames = 144;\n            const remainingGames = totalGames - team.games;\n            \n            if (dropToRank >= 0 && dropToRank < standings.length) {\n                const dropToTeam = standings[dropToRank];\n                const dropToMaxWins = dropToTeam.wins + (totalGames - dropToTeam.games);\n                \n                // 우리가 모든 경기를 져도 해당 순위로 떨어지지 않으면\n                if (team.wins > dropToMaxWins) return 999;\n                \n                // 해당 순위까지 떨어지려면 몇 경기를 더 져야 하는가\n                const magicNumber = Math.max(0, dropToMaxWins - team.wins + 1);\n                return Math.min(magicNumber, remainingGames);\n            }\n            return 0;\n        }\n\n        function calculateChampionshipMagic(team, rankings, index) {\n            const totalGames = 144;\n            const remainingGames = totalGames - team.games;\n            \n            if (index === 0) {\n                // 현재 1위 - 우승 확정까지\n                const secondPlace = rankings[1];\n                if (!secondPlace) return 0;\n                const secondMaxWins = secondPlace.wins + (totalGames - secondPlace.games);\n                return Math.max(0, secondMaxWins - team.wins + 1);\n            } else {\n                // 1위가 아님 - 1위 추월까지\n                const firstPlace = rankings[0];\n                const maxPossibleWins = team.wins + remainingGames;\n                if (maxPossibleWins <= firstPlace.wins) return 999;\n                return Math.max(0, firstPlace.wins - team.wins + 1);\n            }\n        }\n\n        function calculatePlayoffMagic(team, rankings, index) {\n            const totalGames = 144;\n            const playoffSpots = 5;\n            const remainingGames = totalGames - team.games;\n            \n            if (index < playoffSpots) {\n                // 현재 플레이오프 권 내\n                const sixthPlace = rankings[playoffSpots];\n                if (!sixthPlace) return 0;\n                const sixthMaxWins = sixthPlace.wins + (totalGames - sixthPlace.games);\n                return Math.max(0, sixthMaxWins - team.wins + 1);\n            } else {\n                // 플레이오프 권 밖\n                const fifthPlace = rankings[playoffSpots - 1];\n                const maxPossibleWins = team.wins + remainingGames;\n                if (maxPossibleWins <= fifthPlace.wins) return 999;\n                return Math.max(0, fifthPlace.wins - team.wins + 1);\n            }\n        }\n\n        function calculateTragicNumber(team, rankings, index) {\n            const totalGames = 144;\n            const remainingGames = totalGames - team.games;\n            const playoffSpots = 5;\n            \n            if (index < playoffSpots) {\n                // 플레이오프 권 내 - 탈락까지\n                const sixthPlace = rankings[playoffSpots];\n                if (!sixthPlace) return 999;\n                const minPossibleWins = team.wins;\n                const sixthMinWins = sixthPlace.wins;\n                if (minPossibleWins > sixthMinWins) return 999;\n                return Math.max(0, remainingGames - (team.wins - sixthPlace.wins) + 1);\n            } else {\n                // 플레이오프 권 밖\n                const baselineWins = 71; // 플레이오프 진출 기준선\n                const maxPossibleWins = team.wins + remainingGames;\n                if (maxPossibleWins >= baselineWins) {\n                    return Math.max(0, maxPossibleWins - baselineWins + 1);\n                }\n                return 0; // 이미 탈락\n            }\n        }\n\n        // 1위 탈환을 위한 트래직넘버 계산 (승률 기준, 승수 표시)\n        function calculateFirstPlaceTragicNumber(team, rankings, index) {\n            const totalGames = 144;\n            const remainingGames = totalGames - team.games;\n            \n            // 1위팀 정보\n            const firstPlace = rankings[0];\n            if (!firstPlace || team.team === firstPlace.team) {\n                return 0; // 이미 1위이거나 1위팀 정보가 없음\n            }\n            \n            // 현재 팀의 최대 가능 승률 계산\n            const teamMaxPossibleWins = team.wins + remainingGames;\n            const teamMaxPossibleWinRate = teamMaxPossibleWins / (teamMaxPossibleWins + team.losses);\n            \n            // 1위팀 잔여 경기 계산\n            const firstRemainingGames = totalGames - firstPlace.games;\n            \n            // 1위팀의 최저 가능 승률과 현재 팀의 최대 승률 비교\n            const firstMinWins = firstPlace.wins; // 1위팀이 전패할 때의 승수\n            const firstMinWinRate = firstMinWins / (firstMinWins + firstPlace.losses + firstRemainingGames);\n            \n            // 현재 팀이 전승해도 1위팀이 전패했을 때의 승률을 못 넘으면 1위 탈환 불가능\n            if (teamMaxPossibleWinRate <= firstMinWinRate) {\n                return 999; // 1위 탈환 불가능\n            }\n            \n            // 1위팀이 몇 승을 더 해야 현재 팀의 최대 승률을 넘는지 계산\n            \n            for (let additionalWins = 0; additionalWins <= firstRemainingGames; additionalWins++) {\n                const firstFinalWins = firstPlace.wins + additionalWins;\n                const firstFinalLosses = firstPlace.losses + (firstRemainingGames - additionalWins);\n                const firstFinalWinRate = firstFinalWins / (firstFinalWins + firstFinalLosses);\n                \n                // 1위팀의 최종 승률이 현재 팀의 최대 승률을 넘는지 확인\n                if (firstFinalWinRate > teamMaxPossibleWinRate) {\n                    return additionalWins; // 1위팀이 이만큼 승리하면 현재 팀이 1위 탈환 불가\n                }\n            }\n            \n            // 1위팀이 전패해도 현재 팀의 최대 승률을 넘지 못함 (1위 탈환 가능)\n            return 0;\n        }\n\n        function determineTeamStatus(team, championshipMagic, playoffMagic, tragicNumber, index) {\n            // 우승 확정\n            if (championshipMagic === 0 || (index === 0 && championshipMagic <= 3)) {\n                return {\n                    label: '우승확정',\n                    backgroundColor: '#2563eb',\n                    textColor: '#ffffff'\n                };\n            }\n            \n            // 플레이오프 확정\n            if (playoffMagic === 0 || playoffMagic <= 3) {\n                return {\n                    label: 'PO확정',\n                    backgroundColor: '#2563eb',\n                    textColor: '#ffffff'\n                };\n            }\n            \n            // 매직넘버 (유력)\n            if (playoffMagic <= 10) {\n                return {\n                    label: 'PO유력',\n                    backgroundColor: '#16a34a',\n                    textColor: '#ffffff'\n                };\n            }\n            \n            // 경합\n            if (playoffMagic <= 20 && tragicNumber > 10) {\n                return {\n                    label: '경합',\n                    backgroundColor: '#eab308',\n                    textColor: '#000000'\n                };\n            }\n            \n            // 탈락 위험\n            if (tragicNumber <= 5) {\n                return {\n                    label: '탈락위험',\n                    backgroundColor: '#dc2626',\n                    textColor: '#ffffff'\n                };\n            }\n            \n            // 탈락\n            if (tragicNumber === 0) {\n                return {\n                    label: '탈락',\n                    backgroundColor: '#991b1b',\n                    textColor: '#ffffff'\n                };\n            }\n            \n            // 기본 (경합)\n            return {\n                label: '경합',\n                backgroundColor: '#eab308',\n                textColor: '#000000'\n            };\n        }\n\n        function renderHeadToHead() {\n            const grid = document.getElementById('h2h-grid');\n            grid.innerHTML = '';\n\n            // 현재 순위대로 팀 배열 (동적)\n            const teamOrder = currentStandings\n                .sort((a, b) => a.rank - b.rank)\n                .map(team => team.team);\n\n            // Header row - 로고만 표시\n            grid.appendChild(createGridCell('', 'vs-header'));\n            teamOrder.forEach(team => {\n                const teamData = kboTeams[team];\n                const cell = createGridCell('', 'vs-header');\n                cell.innerHTML = `\n                    <div style=\"display: flex; align-items: center; justify-content: center;\" title=\"${team}\">\n                        ${teamData.logo}\n                    </div>\n                `;\n                grid.appendChild(cell);\n            });\n\n            // Data rows\n            teamOrder.forEach(homeTeam => {\n                const teamData = kboTeams[homeTeam];\n                const teamCell = createGridCell('', 'vs-team');\n                teamCell.innerHTML = `\n                    <div style=\"display: flex; align-items: center; justify-content: center;\" title=\"${homeTeam}\">\n                        ${teamData.logo}\n                    </div>\n                `;\n                teamCell.style.color = teamData.color;\n                grid.appendChild(teamCell);\n                \n                teamOrder.forEach(awayTeam => {\n                    if (homeTeam === awayTeam) {\n                        const cell = createGridCell('', 'vs-record');\n                        cell.innerHTML = '<div style=\"color: #666;\">■</div>';\n                        cell.style.background = 'white';\n                        grid.appendChild(cell);\n                    } else {\n                        const record = headToHeadData[homeTeam][awayTeam];\n                        \n                        // 새로운 JSON 형식 지원 (전체 객체) 및 기존 문자열 형식 호환\n                        let wins, losses, draws, homeWins, homeLosses, homeDraws, awayWins, awayLosses, awayDraws;\n                        \n                        if (typeof record === 'string') {\n                            // 기존 문자열 형식 지원 (백업용)\n                            [wins, losses, draws] = record.split('-').map(Number);\n                            // 추정치 사용 (기존 로직)\n                            homeWins = Math.ceil(wins * 0.55);\n                            homeLosses = Math.floor(losses * 0.45);\n                            homeDraws = Math.floor(draws * 0.5);\n                            awayWins = wins - homeWins;\n                            awayLosses = losses - homeLosses;\n                            awayDraws = draws - homeDraws;\n                        } else {\n                            // 새로운 객체 형식 - 실제 데이터 사용\n                            wins = record.wins || 0;\n                            losses = record.losses || 0;\n                            draws = record.draws || 0;\n                            homeWins = record.homeWins || 0;\n                            homeLosses = record.homeLosses || 0;\n                            homeDraws = record.homeDraws || 0;\n                            awayWins = record.awayWins || 0;\n                            awayLosses = record.awayLosses || 0;\n                            awayDraws = record.awayDraws || 0;\n                        }\n                        \n                        const totalGames = wins + losses + draws;\n                        const winPct = totalGames > 0 ? (wins / (wins + losses)) : 0.5; // 무승부 제외한 승률\n                        const winPctDisplay = totalGames > 0 ? winPct.toFixed(3) : '-';\n                        \n                        // 상대전적 우위/열세 확정 판단\n                        let starIcon = '';\n                        \n                        // 전체 경기수 (보통 16경기)\n                        const totalGamesPlayed = wins + losses + draws;\n                        const remainingGames = Math.max(0, 16 - totalGamesPlayed);\n                        \n                        // 우위/열세 확정 조건 체크\n                        if (wins >= 9) {\n                            // 9승 이상 = 상대전적 우위 확정\n                            starIcon = '⭐ ';\n                        } else if (losses >= 9) {\n                            // 9패 이상 = 상대전적 열세 확정\n                            starIcon = '🔻 ';\n                        } else if (remainingGames > 0) {\n                            // 남은 경기가 있는 경우: 남은 경기를 모두 이겨도 상대를 넘을 수 없으면 열세 확정\n                            const maxPossibleWins = wins + remainingGames;\n                            const opponentMinLosses = losses; // 상대방 최소 패수 (현재 내가 진 횟수)\n                            \n                            if (maxPossibleWins < opponentMinLosses) {\n                                // 내가 남은 경기를 모두 이겨도 상대방이 나보다 많이 이김 = 열세 확정\n                                starIcon = '🔻 ';\n                            } else if (wins > losses + remainingGames) {\n                                // 상대가 남은 경기를 모두 이겨도 내가 더 많이 이김 = 우위 확정\n                                starIcon = '⭐ ';\n                            }\n                        }\n                        \n                        // 승률 강도에 따른 그라데이션 색상\n                        let backgroundColor;\n                        let textColor = '#333'; // 모든 셀 통일된 텍스트 색상\n                        \n                        if (winPct === 0.5) {\n                            // 정확히 50% 동률인 경우만 - 노란색 배경\n                            backgroundColor = 'rgba(255, 193, 7, 0.3)';\n                        } else if (winPct > 0.5) {\n                            // 50% 이상 - 승률이 높을수록 진한 초록색\n                            const intensity = (winPct - 0.5) / 0.5; // 0.5-1.0을 0-1로 변환\n                            const opacity = 0.15 + (intensity * 0.75); // 0.15-0.9 범위로 확장\n                            backgroundColor = `rgba(22, 163, 74, ${opacity})`; // 더 진한 초록색 사용\n                        } else {\n                            // 50% 미만 - 패율이 높을수록 진한 빨간색\n                            const intensity = (0.5 - winPct) / 0.5; // 0-0.5를 1-0으로 변환\n                            const opacity = 0.15 + (intensity * 0.75); // 0.15-0.9 범위로 확장\n                            backgroundColor = `rgba(220, 38, 38, ${opacity})`; // 더 진한 빨간색 사용\n                        }\n                        \n                        // 실제 홈/원정 전적 사용\n                        const homeRecord = `${homeWins}-${homeLosses}-${homeDraws}`;\n                        const awayRecord = `${awayWins}-${awayLosses}-${awayDraws}`;\n                        \n                        const homeWinRate = homeWins + homeLosses > 0 ? (homeWins / (homeWins + homeLosses)).toFixed(3) : '-';\n                        const awayWinRate = awayWins + awayLosses > 0 ? (awayWins / (awayWins + awayLosses)).toFixed(3) : '-';\n\n                        // 전체 전적 문자열 생성\n                        const totalRecord = `${wins}-${losses}-${draws}`;\n\n                        const cell = createGridCell('', 'vs-record');\n                        cell.innerHTML = `\n                            <div style=\"line-height: 1.2; text-align: center; margin: 0; padding: 0;\">\n                                <div style=\"margin: 0 0 1px 0; padding: 0; font-size: ${starIcon ? '0.8rem' : '0.9rem'};\">${starIcon}${totalRecord} (${winPctDisplay})</div>\n                                <div style=\"color: #555; margin: 0; padding: 0; font-size: 0.7rem;\">🏠 ${homeRecord} (${homeWinRate})</div>\n                                <div style=\"color: #555; margin: 0; padding: 0; font-size: 0.7rem;\">✈️ ${awayRecord} (${awayWinRate})</div>\n                            </div>\n                        `;\n                        cell.style.background = backgroundColor;\n                        cell.style.color = textColor;\n                        grid.appendChild(cell);\n                    }\n                });\n            });\n        }\n\n        function renderRemainingGames() {\n            const grid = document.getElementById('remaining-grid');\n            grid.innerHTML = '';\n\n            // 현재 순위대로 팀 배열 (동적)\n            const teamOrder = currentStandings\n                .sort((a, b) => a.rank - b.rank)\n                .map(team => team.team);\n\n            // 팀간 남은 경기수 계산 함수\n            function calculateRemainingGamesBetweenTeams(team1, team2) {\n                if (team1 === team2) return '-';\n                \n                // 현재 상대전적에서 이미 치른 경기수 계산\n                const record = headToHeadData[team1][team2];\n                let wins, losses, draws;\n                \n                if (typeof record === 'string') {\n                    [wins, losses, draws] = record.split('-').map(Number);\n                } else {\n                    wins = record.wins || 0;\n                    losses = record.losses || 0;\n                    draws = record.draws || 0;\n                }\n                \n                const playedGames = wins + losses + draws;\n                \n                // KBO 정규시즌에서 각 팀은 다른 팀과 총 16경기씩 치름\n                const totalGamesPerOpponent = 16;\n                const remainingGames = Math.max(0, totalGamesPerOpponent - playedGames);\n                \n                return remainingGames;\n            }\n\n            // Header row\n            grid.appendChild(createGridCell('', 'vs-header'));\n            teamOrder.forEach(team => {\n                const teamData = kboTeams[team];\n                const cell = createGridCell('', 'vs-header');\n                cell.innerHTML = `\n                    <div style=\"display: flex; align-items: center; gap: 3px; justify-content: center;\">\n                        ${teamData.logo}\n                        <span style=\"color: ${teamData.color}; \">${team}</span>\n                    </div>\n                `;\n                grid.appendChild(cell);\n            });\n\n            // Data rows\n            teamOrder.forEach(homeTeam => {\n                const teamData = kboTeams[homeTeam];\n                const teamCell = createGridCell('', 'vs-team');\n                teamCell.innerHTML = `\n                    <div style=\"display: flex; align-items: center; justify-content: center;\" title=\"${homeTeam}\">\n                        ${teamData.logo}\n                    </div>\n                `;\n                teamCell.style.color = teamData.color;\n                grid.appendChild(teamCell);\n                \n                teamOrder.forEach(awayTeam => {\n                    const remainingGames = calculateRemainingGamesBetweenTeams(homeTeam, awayTeam);\n                    \n                    let backgroundColor;\n                    let textColor = '#333'; // 모든 셀 통일된 텍스트 색상\n                    \n                    if (remainingGames === '-') {\n                        backgroundColor = 'white';\n                        textColor = '#666';\n                    } else if (remainingGames === 0) {\n                        backgroundColor = 'rgba(156, 163, 175, 0.6)'; // 회색 - 경기 종료\n                        textColor = '#666';\n                    } else if (remainingGames <= 3) {\n                        backgroundColor = 'rgba(249, 115, 22, 0.6)'; // 주황색 - 적은 경기 남음\n                    } else if (remainingGames <= 6) {\n                        backgroundColor = 'rgba(234, 179, 8, 0.6)'; // 노란색 - 보통\n                    } else {\n                        backgroundColor = 'rgba(34, 197, 94, 0.6)'; // 초록색 - 많은 경기 남음\n                    }\n                    \n                    const cell = createGridCell(remainingGames === '-' ? '■' : remainingGames.toString(), 'vs-record');\n                    cell.style.background = backgroundColor;\n                    cell.style.color = textColor;\n                        cell.style.textAlign = 'center';\n                    grid.appendChild(cell);\n                });\n            });\n        }\n\n        function createGridCell(text, className) {\n            const cell = document.createElement('div');\n            cell.textContent = text;\n            cell.className = className;\n            return cell;\n        }\n\n        function adjustTooltipPositions() {\n            const tooltips = document.querySelectorAll('.tooltip');\n            tooltips.forEach(tooltip => {\n                const tooltiptext = tooltip.querySelector('.tooltiptext');\n                if (tooltiptext) {\n                    const rect = tooltip.getBoundingClientRect();\n                    const windowWidth = window.innerWidth;\n                    \n                    // 테이블 셀이나 카드 내부인지 확인\n                    const parentCard = tooltip.closest('.card, .table-container');\n                    let containerRight = windowWidth;\n                    \n                    if (parentCard) {\n                        const cardRect = parentCard.getBoundingClientRect();\n                        containerRight = cardRect.right;\n                    }\n                    \n                    // 툴팁이 컨테이너 경계를 넘을 경우 왼쪽 정렬\n                    if (rect.left + 150 > containerRight - 20) {\n                        tooltiptext.classList.add('tooltip-left');\n                    } else {\n                        tooltiptext.classList.remove('tooltip-left');\n                    }\n                }\n            });\n        }\n\n        async function initializeApp() {\n            try {\n                \n                // 현재 날짜 표시\n                const today = new Date().toLocaleDateString('ko-KR');\n                \n                // 1. 모든 데이터를 병렬로 로딩 (성능 최적화)\n                const [kboData, headToHeadData] = await Promise.all([\n                    loadKBOData(),\n                    loadHeadToHeadData()\n                ]);\n                \n                // 로드된 데이터 날짜 확인\n                if (kboData?.dataDate) {\n                }\n                \n                // 2. UI 업데이트\n                try {\n                    updateSummaryDashboard();\n                } catch (error) {\n                    logger.error('❌ 대시보드 업데이트 오류:', error);\n                }\n                \n                try {\n                    renderStandingsTable();\n                } catch (error) {\n                    logger.error('❌ 순위표 렌더링 오류:', error);\n                }\n                \n                try {\n                    renderChampionshipCondition();\n                } catch (error) {\n                    logger.error('❌ 우승 조건 렌더링 오류:', error);\n                }\n                \n                try {\n                    renderChaseAnalysis();\n                } catch (error) {\n                    logger.error('❌ 1위 탈환 가능성 렌더링 오류:', error);\n                }\n                \n                \n                try {\n                    renderPlayoffCondition();\n                } catch (error) {\n                    logger.error('❌ 플레이오프 조건 렌더링 오류:', error);\n                }\n                \n                \n                try {\n                    renderHeadToHead();\n                } catch (error) {\n                    logger.error('❌ 팀간 상대전적 렌더링 오류:', error);\n                }\n                \n                try {\n                    renderRemainingGames();\n                } catch (error) {\n                    logger.error('❌ 잔여 경기수 렌더링 오류:', error);\n                }\n                \n                // 3. UI 구성요소 초기화\n                try {\n                    initializeTooltips();\n                } catch (error) {\n                    logger.error('❌ 툴팁 초기화 오류:', error);\n                }\n                \n                try {\n                    initDesktopToggle();\n                } catch (error) {\n                    logger.error('❌ 데스크톱 토글 초기화 오류:', error);\n                }\n\n                // 네비게이션 드래그 스크롤 초기화\n                try {\n                    initNavDragScroll();\n                } catch (error) {\n                    logger.error('❌ 네비게이션 드래그 스크롤 초기화 오류:', error);\n                }\n                \n                // 주차별 분석 초기화\n                try {\n                    if (typeof weeklyAnalysisDisplay !== 'undefined') {\n                        weeklyAnalysisDisplay.init();\n                    }\n                } catch (error) {\n                    logger.error('❌ 주차별 분석 초기화 오류:', error);\n                }\n                \n                // 4. 툴팁 위치 조정\n                setTimeout(adjustTooltipPositions, 100);\n                \n                // 5. 창 크기 변경 시 툴팁 위치 재조정\n                eventManager.add(window, 'resize', () => {\n                    setTimeout(adjustTooltipPositions, 100);\n                });\n                \n                // 5. 탑으로 가기 버튼 기능 초기화\n                const scrollToTopButton = document.getElementById('scrollToTop');\n                \n                if (scrollToTopButton) {\n                    const handleScroll = () => {\n                        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;\n                        \n                        if (scrollPosition > 300) {\n                            scrollToTopButton.classList.add('show');\n                        } else {\n                            scrollToTopButton.classList.remove('show');\n                        }\n                    };\n                    \n                    eventManager.add(window, 'scroll', handleScroll);\n                    handleScroll();\n\n                    scrollToTopButton.addEventListener('click', () => {\n                        window.scrollTo({\n                            top: 0,\n                            behavior: 'smooth'\n                        });\n                    });\n                }\n                \n                \n            } catch (error) {\n                handleError(error, '앱 초기화 실패');\n            }\n        }\n\n        // 초기화 (비동기)\n        // 초기화 플래그\n        let isInitialized = false;\n        \n        async function runInitialization() {\n            if (isInitialized) {\n                return;\n            }\n            isInitialized = true;\n            await initializeApp();\n        }\n        \n        // magic-matrix-data.json 로드\n        async function loadMagicMatrixData() {\n            try {\n                const response = await fetch(`data/magic-matrix-data.json?v=${Date.now()}`);\n                if (response.ok) {\n                    window.magicMatrixData = await response.json();\n                    logger.log('✅ 승수 기준 매직넘버 데이터 로드 완료');\n                }\n            } catch (error) {\n                logger.warn('⚠️ 승수 기준 매직넘버 데이터 로드 실패:', error);\n            }\n        }\n\n        // DOMContentLoaded 이벤트\n        if (document.readyState === 'loading') {\n            eventManager.add(document, 'DOMContentLoaded', async () => {\n                await loadMagicMatrixData();\n                await runInitialization();\n            });\n        } else {\n            // 이미 DOM이 로드된 경우\n            (async () => {\n                await loadMagicMatrixData();\n                await runInitialization();\n            })();\n        }\n\n        // 탑으로 가기 버튼 별도 초기화 (더 안전한 방법)\n        setTimeout(() => {\n            const btn = document.getElementById('scrollToTop');\n            \n            if (btn) {\n                // 스크롤 이벤트\n                const btnScrollHandler = function() {\n                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n                    if (scrollTop > 300) {\n                        btn.style.opacity = '1';\n                        btn.style.visibility = 'visible';\n                        btn.style.transform = 'translateY(0)';\n                    } else {\n                        btn.style.opacity = '0';\n                        btn.style.visibility = 'hidden';\n                        btn.style.transform = 'translateY(20px)';\n                    }\n                };\n                eventManager.add(window, 'scroll', btnScrollHandler);\n                \n                // 클릭 이벤트\n                const btnClickHandler = function() {\n                    window.scrollTo({ top: 0, behavior: 'smooth' });\n                };\n                eventManager.add(btn, 'click', btnClickHandler);\n                \n            } else {\n                logger.error('버튼을 찾을 수 없습니다!');\n            }\n        }, 200);\n\n        // KBO 데이터 업데이트 체크 (하루 3번: 18시, 22시, 24시)\n        function checkForDataUpdate() {\n            const now = new Date();\n            const currentTime = now.getHours() * 100 + now.getMinutes();\n            \n            // 업데이트 시간: 18:00, 22:00, 00:00 (± 5분 오차 허용)\n            const updateTimes = [1800, 2200, 0]; // 18:00, 22:00, 00:00\n            const tolerance = 5; // 5분 오차 허용\n            \n            for (let updateTime of updateTimes) {\n                if (Math.abs(currentTime - updateTime) <= tolerance) {\n                    // 실제 데이터 업데이트는 서버에서 JSON 파일을 업데이트하면 자동으로 반영됨\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        // 1시간마다 업데이트 시간 체크\n        setInterval(checkForDataUpdate, 3600000); // 1시간마다 체크\n\n        // 툴팁 클릭 이벤트 초기화 함수\n        function initializeTooltips() {\n            const tooltips = document.querySelectorAll('.tooltip');\n            \n            tooltips.forEach(tooltip => {\n                // 중복 이벤트 방지\n                if (!tooltip.hasAttribute('data-tooltip-initialized')) {\n                    tooltip.setAttribute('data-tooltip-initialized', 'true');\n                    eventManager.add(tooltip, 'click', function(e) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        \n                        // 다른 모든 툴팁 비활성화\n                        tooltips.forEach(t => t.classList.remove('active'));\n                        \n                        // 현재 툴팁 활성화\n                        this.classList.add('active');\n                    });\n                }\n            });\n            \n            // 다른 곳 클릭시 툴팁 닫기 (한 번만 등록)\n            if (!document.documentElement.hasAttribute('data-tooltip-global-initialized')) {\n                document.documentElement.setAttribute('data-tooltip-global-initialized', 'true');\n                eventManager.add(document, 'click', function() {\n                    tooltips.forEach(tooltip => tooltip.classList.remove('active'));\n                });\n            }\n        }\n\n        // PC 버전 보기 기능\n        function initDesktopToggle() {\n            try {\n                const toggleBtn = document.getElementById('toggle-desktop-view');\n                const mobileControls = document.getElementById('mobile-controls');\n                \n                // 요소가 없으면 함수 종료\n                if (!toggleBtn && !mobileControls) {\n                    return;\n                }\n                \n                // 화면 크기 확인 함수\n                function isMobileDevice() {\n                    return window.innerWidth <= 768;\n                }\n                \n                // 모바일 컨트롤 표시/숨김\n                function updateMobileControlsVisibility() {\n                    if (mobileControls) {\n                        mobileControls.style.display = isMobileDevice() ? 'block' : 'none';\n                    }\n                }\n            \n            // 초기 설정\n            updateMobileControlsVisibility();\n            \n            // 화면 크기 변경 시 업데이트\n            eventManager.add(window, 'resize', updateMobileControlsVisibility);\n            \n            // 버튼 클릭 이벤트\n            if (toggleBtn) {\n                toggleBtn.addEventListener('click', function() {\n                    const viewportMeta = document.querySelector('meta[name=\"viewport\"]');\n                    const isDesktopMode = toggleBtn.textContent.includes('모바일');\n                    \n                    if (isDesktopMode) {\n                        // 모바일 버전으로 되돌리기\n                        viewportMeta.setAttribute('content', 'width=device-width, initial-scale=1.0');\n                        toggleBtn.innerHTML = '🖥️ PC 버전으로 보기';\n                        toggleBtn.nextElementSibling.textContent = '더 원활한 사용이 가능합니다';\n                    } else {\n                        // PC 버전으로 전환\n                        viewportMeta.setAttribute('content', 'width=1200, initial-scale=0.5, user-scalable=yes');\n                        toggleBtn.innerHTML = '📱 모바일 버전으로 돌아가기';\n                        toggleBtn.nextElementSibling.textContent = '원래 크기로 돌아갑니다';\n                    }\n                });\n                \n                // 버튼 hover 효과\n                toggleBtn.addEventListener('mouseenter', function() {\n                    this.style.background = 'rgba(255,255,255,0.2)';\n                    this.style.borderColor = 'rgba(255,255,255,0.4)';\n                });\n                \n                toggleBtn.addEventListener('mouseleave', function() {\n                    this.style.background = 'rgba(255,255,255,0.1)';\n                    this.style.borderColor = 'rgba(255,255,255,0.2)';\n                });\n            }\n            } catch (error) {\n                logger.error('❌ initDesktopToggle 오류:', error);\n                // 이 함수의 오류는 치명적이지 않으므로 계속 진행\n            }\n        }\n        \n        // 초기화는 runInitialization에서 처리됨\n        \n        // 네비게이션 드래그 스크롤 기능\n        function initNavDragScroll() {\n            const navMenu = document.querySelector('.nav-menu');\n            if (!navMenu) return;\n\n            let isDown = false;\n            let startX;\n            let scrollLeft;\n            let hasMoved = false;\n\n            // 마우스 이벤트\n            navMenu.addEventListener('mousedown', (e) => {\n                isDown = true;\n                hasMoved = false;\n                navMenu.classList.add('dragging');\n                startX = e.pageX - navMenu.offsetLeft;\n                scrollLeft = navMenu.scrollLeft;\n                e.preventDefault();\n            });\n\n            navMenu.addEventListener('mouseleave', () => {\n                isDown = false;\n                navMenu.classList.remove('dragging');\n            });\n\n            navMenu.addEventListener('mouseup', (e) => {\n                isDown = false;\n                navMenu.classList.remove('dragging');\n                \n                // 클릭인지 드래그인지 구분\n                if (!hasMoved && e.target.tagName === 'A') {\n                    // 실제 클릭이므로 링크 동작을 허용\n                    return;\n                }\n                \n                // 드래그였으므로 링크 클릭 방지\n                if (hasMoved) {\n                    e.preventDefault();\n                }\n            });\n\n            navMenu.addEventListener('mousemove', (e) => {\n                if (!isDown) return;\n                e.preventDefault();\n                \n                const x = e.pageX - navMenu.offsetLeft;\n                const walk = (x - startX) * 1.5; // 스크롤 속도 조절\n                \n                if (Math.abs(walk) > 3) {\n                    hasMoved = true;\n                }\n                \n                navMenu.scrollLeft = scrollLeft - walk;\n            });\n\n            // 터치 이벤트 (모바일)\n            let touchHasMoved = false;\n            \n            navMenu.addEventListener('touchstart', (e) => {\n                isDown = true;\n                touchHasMoved = false;\n                navMenu.classList.add('dragging');\n                startX = e.touches[0].pageX - navMenu.offsetLeft;\n                scrollLeft = navMenu.scrollLeft;\n            }, { passive: true });\n\n            navMenu.addEventListener('touchmove', (e) => {\n                if (!isDown) return;\n                \n                const x = e.touches[0].pageX - navMenu.offsetLeft;\n                const walk = (x - startX) * 1.5;\n                \n                if (Math.abs(walk) > 5) {\n                    touchHasMoved = true;\n                    e.preventDefault(); // 스크롤 방지\n                }\n                \n                navMenu.scrollLeft = scrollLeft - walk;\n            });\n\n            navMenu.addEventListener('touchend', (e) => {\n                isDown = false;\n                navMenu.classList.remove('dragging');\n                \n                // 터치 드래그였으면 클릭 방지\n                if (touchHasMoved && e.target.tagName === 'A') {\n                    e.preventDefault();\n                }\n            });\n\n            // 링크 클릭 이벤트 처리\n            navMenu.addEventListener('click', (e) => {\n                if (hasMoved || touchHasMoved) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n            });\n        }\n\n        // 네비게이션 함수들 (CSS scroll-margin-top 활용)\n        function scrollToSection(elementId) {\n            const element = document.getElementById(elementId);\n            if (!element) return;\n            \n            // CSS scroll-margin-top을 활용한 간단한 스크롤\n            element.scrollIntoView({ \n                behavior: 'smooth',\n                block: 'start'\n            });\n            \n            updateActiveNav(elementId);\n            \n            // 모바일 메뉴 닫기\n            const navMenu = document.querySelector('.nav-menu');\n            navMenu.classList.remove('active');\n        }\n        \n        \n        function scrollToWeeklyAnalysis() {\n            scrollToSection('weekly-analysis');\n        }\n\n        \n        \n\n        \n        \n\n        \n        \n        // 모바일 메뉴 토글\n        function toggleMobileMenu() {\n            const navMenu = document.querySelector('.nav-menu');\n            navMenu.classList.toggle('active');\n        }\n        \n        \n        // 모바일에서 메뉴 항목 클릭 시 메뉴 닫기\n        document.addEventListener('click', function(e) {\n            const navMenu = document.querySelector('.nav-menu');\n            const navToggle = document.querySelector('.nav-toggle');\n            \n            if (!navMenu.contains(e.target) && !navToggle.contains(e.target)) {\n                navMenu.classList.remove('active');\n            }\n        });\n\n        // 단순한 데이터 그라데이션 적용\n        function applyDataGradients() {\n            // 매직넘버는 작을수록 좋음 (초록)\n            document.querySelectorAll('.magic-number').forEach(cell => {\n                const value = cell.textContent.trim();\n                if (value.includes('확정')) {\n                    cell.classList.add('data-excellent');\n                } else if (!isNaN(value) && value !== '-') {\n                    const num = parseInt(value);\n                    if (num <= 5) cell.classList.add('data-good');\n                    else if (num <= 15) cell.classList.add('data-warning');\n                    else cell.classList.add('data-bad');\n                }\n            });\n            \n            // 트래직넘버는 클수록 안전함 (초록)\n            document.querySelectorAll('.tragic-number').forEach(cell => {\n                const value = cell.textContent.trim();\n                if (value.includes('안전')) {\n                    cell.classList.add('data-excellent');\n                } else if (value.includes('탈락')) {\n                    cell.classList.add('data-bad');\n                } else if (value.startsWith('-')) {\n                    const num = parseInt(value.substring(1));\n                    if (num >= 20) cell.classList.add('data-good');\n                    else if (num >= 10) cell.classList.add('data-warning');\n                    else cell.classList.add('data-bad');\n                }\n            });\n            \n            // 승률은 높을수록 좋음\n            document.querySelectorAll('#standings-table td:nth-child(8)').forEach(cell => {\n                const value = parseFloat(cell.textContent.trim());\n                if (!isNaN(value)) {\n                    if (value >= 0.600) cell.classList.add('data-excellent');\n                    else if (value >= 0.550) cell.classList.add('data-good');\n                    else if (value >= 0.450) cell.classList.add('data-warning');\n                    else cell.classList.add('data-bad');\n                }\n            });\n            \n            // 진출상황은 상태에 따라 색상 구분\n            document.querySelectorAll('.status-text').forEach(cell => {\n                const value = cell.textContent.trim();\n                if (value.includes('확정') || value.includes('진출') || value === '가능') {\n                    cell.classList.add('data-excellent');\n                } else if (value.includes('유력') || value.includes('매우 유력')) {\n                    cell.classList.add('data-good');\n                } else if (value.includes('경합') || value.includes('어려움')) {\n                    cell.classList.add('data-warning');\n                } else if (value.includes('탈락') || value.includes('불가능') || value.includes('매우 어려움') || value.includes('극히 어려움')) {\n                    cell.classList.add('data-bad');\n                }\n            });\n            \n            // 필요 승률은 낮을수록 좋음 (달성하기 쉬움)\n            document.querySelectorAll('.required-rate').forEach(cell => {\n                const value = cell.textContent.trim();\n                if (value === '-' || value === '달성') {\n                    cell.classList.add('data-excellent');\n                } else {\n                    const rate = parseFloat(value);\n                    if (!isNaN(rate)) {\n                        if (rate <= 0.300) cell.classList.add('data-excellent');  // 30% 이하: 매우 쉬움\n                        else if (rate <= 0.500) cell.classList.add('data-good');  // 50% 이하: 쉬움\n                        else if (rate <= 0.700) cell.classList.add('data-warning'); // 70% 이하: 어려움\n                        else cell.classList.add('data-bad');  // 70% 초과: 매우 어려움\n                    }\n                }\n            });\n        }\n\n        // 데이터 렌더링 후 그라데이션 적용\n        function applyGradientsAfterRender() {\n            setTimeout(applyDataGradients, 500);\n        }\n        \n        // 페이지 로드 완료 후 그라데이션 적용\n        window.addEventListener('load', applyGradientsAfterRender);\n\n        // ===========================================\n        // 네비게이션 관련 함수들\n        // ===========================================\n\n        // 부드러운 스크롤 함수\n        function smoothScrollTo(targetId) {\n            const target = document.getElementById(targetId);\n            if (target) {\n                const targetPosition = target.offsetTop - 80; // 네비게이션 높이 고려\n                window.scrollTo({\n                    top: targetPosition,\n                    behavior: 'smooth'\n                });\n                \n                // active 상태 업데이트\n                updateActiveNav(targetId);\n            }\n        }\n\n        // 네비게이션 active 상태 업데이트\n        function updateActiveNav(activeId) {\n            const navItems = document.querySelectorAll('.nav-item');\n            let activeNavItem = null;\n            \n            navItems.forEach(item => {\n                item.classList.remove('active');\n                const onclick = item.getAttribute('onclick');\n                \n                if (onclick && onclick.includes(`smoothScrollTo('${activeId}')`)) {\n                    item.classList.add('active');\n                    activeNavItem = item;\n                }\n            });\n            \n            // 모바일에서 활성화된 네비게이션 아이템이 화면에 보이도록 스크롤\n            if (activeNavItem && window.innerWidth <= 768) {\n                const navMenu = document.querySelector('.nav-menu');\n                if (navMenu) {\n                    // 네비게이션 메뉴의 스크롤 위치 계산\n                    const navMenuRect = navMenu.getBoundingClientRect();\n                    const activeItemRect = activeNavItem.getBoundingClientRect();\n                    \n                    // 활성 아이템이 보이는 영역에 없다면 스크롤\n                    if (activeItemRect.left < navMenuRect.left || activeItemRect.right > navMenuRect.right) {\n                        activeNavItem.scrollIntoView({\n                            behavior: 'smooth',\n                            block: 'nearest',\n                            inline: 'center'\n                        });\n                    }\n                }\n            }\n        }\n\n\n        // 모바일 메뉴 토글\n        function toggleMobileMenu() {\n            const navMenu = document.querySelector('.nav-menu');\n            navMenu.classList.toggle('show');\n        }\n\n        // 스크롤 위치에 따른 자동 active 상태 업데이트\n        function updateActiveOnScroll() {\n            const sections = ['championship', 'scenarios', 'chase', 'playoff', 'standings', 'rank-chart-section', 'vs-records', 'remaining'];\n            const scrollPosition = window.scrollY + 100;\n\n            for (let i = sections.length - 1; i >= 0; i--) {\n                const section = document.getElementById(sections[i]);\n                if (section && section.offsetTop <= scrollPosition) {\n                    updateActiveNav(sections[i]);\n                    break;\n                }\n            }\n        }\n\n        // 스크롤 이벤트 리스너\n        let scrollTimeout;\n        window.addEventListener('scroll', () => {\n            clearTimeout(scrollTimeout);\n            scrollTimeout = setTimeout(updateActiveOnScroll, 50);\n        });\n\n        // 페이지 로드시 초기 액티브 상태 설정\n        document.addEventListener('DOMContentLoaded', () => {\n            // 초기 액티브 상태를 championship으로 설정\n            updateActiveNav('championship');\n            \n            // 스크롤 위치에 따른 초기 액티브 상태 업데이트\n            setTimeout(() => {\n                updateActiveOnScroll();\n            }, 100);\n            \n            // Sticky 네비게이션 구현\n            const navigation = document.querySelector('.navigation');\n            const header = document.querySelector('.header');\n            let navigationOffset = 0;\n            \n            function updateNavigationOffset() {\n                if (navigation) {\n                    navigationOffset = navigation.offsetTop;\n                }\n            }\n            \n            function handleScroll() {\n                if (!navigation) return;\n                \n                const currentScroll = window.pageYOffset;\n                \n                if (currentScroll > navigationOffset) {\n                    navigation.classList.add('sticky');\n                    // sticky 상태일 때 body에 패딩 추가하여 점프 방지\n                    document.body.style.paddingTop = navigation.offsetHeight + 'px';\n                } else {\n                    navigation.classList.remove('sticky');\n                    document.body.style.paddingTop = '0px';\n                }\n            }\n            \n            // 초기 오프셋 계산\n            updateNavigationOffset();\n            \n            // 스크롤 이벤트 리스너\n            window.addEventListener('scroll', handleScroll, { passive: true });\n            \n            // 윈도우 리사이즈 시 오프셋 재계산\n            window.addEventListener('resize', updateNavigationOffset);\n        });\n\n        // 시나리오 분석 관련 함수들\n        function initializeScenarioAnalysis() {\n            // 시나리오 분석 데이터 업데이트\n            updateScenarioStats();\n            \n            // 버튼 이벤트 리스너 추가\n            const matrixBtn = document.getElementById('showScenarioMatrix');\n            const detailedBtn = document.getElementById('showDetailedScenarios');\n            const hideBtn = document.getElementById('hideScenarioResults');\n            \n            if (matrixBtn) {\n                matrixBtn.addEventListener('click', function() {\n                    showScenarioMatrix();\n                });\n            }\n            \n            if (detailedBtn) {\n                detailedBtn.addEventListener('click', function() {\n                    showDetailedScenarios();\n                });\n            }\n            \n            if (hideBtn) {\n                hideBtn.addEventListener('click', function() {\n                    hideScenarioResults();\n                });\n            }\n        }\n\n        function updateScenarioStats() {\n            try {\n                if (!currentStandings || currentStandings.length === 0) {\n                    return;\n                }\n                \n                // 상위 9팀 분석 (10위는 제외)\n                const topTeams = currentStandings.slice(0, 9);\n                \n                // 최대 시나리오 수 계산 (최대 잔여경기수 + 1)\n                const maxRemainingGames = Math.max(...topTeams.map(team => team.remainingGames || 0));\n                const maxScenarios = maxRemainingGames + 1;\n                \n                // 플레이오프 경쟁팀 계산 (현실적으로 5위 안에 들 가능성이 있는 팀)\n                let playoffContenders = 0;\n                const fifthPlaceWinRate = topTeams[4]?.winRate || 0.5;\n                \n                topTeams.forEach(team => {\n                    // 전승 시 승률이 현재 5위 승률보다 높으면 경쟁 가능\n                    const maxPossibleWins = team.wins + (team.remainingGames || 0);\n                    const maxPossibleGames = maxPossibleWins + team.losses + (team.draws || 0);\n                    const maxWinRate = maxPossibleWins / maxPossibleGames;\n                    \n                    if (maxWinRate >= fifthPlaceWinRate * 0.95) { // 95% 기준으로 여유\n                        playoffContenders++;\n                    }\n                });\n                \n                // 우승 가능팀 계산\n                let championshipContenders = 0;\n                const firstPlaceWinRate = topTeams[0]?.winRate || 0.6;\n                \n                topTeams.forEach(team => {\n                    const maxPossibleWins = team.wins + (team.remainingGames || 0);\n                    const maxPossibleGames = maxPossibleWins + team.losses + (team.draws || 0);\n                    const maxWinRate = maxPossibleWins / maxPossibleGames;\n                    \n                    if (maxWinRate >= firstPlaceWinRate * 0.92) { // 92% 기준으로 여유\n                        championshipContenders++;\n                    }\n                });\n                \n                // UI 업데이트\n                updateElementText('max-scenarios', maxScenarios + '개');\n                updateElementText('playoff-contenders', playoffContenders + '팀');\n                updateElementText('championship-contenders', championshipContenders + '팀');\n                \n                // 시나리오 미리보기 업데이트\n                updateScenarioPreview(topTeams);\n                \n            } catch (error) {\n                logger.error('시나리오 통계 업데이트 중 오류:', error);\n            }\n        }\n\n        function updateScenarioPreview(topTeams) {\n            try {\n                // 1위 경쟁 분석\n                const firstPlaceRace = analyzeFirstPlaceRace(topTeams);\n                updateElementText('first-place-race', firstPlaceRace);\n                \n                // 플레이오프 경쟁 분석\n                const playoffRace = analyzePlayoffRace(topTeams);\n                updateElementText('playoff-race', playoffRace);\n                \n                // 최대 승률 변동 분석\n                const maxWinRateChange = analyzeMaxWinRateChange(topTeams);\n                updateElementText('max-winrate-change', maxWinRateChange);\n                \n                // 최대 순위 변동 분석\n                const maxRankChange = analyzeMaxRankChange(topTeams);\n                updateElementText('max-rank-change', maxRankChange);\n                \n            } catch (error) {\n                logger.error('시나리오 미리보기 업데이트 중 오류:', error);\n            }\n        }\n\n        function analyzeFirstPlaceRace(topTeams) {\n            if (topTeams.length === 0) return '데이터 없음';\n            \n            const firstPlace = topTeams[0];\n            let contenders = [];\n            \n            topTeams.forEach(team => {\n                const maxPossibleWins = team.wins + (team.remainingGames || 0);\n                const maxPossibleGames = maxPossibleWins + team.losses + (team.draws || 0);\n                const maxWinRate = maxPossibleWins / maxPossibleGames;\n                \n                // 1위팀의 최저 가능 승률\n                const firstPlaceMinWins = firstPlace.wins;\n                const firstPlaceMinGames = firstPlaceMinWins + firstPlace.losses + (firstPlace.draws || 0) + (firstPlace.remainingGames || 0);\n                const firstPlaceMinWinRate = firstPlaceMinWins / firstPlaceMinGames;\n                \n                if (team.team !== firstPlace.team && maxWinRate > firstPlaceMinWinRate) {\n                    contenders.push(team.team);\n                }\n            });\n            \n            if (contenders.length === 0) {\n                return `${firstPlace.team} 독주 체제`;\n            } else {\n                return `${contenders.slice(0, 3).join(', ')} 등 ${contenders.length}팀 경쟁`;\n            }\n        }\n\n        function analyzePlayoffRace(topTeams) {\n            if (topTeams.length < 5) return '데이터 부족';\n            \n            const fifthPlace = topTeams[4];\n            let contenders = [];\n            \n            topTeams.forEach((team, index) => {\n                if (index >= 4) { // 5위 이하 팀들\n                    const maxPossibleWins = team.wins + (team.remainingGames || 0);\n                    const maxPossibleGames = maxPossibleWins + team.losses + (team.draws || 0);\n                    const maxWinRate = maxPossibleWins / maxPossibleGames;\n                    \n                    // 5위팀의 최저 가능 승률\n                    const fifthPlaceMinWins = fifthPlace.wins;\n                    const fifthPlaceMinGames = fifthPlaceMinWins + fifthPlace.losses + (fifthPlace.draws || 0) + (fifthPlace.remainingGames || 0);\n                    const fifthPlaceMinWinRate = fifthPlaceMinWins / fifthPlaceMinGames;\n                    \n                    if (maxWinRate > fifthPlaceMinWinRate) {\n                        contenders.push(team.team);\n                    }\n                }\n            });\n            \n            return contenders.length > 0 ? \n                   `${contenders.slice(0, 3).join(', ')} 등 ${contenders.length}팀 추격` : \n                   '상위 5팀 고정';\n        }\n\n        function analyzeMaxWinRateChange(topTeams) {\n            let maxIncrease = 0;\n            let maxDecrease = 0;\n            \n            topTeams.forEach(team => {\n                const currentWinRate = team.winRate;\n                \n                // 최대 가능 승률 (전승)\n                const maxPossibleWins = team.wins + (team.remainingGames || 0);\n                const maxPossibleGames = maxPossibleWins + team.losses + (team.draws || 0);\n                const maxWinRate = maxPossibleWins / maxPossibleGames;\n                \n                // 최저 가능 승률 (전패)\n                const minPossibleWins = team.wins;\n                const minPossibleGames = minPossibleWins + team.losses + (team.draws || 0) + (team.remainingGames || 0);\n                const minWinRate = minPossibleWins / minPossibleGames;\n                \n                const increase = (maxWinRate - currentWinRate) * 100;\n                const decrease = (currentWinRate - minWinRate) * 100;\n                \n                maxIncrease = Math.max(maxIncrease, increase);\n                maxDecrease = Math.max(maxDecrease, decrease);\n            });\n            \n            return `+${maxIncrease.toFixed(1)}%p ~ -${maxDecrease.toFixed(1)}%p`;\n        }\n\n        function analyzeMaxRankChange(topTeams) {\n            // 간단한 순위 변동 범위 계산\n            const totalTeams = topTeams.length;\n            \n            // 현실적인 최대 순위 변동 (잔여경기 기준)\n            const avgRemainingGames = topTeams.reduce((sum, team) => sum + (team.remainingGames || 0), 0) / totalTeams;\n            \n            if (avgRemainingGames >= 20) {\n                return '최대 ±4위 변동';\n            } else if (avgRemainingGames >= 10) {\n                return '최대 ±3위 변동';\n            } else if (avgRemainingGames >= 5) {\n                return '최대 ±2위 변동';\n            } else {\n                return '최대 ±1위 변동';\n            }\n        }\n\n        function updateElementText(elementId, text) {\n            const element = document.getElementById(elementId);\n            if (element) {\n                element.textContent = text;\n            }\n        }\n\n        // 시나리오 매트릭스 표시\n        function showScenarioMatrix(autoScroll = true) {\n            try {\n                if (!currentStandings || currentStandings.length === 0) {\n                    alert('순위 데이터를 불러오는 중입니다. 잠시 후 다시 시도해 주세요.');\n                    return;\n                }\n                \n                const topTeams = currentStandings.slice(0, 10);\n                const matrixHTML = generateScenarioMatrix(topTeams);\n                \n                const scenarioContent = document.getElementById('scenario-content');\n                \n                if (scenarioContent) {\n                    scenarioContent.innerHTML = matrixHTML;\n                    scenarioContent.style.display = 'block';\n                    \n                    // 사용자가 버튼을 클릭했을 때만 스크롤\n                    if (autoScroll) {\n                        scenarioContent.scrollIntoView({ behavior: 'smooth', block: 'nearest' });\n                    }\n                } else {\n                    logger.error('scenario-content 요소를 찾을 수 없습니다.');\n                }\n                \n            } catch (error) {\n                logger.error('매트릭스 시나리오 표시 중 오류:', error);\n                alert('시나리오 분석 중 오류가 발생했습니다.');\n            }\n        }\n\n        // 상세 시나리오 표시\n        function showDetailedScenarios() {\n            try {\n                if (!currentStandings || currentStandings.length === 0) {\n                    alert('순위 데이터를 불러오는 중입니다. 잠시 후 다시 시도해 주세요.');\n                    return;\n                }\n                \n                const topTeams = currentStandings.slice(0, 5); // 상위 5팀만\n                const detailedHTML = generateDetailedScenarios(topTeams);\n                \n                const scenarioContent = document.getElementById('scenario-content');\n                const scenarioResults = document.getElementById('scenario-results');\n                \n                if (scenarioContent && scenarioResults) {\n                    scenarioContent.innerHTML = detailedHTML;\n                    scenarioResults.style.display = 'block';\n                    \n                    // 스크롤하여 결과 영역으로 이동\n                    scenarioResults.scrollIntoView({ behavior: 'smooth', block: 'nearest' });\n                }\n                \n            } catch (error) {\n                logger.error('상세 시나리오 표시 중 오류:', error);\n                alert('시나리오 분석 중 오류가 발생했습니다.');\n            }\n        }\n\n        // 시나리오 결과 숨기기\n        function hideScenarioResults() {\n            const scenarioResults = document.getElementById('scenario-results');\n            if (scenarioResults) {\n                scenarioResults.style.display = 'none';\n            }\n        }\n\n        // 매트릭스 시나리오 HTML 생성\n        function generateScenarioMatrix(topTeams, skipFiltering = false) {\n            // 완전한 시나리오 기반 5위 진출 가능성 검사\n            function canReachTop5(targetTeam, allTeams) {\n                // 모든 팀의 가능한 최종 성적 범위 계산\n                const teamScenarios = allTeams.map(team => {\n                    const remaining = team.remainingGames || 0;\n                    const scenarios = [];\n                    \n                    // 0승부터 전승까지 모든 경우\n                    for (let wins = 0; wins <= remaining; wins++) {\n                        const finalWins = team.wins + wins;\n                        const finalLosses = team.losses + (remaining - wins);\n                        const finalGames = finalWins + finalLosses + (team.draws || 0);\n                        const finalWinRate = finalWins / (finalWins + finalLosses); // 무승부 제외한 승률\n                        \n                        scenarios.push({\n                            team: team.team,\n                            wins: finalWins,\n                            losses: finalLosses,\n                            games: finalGames,\n                            winRate: finalWinRate,\n                            winLossMargin: finalWins - finalLosses\n                        });\n                    }\n                    return scenarios;\n                });\n                \n                // 현실적으로 플레이오프 경쟁 가능한 팀들만 체크\n                const competingTeams = teamScenarios.slice(0, Math.min(10, teamScenarios.length));\n                \n                // 더 많은 시나리오 샘플링 (더 정확한 검사)\n                const sampleSize = Math.min(100, Math.max(20, competingTeams[0].length));\n                const stepSize = Math.max(1, Math.floor(competingTeams[0].length / sampleSize));\n                \n                for (let i = 0; i < competingTeams[0].length; i += stepSize) {\n                    // 각 팀의 i번째 시나리오 조합\n                    const scenarioResults = competingTeams.map(scenarios => scenarios[Math.min(i, scenarios.length - 1)]);\n                    \n                    // 승률 기준으로 정렬\n                    scenarioResults.sort((a, b) => {\n                        if (Math.abs(a.winRate - b.winRate) < 0.001) {\n                            return b.winLossMargin - a.winLossMargin; // 승률 같으면 승패차\n                        }\n                        return b.winRate - a.winRate;\n                    });\n                    \n                    // 타겟 팀이 5위 안에 있는지 확인\n                    const targetTeamRank = scenarioResults.findIndex(team => team.team === targetTeam.team) + 1;\n                    if (targetTeamRank <= 5 && targetTeamRank > 0) {\n                        return true; // 5위 안에 들 수 있는 시나리오 발견\n                    }\n                }\n                \n                // 극한 시나리오도 체크 (타겟팀 전승, 다른팀들 전패)\n                const extremeScenario = competingTeams.map((scenarios, index) => {\n                    if (scenarios[0].team === targetTeam.team) {\n                        return scenarios[scenarios.length - 1]; // 타겟팀 전승 (최고 성적)\n                    } else {\n                        return scenarios[0]; // 다른 팀들 전패 (최저 성적)\n                    }\n                });\n                \n                // KBO 규정에 따른 정렬 (승률 → 승패차)\n                extremeScenario.sort((a, b) => {\n                    if (Math.abs(a.winRate - b.winRate) < 0.001) {\n                        return b.winLossMargin - a.winLossMargin;\n                    }\n                    return b.winRate - a.winRate;\n                });\n                \n                const extremeRank = extremeScenario.findIndex(team => team.team === targetTeam.team) + 1;\n                \n                // 디버깅: 극한 시나리오 결과 출력\n                if (targetTeam.team === '두산') {\n                    extremeScenario.forEach((team, index) => {\n                        const marker = team.team === '두산' ? '👈' : '';\n                    });\n                }\n                \n                return extremeRank <= 5 && extremeRank > 0;\n            }\n            \n            // 필터링: 새창에서는 모든 팀, 메인에서는 경쟁 가능한 팀만\n            const playoffContenders = skipFiltering ? topTeams : topTeams.filter(team => {\n                // 상위 8팀은 무조건 포함 (더 관대하게)\n                const currentRank = topTeams.findIndex(t => t.team === team.team) + 1;\n                if (currentRank <= 8) {\n                    return true;\n                }\n                \n                // 9위, 10위는 기본적인 수학적 가능성 체크\n                const maxPossibleWins = team.wins + (team.remainingGames || 0);\n                \n                // 현재 5위팀의 현재 승수보다 최대가능승수가 높으면 포함\n                const fifthPlaceWins = topTeams[4]?.wins || 0;\n                if (maxPossibleWins > fifthPlaceWins) {\n                    return true;\n                }\n                \n                // 매우 관대한 기준: 50승 이상 가능하면 포함\n                if (maxPossibleWins >= 50) {\n                    return true;\n                }\n                \n                return false;\n            });\n            \n            // 실제 경쟁 가능한 팀만 선별 (새창: 전체 10팀, 메인: 최대 9팀)\n            const eligibleTeams = skipFiltering ? playoffContenders : playoffContenders.slice(0, 9);\n            \n            // 두산 특별 체크\n            const doosan = topTeams.find(t => t.team === '두산');\n            if (doosan) {\n            }\n            \n            // 팀이 너무 적으면 최소 상위 팀 보장 (새창: 10팀, 메인: 8팀)\n            const minTeamCount = skipFiltering ? 10 : 8;\n            const maxTeamCount = skipFiltering ? 10 : 9;\n            if (eligibleTeams.length < minTeamCount) {\n                const minTeams = topTeams.slice(0, Math.min(maxTeamCount, topTeams.length));\n                eligibleTeams.splice(0, eligibleTeams.length, ...minTeams);\n            }\n            let html = `\n                \n                <div class=\"scenario-matrix-container\" style=\"\n                    overflow-x: auto; \n                    overflow-y: auto;\n                    border-radius: 12px; \n                    border: 1px solid #e0e0e0; \n                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n                    max-height: 80vh;\n                    width: 100%;\n                    position: relative;\n                \">\n                    <table class=\"scenario-matrix-table\" style=\"\n                        width: 100%; \n                        border-collapse: collapse; \n                        font-size: 0.75rem; \n                        background: white; \n                        min-width: ${window.innerWidth <= 768 ? '800px' : Math.max(1100, 6 * (75 + 95) + 70 + 140) + 'px'};\n                    \">\n                        <thead style=\"position: sticky; top: 0; z-index: 100;\">\n                            <!-- 1행: 순위 -->\n                            <tr style=\"background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); color: white;\">\n                                <th style=\"\n                                    position: sticky;\n                                    left: 0;\n                                    z-index: 110;\n                                    min-width: 70px; \n                                    width: 70px;\n                                    padding: 4px 6px; \n                                    text-align: center; \n                                    font-weight: 600; \n                                    border-right: 2px solid rgba(255,255,255,0.4); \n                                    background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); \n                                    font-size: 0.7rem;\n                                \">순위</th>\n            `;\n            \n            // 첫 번째 헤더 행 - 팀 정보 통합 (순위 + 팀명 + 현재성적)\n            eligibleTeams.forEach((team, index) => {\n                const isLast = index === eligibleTeams.length - 1;\n                const teamData = kboTeams[team.team];\n                const teamColor = teamData?.color || '#333';\n                const columnWidth = index < 6 ? '160px' : '120px';\n                \n                const totalColumnWidth = index < 6 ? '170px' : '140px'; // 75+95 또는 60+80\n                html += `<th colspan=\"2\" style=\"\n                    min-width: ${totalColumnWidth}; \n                    width: ${totalColumnWidth};\n                    padding: 6px 4px 3px 4px; \n                    text-align: center; \n                    font-weight: 700; \n                    background: linear-gradient(135deg, rgba(233, 236, 239, 0.9) 0%, rgba(248, 249, 250, 0.9) 100%); \n                    color: ${teamColor}; \n                    ${index === 4 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} \n                    font-size: 0.8rem;\n                    white-space: nowrap;\n                    line-height: 1.2;\n                \">\n                    <div style=\"font-size: 0.85rem; font-weight: 800; color: ${teamColor};\">${team.displayRank || team.rank}위 ${teamData?.logo || ''} ${teamData?.shortName || team.team}</div>\n                </th>`;\n            });\n            \n            // 2행: 성적\n            html += `</tr><tr style=\"background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); color: white;\">\n                <th style=\"\n                    position: sticky;\n                    left: 0;\n                    z-index: 110;\n                    min-width: 70px; \n                    width: 70px;\n                    padding: 4px 6px; \n                    text-align: center; \n                    font-weight: 600; \n                    border-right: 2px solid rgba(255,255,255,0.4); \n                    background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); \n                    font-size: 0.7rem;\n                \">성적</th>`;\n                \n            eligibleTeams.forEach((team, index) => {\n                const isLast = index === eligibleTeams.length - 1;\n                const totalColumnWidth = '170px';\n                html += `<th colspan=\"2\" style=\"\n                    min-width: ${totalColumnWidth}; \n                    width: ${totalColumnWidth};\n                    padding: 4px; \n                    text-align: center; \n                    font-weight: 600; \n                    background: rgba(255,255,255,0.9); \n                    color: #333;\n                    ${index === 4 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} \n                    font-size: 0.7rem;\n                \">${team.wins}승 ${team.losses}패 ${team.draws || 0}무 (${team.winRate?.toFixed(3) || 'N/A'})</th>`;\n            });\n                \n            // 3행: 잔여경기\n            html += `</tr><tr style=\"background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); color: white;\">\n                <th style=\"\n                    position: sticky;\n                    left: 0;\n                    z-index: 110;\n                    min-width: 70px; \n                    width: 70px;\n                    padding: 4px 6px; \n                    text-align: center; \n                    font-weight: 600; \n                    border-right: 2px solid rgba(255,255,255,0.4); \n                    background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); \n                    font-size: 0.7rem;\n                \">잔여경기</th>`;\n                \n            eligibleTeams.forEach((team, index) => {\n                const isLast = index === eligibleTeams.length - 1;\n                const totalColumnWidth = '170px';\n                html += `<th colspan=\"2\" style=\"\n                    min-width: ${totalColumnWidth}; \n                    width: ${totalColumnWidth};\n                    padding: 4px; \n                    text-align: center; \n                    font-weight: 600; \n                    background: rgba(255,255,255,0.9); \n                    color: #333;\n                    ${index === 4 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} \n                    font-size: 0.7rem;\n                \">잔여: ${team.remainingGames}경기</th>`;\n            });\n                \n            // 4행: 승률 + 컬럼 구분\n            html += `</tr><tr style=\"background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); color: white;\">\n                <th style=\"\n                    position: sticky;\n                    left: 0;\n                    z-index: 110;\n                    min-width: 70px; \n                    width: 70px;\n                    padding: 4px 6px; \n                    text-align: center; \n                    font-weight: 600; \n                    border-right: 2px solid rgba(255,255,255,0.4); \n                    background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%); \n                    font-size: 0.7rem;\n                \">승률</th>`;\n            \n            // 네 번째 헤더 행 - 컬럼 구분 (잔여경기 vs 최종성적)\n            eligibleTeams.forEach((team, index) => {\n                const isLast = index === eligibleTeams.length - 1;\n                const cellWidth = '75px';\n                const finalCellWidth = '95px';\n                html += `\n                    <th style=\"\n                        width: ${cellWidth}; \n                        min-width: ${cellWidth}; \n                        font-size: 0.7rem; \n                        padding: 4px 2px; \n                        background: rgba(255,255,255,0.1); \n                        border-right: 1px solid rgba(255,255,255,0.3);\n                        text-align: center;\n                        font-weight: 600;\n                    \">잔여 성적<br><span style=\"font-size: 0.6rem;\">(승-패/승률)</span></th>\n                    <th style=\"\n                        width: ${finalCellWidth}; \n                        min-width: ${finalCellWidth}; \n                        font-size: 0.7rem; \n                        padding: 4px 2px; \n                        background: rgba(255,255,255,0.1); \n                        ${index === 4 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')}\n                        text-align: center;\n                        font-weight: 600;\n                    \">최종 성적<br><span style=\"font-size: 0.6rem;\">(승-패-무/승률)</span></th>`;\n            });\n            \n            html += `</tr></thead><tbody>`;\n            \n            // 모든 팀의 시나리오 수집 및 승률순 정렬\n            const allScenarios = [];\n            eligibleTeams.forEach(team => {\n                for (let wins = team.remainingGames; wins >= 0; wins--) {\n                    const losses = team.remainingGames - wins;\n                    const finalWins = team.wins + wins;\n                    const finalLosses = team.losses + losses;\n                    const finalGames = finalWins + finalLosses + (team.draws || 0);\n                    const finalWinRate = finalWins / (finalWins + finalLosses); // 무승부 제외한 승률\n                    \n                    allScenarios.push({\n                        team: team.team,\n                        wins,\n                        losses,\n                        finalWinRate,\n                        remainingWinRate: wins / (wins + losses) || 0\n                    });\n                }\n            });\n            \n            // 승률별 그룹화\n            const winRateGroups = {};\n            allScenarios.forEach(scenario => {\n                const rateKey = scenario.finalWinRate.toFixed(3);\n                if (!winRateGroups[rateKey]) {\n                    winRateGroups[rateKey] = [];\n                }\n                winRateGroups[rateKey].push(scenario);\n            });\n            \n            // 승률 높은순으로 정렬하여 표시\n            const sortedRates = Object.keys(winRateGroups).sort((a, b) => parseFloat(b) - parseFloat(a));\n            \n            Object.keys(winRateGroups)\n                .sort((a, b) => parseFloat(b) - parseFloat(a))\n                .forEach(rateKey => {\n                    const scenarios = winRateGroups[rateKey];\n                    const winRate = parseFloat(rateKey);\n                    \n                    html += `<tr class=\"scenario-row\">\n                        <td style=\"font-size: 0.8rem; padding: 3px 2px; font-weight: 700; background: white; color: #2E7D32; border: 1px solid #dee2e6; text-align: center; position: sticky; left: 0; z-index: 5; width: 60px; box-shadow: 2px 0 4px rgba(0,0,0,0.1); line-height: 1.2;\">\n                            ${winRate.toFixed(3)}\n                        </td>`;\n                    \n                    eligibleTeams.forEach((team, teamIndex) => {\n                        const isLast = teamIndex === eligibleTeams.length - 1;\n                        const teamScenario = scenarios.find(s => s.team === team.team);\n                        \n                        if (teamScenario) {\n                            const remainingWinRate = teamScenario.losses === 0 && teamScenario.wins > 0 ? 1.00 :\n                                                   teamScenario.wins === 0 && teamScenario.losses > 0 ? 0.00 :\n                                                   teamScenario.wins / (teamScenario.wins + teamScenario.losses);\n                            \n                            const teamData = eligibleTeams.find(t => t.team === teamScenario.team);\n                            const finalWins = teamData.wins + teamScenario.wins;\n                            const finalLosses = teamData.losses + teamScenario.losses;\n                            const finalDraws = teamData.draws || 0;\n                            \n                            const finalWinRateBg = getWinRateBackgroundColor(teamScenario.finalWinRate);\n                            const finalWinRateTextColor = getWinRateTextColor(teamScenario.finalWinRate);\n                            const remainingWinRateBg = getWinRateBackgroundColor(remainingWinRate);\n                            const remainingWinRateTextColor = getWinRateTextColor(remainingWinRate);\n                            \n                            // 잔여경기 컬럼\n                            const cellWidth = '75px';\n                            html += `<td style=\"\n                                padding: 4px 1px; \n                                text-align: center; \n                                border: 1px solid #dee2e6; \n                                width: ${cellWidth};\n                                min-width: ${cellWidth};\n                                line-height: 1.1;\n                                background: ${remainingWinRateBg};\n                                color: ${remainingWinRateTextColor};\n                            \">\n                                <div style=\"font-size: 0.8rem; font-weight: 600;\">${teamScenario.wins}승 ${teamScenario.losses}패</div>\n                                <div style=\"font-size: 0.7rem;\">${remainingWinRate.toFixed(3)}</div>\n                            </td>`;\n                            \n                            // 최종성적 컬럼 (더 넓게)\n                            const finalCellWidth = '95px';\n                            html += `<td style=\"\n                                padding: 4px 2px; \n                                text-align: center; \n                                border: 1px solid #dee2e6; \n                                width: ${finalCellWidth};\n                                min-width: ${finalCellWidth};\n                                line-height: 1.1;\n                                white-space: nowrap;\n                                background: ${finalWinRateBg};\n                                color: ${finalWinRateTextColor};\n                                ${teamIndex === 4 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid #dee2e6;' : '')}\n                            \">\n                                <div style=\"font-size: 0.8rem; font-weight: 600;\">${finalWins}승 ${finalLosses}패 ${finalDraws}무</div>\n                                <div style=\"font-size: 0.7rem;\">${teamScenario.finalWinRate.toFixed(3)}</div>\n                            </td>`;\n                        } else {\n                            html += `<td style=\"background: #f8f9fa; border: 1px solid #dee2e6;\"></td><td style=\"background: #f8f9fa; border: 1px solid #dee2e6; ${teamIndex === 4 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid #dee2e6;' : '')}\"></td>`;\n                        }\n                    });\n                    \n                    html += `</tr>`;\n                });\n            \n            html += `</tbody></table></div>`;\n            \n            return html;\n        }\n\n        // 상세 시나리오 HTML 생성\n        function generateDetailedScenarios(topTeams) {\n            let html = `\n                <div style=\"margin-bottom: 15px;\">\n                    <h5 style=\"color: #2E7D32; margin-bottom: 10px;\">🏆 상위 5팀 상세 시나리오</h5>\n                    <p style=\"font-size: 0.9rem; color: #666; margin-bottom: 15px;\">\n                        상위 5팀의 모든 잔여경기 승패 조합과 최종 승률을 표시합니다.\n                    </p>\n                </div>\n                \n                <div style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;\">\n            `;\n            \n            topTeams.forEach((team, index) => {\n                const colors = ['#e3f2fd', '#e8f5e8', '#fff3e0', '#f3e5f5', '#fce4ec'];\n                const bgColor = colors[index] || '#f8f9fa';\n                \n                html += `\n                    <div style=\"background: ${bgColor}; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px;\">\n                        <h6 style=\"margin: 0 0 10px 0; color: #333; text-align: center;\">\n                            ${team.rank}위 ${kboTeams[team.team]?.fullName || team.team}\n                        </h6>\n                        <div style=\"text-align: center; margin-bottom: 10px; font-size: 0.9rem; color: #666;\">\n                            현재: ${team.wins}승 ${team.losses}패 ${team.draws || 0}무 ${team.winRate.toFixed(3)}<br>\n                            잔여: ${team.remainingGames}경기\n                        </div>\n                        \n                        <table style=\"width: 100%; border-collapse: collapse; font-size: 0.8rem;\">\n                            <thead>\n                                <tr style=\"background: rgba(0,0,0,0.05);\">\n                                    <th style=\"padding: 4px; border: 1px solid #ccc;\">승</th>\n                                    <th style=\"padding: 4px; border: 1px solid #ccc;\">패</th>\n                                    <th style=\"padding: 4px; border: 1px solid #ccc;\">최종승률</th>\n                                </tr>\n                            </thead>\n                            <tbody>\n                `;\n                \n                for (let wins = team.remainingGames; wins >= 0; wins--) {\n                    const losses = team.remainingGames - wins;\n                    const finalWins = team.wins + wins;\n                    const finalLosses = team.losses + losses;\n                    const finalGames = finalWins + finalLosses + (team.draws || 0);\n                    const finalWinRate = finalWins / finalGames;\n                    \n                    const rowBgColor = getWinRateColor(finalWinRate);\n                    \n                    html += `\n                        <tr style=\"background: ${rowBgColor};\">\n                            <td style=\"padding: 4px; border: 1px solid #ccc; text-align: center;\">${wins}</td>\n                            <td style=\"padding: 4px; border: 1px solid #ccc; text-align: center;\">${losses}</td>\n                            <td style=\"padding: 4px; border: 1px solid #ccc; text-align: center; font-weight: 600;\">\n                                ${(finalWinRate * 100).toFixed(1)}%\n                            </td>\n                        </tr>\n                    `;\n                }\n                \n                html += `\n                            </tbody>\n                        </table>\n                    </div>\n                `;\n            });\n            \n            html += `</div>`;\n            \n            return html;\n        }\n\n\n        // 승률에 따른 배경색 반환\n        function getWinRateColor(winRate) {\n            if (winRate >= 0.700) return '#c8e6c9';      // 진한 녹색\n            if (winRate >= 0.650) return '#dcedc8';      // 연한 녹색\n            if (winRate >= 0.600) return '#f0f4c3';      // 연한 황녹색\n            if (winRate >= 0.550) return '#fff9c4';      // 연한 노란색\n            if (winRate >= 0.500) return '#fff3e0';      // 연한 주황색\n            if (winRate >= 0.450) return '#ffccbc';      // 연한 주황색\n            if (winRate >= 0.400) return '#ffcdd2';      // 연한 빨간색\n            return '#ffebee';                             // 매우 연한 빨간색\n        }\n\n        // 0.5 기준 승률 색상 반환 함수\n        function getWinRateBackgroundColor(winRate) {\n            if (winRate > 0.5) {\n                // 0.5 초과: 녹색 계열 (진하게)\n                const intensity = Math.min((winRate - 0.5) * 2, 1); // 0.5-1.0을 0-1로 변환\n                const greenValue = Math.floor(200 - intensity * 80); // 200에서 120으로\n                return `linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%)`;\n            } else if (winRate < 0.5) {\n                // 0.5 미만: 빨간색 계열\n                const intensity = Math.min((0.5 - winRate) * 2, 1); // 0.5-0을 0-1로 변환\n                return `linear-gradient(135deg, #f44336 0%, #e57373 100%)`;\n            } else {\n                // 정확히 0.5: 노란색 계열\n                return `linear-gradient(135deg, #FF9800 0%, #FFB74D 100%)`;\n            }\n        }\n\n        // 0.5 기준 승률 텍스트 색상 반환 함수\n        function getWinRateTextColor(winRate) {\n            return 'white'; // 모든 배경이 진한 색이므로 흰색 텍스트\n        }\n\n        // 승률에 따른 CSS 클래스 반환\n        function getWinRateClass(winRate) {\n            if (winRate >= 0.700) return 'rate-excellent';\n            if (winRate >= 0.650) return 'rate-very-good';  \n            if (winRate >= 0.600) return 'rate-good';\n            if (winRate >= 0.550) return 'rate-decent';\n            if (winRate >= 0.500) return 'rate-average';\n            if (winRate >= 0.450) return 'rate-below';\n            if (winRate >= 0.400) return 'rate-poor';\n            return 'rate-very-poor';\n        }\n\n        // 기존 초기화 함수에 시나리오 분석 초기화 추가\n        document.addEventListener('DOMContentLoaded', function() {\n            // 데이터 로딩 후 시나리오 분석 초기화\n            setTimeout(() => {\n                initializeScenarioAnalysis();\n                // 페이지 로드 시 바로 매트릭스 표시\n                setTimeout(() => {\n                    if (currentStandings && currentStandings.length > 0) {\n                        showScenarioMatrix(false); // 페이지 로드 시에는 스크롤하지 않음\n                    } else {\n                    }\n                }, 500); // 추가 딜레이\n            }, 3000); // 기존 데이터 로딩 후 실행 (3초로 늘림)\n            \n            // 플로팅 공유 버튼 초기화\n            initializeFloatingShare();\n            \n            // 탑으로 가기 버튼 초기화 (딜레이 없이 바로 실행)\n            initializeScrollToTop();\n        });\n\n        // 플로팅 공유 버튼 기능\n        function initializeFloatingShare() {\n            const shareToggle = document.getElementById('shareToggle');\n            const shareOptions = document.getElementById('shareOptions');\n            const shareButtons = document.querySelectorAll('.share-btn');\n\n            if (!shareToggle || !shareOptions) return;\n\n            // 공유 옵션 토글\n            shareToggle.addEventListener('click', function() {\n                shareOptions.classList.toggle('show');\n            });\n\n            // 외부 클릭 시 공유 옵션 닫기\n            document.addEventListener('click', function(e) {\n                if (!shareToggle.contains(e.target) && !shareOptions.contains(e.target)) {\n                    shareOptions.classList.remove('show');\n                }\n            });\n\n            // 각 공유 버튼 이벤트\n            shareButtons.forEach(button => {\n                button.addEventListener('click', function() {\n                    const type = this.getAttribute('data-type');\n                    const url = window.location.href;\n                    const title = 'KBO 2025 우승 매직넘버 계산기';\n                    const text = 'KBO 2025 매직넘버 계산기! 10개 구단의 플레이오프 진출 조건, 우승 가능성, 팀별 순위표와 상대전적을 실시간으로 확인하세요.';\n\n                    switch(type) {\n                        case 'copy':\n                            copyToClipboard(url);\n                            break;\n                        case 'threads':\n                            window.open(`https://threads.net/intent/post?text=${encodeURIComponent(text + ' ' + url)}`, '_blank');\n                            break;\n                        case 'twitter':\n                            window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`, '_blank');\n                            break;\n                        case 'facebook':\n                            window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}&quote=${encodeURIComponent(text)}`, '_blank');\n                            break;\n                    }\n                    \n                    // 공유 후 옵션 닫기\n                    shareOptions.classList.remove('show');\n                });\n            });\n        }\n\n        // URL 복사 기능\n        function copyToClipboard(text) {\n            if (navigator.clipboard && window.isSecureContext) {\n                navigator.clipboard.writeText(text).then(() => {\n                    showCopySuccess();\n                }).catch(() => {\n                    fallbackCopyTextToClipboard(text);\n                });\n            } else {\n                fallbackCopyTextToClipboard(text);\n            }\n        }\n\n        // 구형 브라우저 대응 복사 기능\n        function fallbackCopyTextToClipboard(text) {\n            const textArea = document.createElement(\"textarea\");\n            textArea.value = text;\n            textArea.style.position = \"fixed\";\n            textArea.style.left = \"-999999px\";\n            textArea.style.top = \"-999999px\";\n            document.body.appendChild(textArea);\n            textArea.focus();\n            textArea.select();\n            \n            try {\n                document.execCommand('copy');\n                showCopySuccess();\n            } catch (err) {\n                logger.error('복사 실패:', err);\n            }\n            \n            document.body.removeChild(textArea);\n        }\n\n        // 복사 성공 메시지\n        function showCopySuccess() {\n            const shareButtons = document.querySelectorAll('.share-btn');\n            const copyButton = shareButtons[0];\n            if (copyButton) {\n                const originalText = copyButton.querySelector('span').textContent;\n                copyButton.querySelector('span').textContent = '복사됨!';\n                copyButton.style.color = '#4caf50';\n                \n                setTimeout(() => {\n                    copyButton.querySelector('span').textContent = originalText;\n                    copyButton.style.color = '';\n                }, 2000);\n            }\n        }\n\n        // 탑으로 가기 버튼 기능\n        function initializeScrollToTop() {\n            const scrollToTopButton = document.getElementById('scrollToTop');\n            \n            if (!scrollToTopButton) {\n                logger.warn('탑으로 가기 버튼을 찾을 수 없습니다.');\n                return;\n            }\n            \n            // 스크롤 상태 확인 및 버튼 표시/숨김 함수\n            function updateScrollButtonVisibility() {\n                if (window.pageYOffset > 300) {\n                    scrollToTopButton.classList.add('show');\n                } else {\n                    scrollToTopButton.classList.remove('show');\n                }\n            }\n            \n            // 페이지 로드 시 즉시 스크롤 상태 확인\n            updateScrollButtonVisibility();\n            \n            // 스크롤 이벤트 리스너\n            window.addEventListener('scroll', updateScrollButtonVisibility);\n            \n            // 버튼 클릭 이벤트\n            scrollToTopButton.addEventListener('click', function() {\n                window.scrollTo({\n                    top: 0,\n                    behavior: 'smooth'\n                });\n            });\n            \n            logger.log('탑으로 가기 버튼 초기화 완료');\n        }\n\n        // 전체 팀 경우의수 새창에서 보기 함수\n        function showAllTeamsScenario() {\n            if (!currentStandings || currentStandings.length === 0) {\n                alert('데이터를 불러오는 중입니다. 잠시 후 다시 시도해 주세요.');\n                return;\n            }\n            \n            // 전체 10팀의 승률 기준 시나리오 매트릭스 생성 (필터링 없음)\n            const allTeams = currentStandings.slice(0, 10);\n            const fullScenarioMatrix = generateScenarioMatrix(allTeams, true);\n            \n            // 새 창 열기\n            const newWindow = window.open('', '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');\n            \n            if (newWindow) {\n                newWindow.document.write(`\n                    <!DOCTYPE html>\n                    <html lang=\"ko\">\n                    <head>\n                        <meta charset=\"UTF-8\">\n                        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n                        <title>KBO 전체 팀 경우의수 분석</title>\n                        <style>\n                            body { \n                                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; \n                                margin: 20px; \n                                background: #f5f5f5; \n                                line-height: 1.6;\n                            }\n                            .header { \n                                background: white; \n                                padding: 20px; \n                                border-radius: 12px; \n                                margin-bottom: 20px; \n                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n                            }\n                            .header h1 { \n                                color: #2E7D32; \n                                margin: 0 0 10px 0; \n                                font-size: 28px;\n                            }\n                            .header p { \n                                color: #666; \n                                margin: 5px 0; \n                                font-size: 14px;\n                            }\n                            .magic-table-container { \n                                background: white; \n                                border-radius: 12px; \n                                padding: 20px; \n                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n                                overflow-x: auto;\n                            }\n                            .magic-number-table {\n                                width: 100%;\n                                border-collapse: collapse;\n                                margin: 0 auto;\n                                font-size: 0.85rem;\n                                background: white;\n                            }\n                            .magic-number-table th {\n                                background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%);\n                                color: white;\n                                padding: 12px 8px;\n                                text-align: center;\n                                font-weight: 600;\n                                border: 1px solid #ddd;\n                                font-size: 0.8rem;\n                            }\n                            .magic-number-table td {\n                                padding: 10px 8px;\n                                text-align: center;\n                                border: 1px solid #ddd;\n                                font-size: 0.8rem;\n                            }\n                            .magic-number-table tr:nth-child(even) {\n                                background-color: #f8f9fa;\n                            }\n                            .magic-number-table tr:hover {\n                                background-color: #e8f5e9;\n                            }\n                            .team-name {\n                                text-align: left !important;\n                                font-weight: 600;\n                            }\n                            .team-logo {\n                                width: 20px; \n                                height: 20px; \n                                object-fit: contain; \n                                margin-right: 5px;\n                            }\n                            .team-logo { width: 24px; height: 24px; object-fit: contain; }\n                            \n                            @media print {\n                                body { margin: 10px; background: white; }\n                                .header, .matrix-container { box-shadow: none; }\n                                .current-win-rate { \n                                    animation: none !important;\n                                    background-color: #fff3cd !important;\n                                }\n                            }\n                        </style>\n                    </head>\n                    <body>\n                        <div class=\"header\">\n                            <h1>🎲 KBO 2025 전체 팀 경우의수 분석</h1>\n                            <p>📅 업데이트: ${new Date().toLocaleDateString('ko-KR', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' })}</p>\n                            <p>📊 KBO 리그 전체 10개 팀의 모든 승패 시나리오와 최종 순위 경우의수를 분석합니다.</p>\n                            <p>🏆 상단 5개 팀: 플레이오프 진출 가능 | 하단 5개 팀: 일반 순위</p>\n                        </div>\n                        <div class=\"magic-table-container\">\n                            ${fullScenarioMatrix}\n                        </div>\n                    </body>\n                    </html>\n                `);\n                newWindow.document.close();\n            } else {\n                alert('팝업이 차단되었습니다. 브라우저 설정에서 팝업을 허용해 주세요.');\n            }\n        }\n        \n\n        // 전역 함수로 등록\n        window.showAllTeamsScenario = showAllTeamsScenario;\n\n","usedDeprecatedRules":[]}]
